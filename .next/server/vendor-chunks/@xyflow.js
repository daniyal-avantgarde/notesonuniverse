"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@xyflow";
exports.ids = ["vendor-chunks/@xyflow"];
exports.modules = {

/***/ "(ssr)/./node_modules/@xyflow/react/dist/esm/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/esm/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Background: () => (/* binding */ Background),\n/* harmony export */   BackgroundVariant: () => (/* binding */ BackgroundVariant),\n/* harmony export */   BaseEdge: () => (/* binding */ BaseEdge),\n/* harmony export */   BezierEdge: () => (/* binding */ BezierEdge),\n/* harmony export */   ConnectionLineType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode),\n/* harmony export */   ControlButton: () => (/* binding */ ControlButton),\n/* harmony export */   Controls: () => (/* binding */ Controls),\n/* harmony export */   EdgeLabelRenderer: () => (/* binding */ EdgeLabelRenderer),\n/* harmony export */   EdgeText: () => (/* binding */ EdgeText),\n/* harmony export */   Handle: () => (/* binding */ Handle),\n/* harmony export */   MarkerType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType),\n/* harmony export */   MiniMap: () => (/* binding */ MiniMap),\n/* harmony export */   NodeResizeControl: () => (/* binding */ NodeResizeControl),\n/* harmony export */   NodeResizer: () => (/* binding */ NodeResizer),\n/* harmony export */   NodeToolbar: () => (/* binding */ NodeToolbar),\n/* harmony export */   PanOnScrollMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode),\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   Position: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position),\n/* harmony export */   ReactFlow: () => (/* binding */ index),\n/* harmony export */   ReactFlowProvider: () => (/* binding */ ReactFlowProvider),\n/* harmony export */   ResizeControlVariant: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode),\n/* harmony export */   SimpleBezierEdge: () => (/* binding */ SimpleBezierEdge),\n/* harmony export */   SmoothStepEdge: () => (/* binding */ SmoothStepEdge),\n/* harmony export */   StepEdge: () => (/* binding */ StepEdge),\n/* harmony export */   StraightEdge: () => (/* binding */ StraightEdge),\n/* harmony export */   ViewportPortal: () => (/* binding */ ViewportPortal),\n/* harmony export */   addEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge),\n/* harmony export */   applyEdgeChanges: () => (/* binding */ applyEdgeChanges),\n/* harmony export */   applyNodeChanges: () => (/* binding */ applyNodeChanges),\n/* harmony export */   getBezierEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath),\n/* harmony export */   getConnectedEdges: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectedEdges),\n/* harmony export */   getEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgeCenter),\n/* harmony export */   getIncomers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getIncomers),\n/* harmony export */   getNodesBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds),\n/* harmony export */   getOutgoers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOutgoers),\n/* harmony export */   getSimpleBezierPath: () => (/* binding */ getSimpleBezierPath),\n/* harmony export */   getSmoothStepPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   reconnectEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.reconnectEdge),\n/* harmony export */   useConnection: () => (/* binding */ useConnection),\n/* harmony export */   useEdges: () => (/* binding */ useEdges),\n/* harmony export */   useEdgesState: () => (/* binding */ useEdgesState),\n/* harmony export */   useHandleConnections: () => (/* binding */ useHandleConnections),\n/* harmony export */   useInternalNode: () => (/* binding */ useInternalNode),\n/* harmony export */   useKeyPress: () => (/* binding */ useKeyPress),\n/* harmony export */   useNodeConnections: () => (/* binding */ useNodeConnections),\n/* harmony export */   useNodeId: () => (/* binding */ useNodeId),\n/* harmony export */   useNodes: () => (/* binding */ useNodes),\n/* harmony export */   useNodesData: () => (/* binding */ useNodesData),\n/* harmony export */   useNodesInitialized: () => (/* binding */ useNodesInitialized),\n/* harmony export */   useNodesState: () => (/* binding */ useNodesState),\n/* harmony export */   useOnSelectionChange: () => (/* binding */ useOnSelectionChange),\n/* harmony export */   useOnViewportChange: () => (/* binding */ useOnViewportChange),\n/* harmony export */   useReactFlow: () => (/* binding */ useReactFlow),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStoreApi: () => (/* binding */ useStoreApi),\n/* harmony export */   useUpdateNodeInternals: () => (/* binding */ useUpdateNodeInternals),\n/* harmony export */   useViewport: () => (/* binding */ useViewport)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! classcat */ \"(ssr)/./node_modules/classcat/index.js\");\n/* harmony import */ var _xyflow_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @xyflow/system */ \"(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/./node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ ConnectionLineType,ConnectionMode,MarkerType,PanOnScrollMode,Position,ResizeControlVariant,SelectionMode,addEdge,getBezierEdgeCenter,getBezierPath,getConnectedEdges,getEdgeCenter,getIncomers,getNodesBounds,getOutgoers,getSmoothStepPath,getStraightPath,getViewportForBounds,reconnectEdge,Background,BackgroundVariant,BaseEdge,BezierEdge,ControlButton,Controls,EdgeLabelRenderer,EdgeText,Handle,MiniMap,NodeResizeControl,NodeResizer,NodeToolbar,Panel,ReactFlow,ReactFlowProvider,SimpleBezierEdge,SmoothStepEdge,StepEdge,StraightEdge,ViewportPortal,applyEdgeChanges,applyNodeChanges,getSimpleBezierPath,isEdge,isNode,useConnection,useEdges,useEdgesState,useHandleConnections,useInternalNode,useKeyPress,useNodeConnections,useNodeId,useNodes,useNodesData,useNodesInitialized,useNodesState,useOnSelectionChange,useOnViewportChange,useReactFlow,useStore,useStoreApi,useUpdateNodeInternals,useViewport auto */ \n\n\n\n\n\n\n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider$1 = StoreContext.Provider;\nconst zustandErrorMessage = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error001']();\n/**\n * This hook can be used to subscribe to internal state changes of the React Flow\n * component. The `useStore` hook is re-exported from the [Zustand](https://github.com/pmndrs/zustand)\n * state management library, so you should check out their docs for more details.\n *\n * @public\n * @param selector - A selector function that returns a slice of the flow's internal state.\n * Extracting or transforming just the state you need is a good practice to avoid unnecessary\n * re-renders.\n * @param equalityFn - A function to compare the previous and next value. This is incredibly useful\n * for preventing unnecessary re-renders. Good sensible defaults are using `Object.is` or importing\n * `zustand/shallow`, but you can be as granular as you like.\n * @returns The selected state slice.\n *\n * @example\n * ```ts\n * const nodes = useStore((state) => state.nodes);\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStore(selector, equalityFn) {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.useStoreWithEqualityFn)(store, selector, equalityFn);\n}\n/**\n * In some cases, you might need to access the store directly. This hook returns the store object which can be used on demand to access the state or dispatch actions.\n *\n * @returns The store object.\n * @example\n * ```ts\n * const store = useStoreApi();\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStoreApi() {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useStoreApi.useMemo\": ()=>({\n                getState: store.getState,\n                setState: store.setState,\n                subscribe: store.subscribe\n            })\n    }[\"useStoreApi.useMemo\"], [\n        store\n    ]);\n}\nconst style = {\n    display: 'none'\n};\nconst ariaLiveStyle = {\n    position: 'absolute',\n    width: 1,\n    height: 1,\n    margin: -1,\n    border: 0,\n    padding: 0,\n    overflow: 'hidden',\n    clip: 'rect(0px, 0px, 0px, 0px)',\n    clipPath: 'inset(100%)'\n};\nconst ARIA_NODE_DESC_KEY = 'react-flow__node-desc';\nconst ARIA_EDGE_DESC_KEY = 'react-flow__edge-desc';\nconst ARIA_LIVE_MESSAGE = 'react-flow__aria-live';\nconst selector$o = (s)=>s.ariaLiveMessage;\nfunction AriaLiveMessage({ rfId }) {\n    const ariaLiveMessage = useStore(selector$o);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        id: `${ARIA_LIVE_MESSAGE}-${rfId}`,\n        \"aria-live\": \"assertive\",\n        \"aria-atomic\": \"true\",\n        style: ariaLiveStyle,\n        children: ariaLiveMessage\n    });\n}\nfunction A11yDescriptions({ rfId, disableKeyboardA11y }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n                id: `${ARIA_NODE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: [\n                    \"Press enter or space to select a node.\",\n                    !disableKeyboardA11y && 'You can then use the arrow keys to move the node around.',\n                    \" Press delete to remove it and escape to cancel.\",\n                    ' '\n                ]\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_EDGE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: \"Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.\"\n            }),\n            !disableKeyboardA11y && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AriaLiveMessage, {\n                rfId: rfId\n            })\n        ]\n    });\n}\nconst selector$n = (s)=>s.userSelectionActive ? 'none' : 'all';\n/**\n * The `<Panel />` component helps you position content above the viewport.\n * It is used internally by the [`<MiniMap />`](/api-reference/components/minimap)\n * and [`<Controls />`](/api-reference/components/controls) components.\n *\n * @public\n *\n * @example\n * ```jsx\n *import { ReactFlow, Background, Panel } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[]} fitView>\n *      <Panel position=\"top-left\">top-left</Panel>\n *      <Panel position=\"top-center\">top-center</Panel>\n *      <Panel position=\"top-right\">top-right</Panel>\n *      <Panel position=\"bottom-left\">bottom-left</Panel>\n *      <Panel position=\"bottom-center\">bottom-center</Panel>\n *      <Panel position=\"bottom-right\">bottom-right</Panel>\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const Panel = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ position = 'top-left', children, className, style, ...rest }, ref)=>{\n    const pointerEvents = useStore(selector$n);\n    const positionClasses = `${position}`.split('-');\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__panel',\n            className,\n            ...positionClasses\n        ]),\n        style: {\n            ...style,\n            pointerEvents\n        },\n        ref: ref,\n        ...rest,\n        children: children\n    });\n});\nPanel.displayName = 'Panel';\nfunction Attribution({ proOptions, position = 'bottom-right' }) {\n    if (proOptions?.hideAttribution) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        className: \"react-flow__attribution\",\n        \"data-message\": \"Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"https://reactflow.dev\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\",\n            \"aria-label\": \"React Flow attribution\",\n            children: \"React Flow\"\n        })\n    });\n}\nconst selector$m = (s)=>{\n    const selectedNodes = [];\n    const selectedEdges = [];\n    for (const [, node] of s.nodeLookup){\n        if (node.selected) {\n            selectedNodes.push(node.internals.userNode);\n        }\n    }\n    for (const [, edge] of s.edgeLookup){\n        if (edge.selected) {\n            selectedEdges.push(edge);\n        }\n    }\n    return {\n        selectedNodes,\n        selectedEdges\n    };\n};\nconst selectId = (obj)=>obj.id;\nfunction areEqual(a, b) {\n    return (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) && (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId));\n}\nfunction SelectionListenerInner({ onSelectionChange }) {\n    const store = useStoreApi();\n    const { selectedNodes, selectedEdges } = useStore(selector$m, areEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionListenerInner.useEffect\": ()=>{\n            const params = {\n                nodes: selectedNodes,\n                edges: selectedEdges\n            };\n            onSelectionChange?.(params);\n            store.getState().onSelectionChangeHandlers.forEach({\n                \"SelectionListenerInner.useEffect\": (fn)=>fn(params)\n            }[\"SelectionListenerInner.useEffect\"]);\n        }\n    }[\"SelectionListenerInner.useEffect\"], [\n        selectedNodes,\n        selectedEdges,\n        onSelectionChange\n    ]);\n    return null;\n}\nconst changeSelector = (s)=>!!s.onSelectionChangeHandlers;\nfunction SelectionListener({ onSelectionChange }) {\n    const storeHasSelectionChangeHandlers = useStore(changeSelector);\n    if (onSelectionChange || storeHasSelectionChangeHandlers) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListenerInner, {\n            onSelectionChange: onSelectionChange\n        });\n    }\n    return null;\n}\nconst defaultNodeOrigin = [\n    0,\n    0\n];\nconst defaultViewport = {\n    x: 0,\n    y: 0,\n    zoom: 1\n};\n/*\n * This component helps us to update the store with the values coming from the user.\n * We distinguish between values we can update directly with `useDirectStoreUpdater` (like `snapGrid`)\n * and values that have a dedicated setter function in the store (like `setNodes`).\n */ // These fields exist in the global store, and we need to keep them up to date\nconst reactFlowFieldsToTrack = [\n    'nodes',\n    'edges',\n    'defaultNodes',\n    'defaultEdges',\n    'onConnect',\n    'onConnectStart',\n    'onConnectEnd',\n    'onClickConnectStart',\n    'onClickConnectEnd',\n    'nodesDraggable',\n    'nodesConnectable',\n    'nodesFocusable',\n    'edgesFocusable',\n    'edgesReconnectable',\n    'elevateNodesOnSelect',\n    'elevateEdgesOnSelect',\n    'minZoom',\n    'maxZoom',\n    'nodeExtent',\n    'onNodesChange',\n    'onEdgesChange',\n    'elementsSelectable',\n    'connectionMode',\n    'snapGrid',\n    'snapToGrid',\n    'translateExtent',\n    'connectOnClick',\n    'defaultEdgeOptions',\n    'fitView',\n    'fitViewOptions',\n    'onNodesDelete',\n    'onEdgesDelete',\n    'onDelete',\n    'onNodeDrag',\n    'onNodeDragStart',\n    'onNodeDragStop',\n    'onSelectionDrag',\n    'onSelectionDragStart',\n    'onSelectionDragStop',\n    'onMoveStart',\n    'onMove',\n    'onMoveEnd',\n    'noPanClassName',\n    'nodeOrigin',\n    'autoPanOnConnect',\n    'autoPanOnNodeDrag',\n    'onError',\n    'connectionRadius',\n    'isValidConnection',\n    'selectNodesOnDrag',\n    'nodeDragThreshold',\n    'onBeforeDelete',\n    'debug',\n    'autoPanSpeed',\n    'paneClickDistance'\n];\n// rfId doesn't exist in ReactFlowProps, but it's one of the fields we want to update\nconst fieldsToTrack = [\n    ...reactFlowFieldsToTrack,\n    'rfId'\n];\nconst selector$l = (s)=>({\n        setNodes: s.setNodes,\n        setEdges: s.setEdges,\n        setMinZoom: s.setMinZoom,\n        setMaxZoom: s.setMaxZoom,\n        setTranslateExtent: s.setTranslateExtent,\n        setNodeExtent: s.setNodeExtent,\n        reset: s.reset,\n        setDefaultNodesAndEdges: s.setDefaultNodesAndEdges,\n        setPaneClickDistance: s.setPaneClickDistance\n    });\nconst initPrevValues = {\n    /*\n     * these are values that are also passed directly to other components\n     * than the StoreUpdater. We can reduce the number of setStore calls\n     * by setting the same values here as prev fields.\n     */ translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n    nodeOrigin: defaultNodeOrigin,\n    minZoom: 0.5,\n    maxZoom: 2,\n    elementsSelectable: true,\n    noPanClassName: 'nopan',\n    rfId: '1',\n    paneClickDistance: 0\n};\nfunction StoreUpdater(props) {\n    const { setNodes, setEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, setDefaultNodesAndEdges, setPaneClickDistance } = useStore(selector$l, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"StoreUpdater.useEffect\": ()=>{\n            setDefaultNodesAndEdges(props.defaultNodes, props.defaultEdges);\n            return ({\n                \"StoreUpdater.useEffect\": ()=>{\n                    // when we reset the store we also need to reset the previous fields\n                    previousFields.current = initPrevValues;\n                    reset();\n                }\n            })[\"StoreUpdater.useEffect\"];\n        }\n    }[\"StoreUpdater.useEffect\"], []);\n    const previousFields = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(initPrevValues);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"StoreUpdater.useEffect\": ()=>{\n            for (const fieldName of fieldsToTrack){\n                const fieldValue = props[fieldName];\n                const previousFieldValue = previousFields.current[fieldName];\n                if (fieldValue === previousFieldValue) continue;\n                if (typeof props[fieldName] === 'undefined') continue;\n                // Custom handling with dedicated setters for some fields\n                if (fieldName === 'nodes') setNodes(fieldValue);\n                else if (fieldName === 'edges') setEdges(fieldValue);\n                else if (fieldName === 'minZoom') setMinZoom(fieldValue);\n                else if (fieldName === 'maxZoom') setMaxZoom(fieldValue);\n                else if (fieldName === 'translateExtent') setTranslateExtent(fieldValue);\n                else if (fieldName === 'nodeExtent') setNodeExtent(fieldValue);\n                else if (fieldName === 'paneClickDistance') setPaneClickDistance(fieldValue);\n                else if (fieldName === 'fitView') store.setState({\n                    fitViewQueued: fieldValue\n                });\n                else if (fieldName === 'fitViewOptions') store.setState({\n                    fitViewOptions: fieldValue\n                });\n                else store.setState({\n                    [fieldName]: fieldValue\n                });\n            }\n            previousFields.current = props;\n        }\n    }[\"StoreUpdater.useEffect\"], // Only re-run the effect if one of the fields we track changes\n    fieldsToTrack.map({\n        \"StoreUpdater.useEffect\": (fieldName)=>props[fieldName]\n    }[\"StoreUpdater.useEffect\"]));\n    return null;\n}\nfunction getMediaQuery() {\n    if (true) {\n        return null;\n    }\n    return window.matchMedia('(prefers-color-scheme: dark)');\n}\n/**\n * Hook for receiving the current color mode class 'dark' or 'light'.\n *\n * @internal\n * @param colorMode - The color mode to use ('dark', 'light' or 'system')\n */ function useColorModeClass(colorMode) {\n    const [colorModeClass, setColorModeClass] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(colorMode === 'system' ? null : colorMode);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useColorModeClass.useEffect\": ()=>{\n            if (colorMode !== 'system') {\n                setColorModeClass(colorMode);\n                return;\n            }\n            const mediaQuery = getMediaQuery();\n            const updateColorModeClass = {\n                \"useColorModeClass.useEffect.updateColorModeClass\": ()=>setColorModeClass(mediaQuery?.matches ? 'dark' : 'light')\n            }[\"useColorModeClass.useEffect.updateColorModeClass\"];\n            updateColorModeClass();\n            mediaQuery?.addEventListener('change', updateColorModeClass);\n            return ({\n                \"useColorModeClass.useEffect\": ()=>{\n                    mediaQuery?.removeEventListener('change', updateColorModeClass);\n                }\n            })[\"useColorModeClass.useEffect\"];\n        }\n    }[\"useColorModeClass.useEffect\"], [\n        colorMode\n    ]);\n    return colorModeClass !== null ? colorModeClass : getMediaQuery()?.matches ? 'dark' : 'light';\n}\nconst defaultDoc = typeof document !== 'undefined' ? document : null;\n/**\n * This hook lets you listen for specific key codes and tells you whether they are\n * currently pressed or not.\n *\n * @public\n * @param options - Options\n *\n * @example\n * ```tsx\n *import { useKeyPress } from '@xyflow/react';\n *\n *export default function () {\n *  const spacePressed = useKeyPress('Space');\n *  const cmdAndSPressed = useKeyPress(['Meta+s', 'Strg+s']);\n *\n *  return (\n *    <div>\n *     {spacePressed && <p>Space pressed!</p>}\n *     {cmdAndSPressed && <p>Cmd + S pressed!</p>}\n *    </div>\n *  );\n *}\n *```\n */ function useKeyPress(/**\n * The key code (string or array of strings) specifies which key(s) should trigger\n * an action.\n *\n * A **string** can represent:\n * - A **single key**, e.g. `'a'`\n * - A **key combination**, using `'+'` to separate keys, e.g. `'a+d'`\n *\n * An  **array of strings** represents **multiple possible key inputs**. For example, `['a', 'd+s']`\n * means the user can press either the single key `'a'` or the combination of `'d'` and `'s'`.\n * @default null\n */ keyCode = null, options = {\n    target: defaultDoc,\n    actInsideInputWithModifier: true\n}) {\n    const [keyPressed, setKeyPressed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // we need to remember if a modifier key is pressed in order to track it\n    const modifierPressed = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // we need to remember the pressed keys in order to support combinations\n    const pressedKeys = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set([]));\n    /*\n     * keyCodes = array with single keys [['a']] or key combinations [['a', 's']]\n     * keysToWatch = array with all keys flattened ['a', 'd', 'ShiftLeft']\n     * used to check if we store event.code or event.key. When the code is in the list of keysToWatch\n     * we use the code otherwise the key. Explainer: When you press the left \"command\" key, the code is \"MetaLeft\"\n     * and the key is \"Meta\". We want users to be able to pass keys and codes so we assume that the key is meant when\n     * we can't find it in the list of keysToWatch.\n     */ const [keyCodes, keysToWatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useKeyPress.useMemo\": ()=>{\n            if (keyCode !== null) {\n                const keyCodeArr = Array.isArray(keyCode) ? keyCode : [\n                    keyCode\n                ];\n                const keys = keyCodeArr.filter({\n                    \"useKeyPress.useMemo.keys\": (kc)=>typeof kc === 'string'\n                }[\"useKeyPress.useMemo.keys\"])/*\n                 * we first replace all '+' with '\\n'  which we will use to split the keys on\n                 * then we replace '\\n\\n' with '\\n+', this way we can also support the combination 'key++'\n                 * in the end we simply split on '\\n' to get the key array\n                 */ .map({\n                    \"useKeyPress.useMemo.keys\": (kc)=>kc.replace('+', '\\n').replace('\\n\\n', '\\n+').split('\\n')\n                }[\"useKeyPress.useMemo.keys\"]);\n                const keysFlat = keys.reduce({\n                    \"useKeyPress.useMemo.keysFlat\": (res, item)=>res.concat(...item)\n                }[\"useKeyPress.useMemo.keysFlat\"], []);\n                return [\n                    keys,\n                    keysFlat\n                ];\n            }\n            return [\n                [],\n                []\n            ];\n        }\n    }[\"useKeyPress.useMemo\"], [\n        keyCode\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useKeyPress.useEffect\": ()=>{\n            const target = options?.target ?? defaultDoc;\n            const actInsideInputWithModifier = options?.actInsideInputWithModifier ?? true;\n            if (keyCode !== null) {\n                const downHandler = {\n                    \"useKeyPress.useEffect.downHandler\": (event)=>{\n                        modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey || event.altKey;\n                        const preventAction = (!modifierPressed.current || modifierPressed.current && !actInsideInputWithModifier) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event);\n                        if (preventAction) {\n                            return false;\n                        }\n                        const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                        pressedKeys.current.add(event[keyOrCode]);\n                        if (isMatchingKey(keyCodes, pressedKeys.current, false)) {\n                            const target = event.composedPath?.()?.[0] || event.target;\n                            const isInteractiveElement = target?.nodeName === 'BUTTON' || target?.nodeName === 'A';\n                            if (options.preventDefault !== false && (modifierPressed.current || !isInteractiveElement)) {\n                                event.preventDefault();\n                            }\n                            setKeyPressed(true);\n                        }\n                    }\n                }[\"useKeyPress.useEffect.downHandler\"];\n                const upHandler = {\n                    \"useKeyPress.useEffect.upHandler\": (event)=>{\n                        const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                        if (isMatchingKey(keyCodes, pressedKeys.current, true)) {\n                            setKeyPressed(false);\n                            pressedKeys.current.clear();\n                        } else {\n                            pressedKeys.current.delete(event[keyOrCode]);\n                        }\n                        // fix for Mac: when cmd key is pressed, keyup is not triggered for any other key, see: https://stackoverflow.com/questions/27380018/when-cmd-key-is-kept-pressed-keyup-is-not-triggered-for-any-other-key\n                        if (event.key === 'Meta') {\n                            pressedKeys.current.clear();\n                        }\n                        modifierPressed.current = false;\n                    }\n                }[\"useKeyPress.useEffect.upHandler\"];\n                const resetHandler = {\n                    \"useKeyPress.useEffect.resetHandler\": ()=>{\n                        pressedKeys.current.clear();\n                        setKeyPressed(false);\n                    }\n                }[\"useKeyPress.useEffect.resetHandler\"];\n                target?.addEventListener('keydown', downHandler);\n                target?.addEventListener('keyup', upHandler);\n                window.addEventListener('blur', resetHandler);\n                window.addEventListener('contextmenu', resetHandler);\n                return ({\n                    \"useKeyPress.useEffect\": ()=>{\n                        target?.removeEventListener('keydown', downHandler);\n                        target?.removeEventListener('keyup', upHandler);\n                        window.removeEventListener('blur', resetHandler);\n                        window.removeEventListener('contextmenu', resetHandler);\n                    }\n                })[\"useKeyPress.useEffect\"];\n            }\n        }\n    }[\"useKeyPress.useEffect\"], [\n        keyCode,\n        setKeyPressed\n    ]);\n    return keyPressed;\n}\n// utils\nfunction isMatchingKey(keyCodes, pressedKeys, isUp) {\n    return keyCodes/*\n         * we only want to compare same sizes of keyCode definitions\n         * and pressed keys. When the user specified 'Meta' as a key somewhere\n         * this would also be truthy without this filter when user presses 'Meta' + 'r'\n         */ .filter((keys)=>isUp || keys.length === pressedKeys.size)/*\n         * since we want to support multiple possibilities only one of the\n         * combinations need to be part of the pressed keys\n         */ .some((keys)=>keys.every((k)=>pressedKeys.has(k)));\n}\nfunction useKeyOrCode(eventCode, keysToWatch) {\n    return keysToWatch.includes(eventCode) ? 'code' : 'key';\n}\n/**\n * Hook for getting viewport helper functions.\n *\n * @internal\n * @returns viewport helper functions\n */ const useViewportHelper = ()=>{\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useViewportHelper.useMemo\": ()=>{\n            return {\n                zoomIn: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleBy(1.2, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                zoomOut: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleBy(1 / 1.2, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                zoomTo: ({\n                    \"useViewportHelper.useMemo\": (zoomLevel, options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleTo(zoomLevel, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                getZoom: ({\n                    \"useViewportHelper.useMemo\": ()=>store.getState().transform[2]\n                })[\"useViewportHelper.useMemo\"],\n                setViewport: ({\n                    \"useViewportHelper.useMemo\": async (viewport, options)=>{\n                        const { transform: [tX, tY, tZoom], panZoom } = store.getState();\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport({\n                            x: viewport.x ?? tX,\n                            y: viewport.y ?? tY,\n                            zoom: viewport.zoom ?? tZoom\n                        }, {\n                            duration: options?.duration\n                        });\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                getViewport: ({\n                    \"useViewportHelper.useMemo\": ()=>{\n                        const [x, y, zoom] = store.getState().transform;\n                        return {\n                            x,\n                            y,\n                            zoom\n                        };\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                setCenter: ({\n                    \"useViewportHelper.useMemo\": async (x, y, options)=>{\n                        const { width, height, maxZoom, panZoom } = store.getState();\n                        const nextZoom = typeof options?.zoom !== 'undefined' ? options.zoom : maxZoom;\n                        const centerX = width / 2 - x * nextZoom;\n                        const centerY = height / 2 - y * nextZoom;\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport({\n                            x: centerX,\n                            y: centerY,\n                            zoom: nextZoom\n                        }, {\n                            duration: options?.duration\n                        });\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                fitBounds: ({\n                    \"useViewportHelper.useMemo\": async (bounds, options)=>{\n                        const { width, height, minZoom, maxZoom, panZoom } = store.getState();\n                        const viewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport(viewport, {\n                            duration: options?.duration\n                        });\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                screenToFlowPosition: ({\n                    \"useViewportHelper.useMemo\": (clientPosition, options = {})=>{\n                        const { transform, snapGrid, snapToGrid, domNode } = store.getState();\n                        if (!domNode) {\n                            return clientPosition;\n                        }\n                        const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                        const correctedPosition = {\n                            x: clientPosition.x - domX,\n                            y: clientPosition.y - domY\n                        };\n                        const _snapGrid = options.snapGrid ?? snapGrid;\n                        const _snapToGrid = options.snapToGrid ?? snapToGrid;\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(correctedPosition, transform, _snapToGrid, _snapGrid);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                flowToScreenPosition: ({\n                    \"useViewportHelper.useMemo\": (flowPosition)=>{\n                        const { transform, domNode } = store.getState();\n                        if (!domNode) {\n                            return flowPosition;\n                        }\n                        const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                        const rendererPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.rendererPointToPoint)(flowPosition, transform);\n                        return {\n                            x: rendererPosition.x + domX,\n                            y: rendererPosition.y + domY\n                        };\n                    }\n                })[\"useViewportHelper.useMemo\"]\n            };\n        }\n    }[\"useViewportHelper.useMemo\"], []);\n};\n/*\n * This function applies changes to nodes or edges that are triggered by React Flow internally.\n * When you drag a node for example, React Flow will send a position change update.\n * This function then applies the changes and returns the updated elements.\n */ function applyChanges(changes, elements) {\n    const updatedElements = [];\n    /*\n     * By storing a map of changes for each element, we can a quick lookup as we\n     * iterate over the elements array!\n     */ const changesMap = new Map();\n    const addItemChanges = [];\n    for (const change of changes){\n        if (change.type === 'add') {\n            addItemChanges.push(change);\n            continue;\n        } else if (change.type === 'remove' || change.type === 'replace') {\n            /*\n             * For a 'remove' change we can safely ignore any other changes queued for\n             * the same element, it's going to be removed anyway!\n             */ changesMap.set(change.id, [\n                change\n            ]);\n        } else {\n            const elementChanges = changesMap.get(change.id);\n            if (elementChanges) {\n                /*\n                 * If we have some changes queued already, we can do a mutable update of\n                 * that array and save ourselves some copying.\n                 */ elementChanges.push(change);\n            } else {\n                changesMap.set(change.id, [\n                    change\n                ]);\n            }\n        }\n    }\n    for (const element of elements){\n        const changes = changesMap.get(element.id);\n        /*\n         * When there are no changes for an element we can just push it unmodified,\n         * no need to copy it.\n         */ if (!changes) {\n            updatedElements.push(element);\n            continue;\n        }\n        // If we have a 'remove' change queued, it'll be the only change in the array\n        if (changes[0].type === 'remove') {\n            continue;\n        }\n        if (changes[0].type === 'replace') {\n            updatedElements.push({\n                ...changes[0].item\n            });\n            continue;\n        }\n        /**\n         * For other types of changes, we want to start with a shallow copy of the\n         * object so React knows this element has changed. Sequential changes will\n         * each _mutate_ this object, so there's only ever one copy.\n         */ const updatedElement = {\n            ...element\n        };\n        for (const change of changes){\n            applyChange(change, updatedElement);\n        }\n        updatedElements.push(updatedElement);\n    }\n    /*\n     * we need to wait for all changes to be applied before adding new items\n     * to be able to add them at the correct index\n     */ if (addItemChanges.length) {\n        addItemChanges.forEach((change)=>{\n            if (change.index !== undefined) {\n                updatedElements.splice(change.index, 0, {\n                    ...change.item\n                });\n            } else {\n                updatedElements.push({\n                    ...change.item\n                });\n            }\n        });\n    }\n    return updatedElements;\n}\n// Applies a single change to an element. This is a *mutable* update.\nfunction applyChange(change, element) {\n    switch(change.type){\n        case 'select':\n            {\n                element.selected = change.selected;\n                break;\n            }\n        case 'position':\n            {\n                if (typeof change.position !== 'undefined') {\n                    element.position = change.position;\n                }\n                if (typeof change.dragging !== 'undefined') {\n                    element.dragging = change.dragging;\n                }\n                break;\n            }\n        case 'dimensions':\n            {\n                if (typeof change.dimensions !== 'undefined') {\n                    element.measured ??= {};\n                    element.measured.width = change.dimensions.width;\n                    element.measured.height = change.dimensions.height;\n                    if (change.setAttributes) {\n                        if (change.setAttributes === true || change.setAttributes === 'width') {\n                            element.width = change.dimensions.width;\n                        }\n                        if (change.setAttributes === true || change.setAttributes === 'height') {\n                            element.height = change.dimensions.height;\n                        }\n                    }\n                }\n                if (typeof change.resizing === 'boolean') {\n                    element.resizing = change.resizing;\n                }\n                break;\n            }\n    }\n}\n/**\n * Drop in function that applies node changes to an array of nodes.\n * @public\n * @param changes - Array of changes to apply.\n * @param nodes - Array of nodes to apply the changes to.\n * @returns Array of updated nodes.\n * @example\n *```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyNodeChanges, type Node, type Edge, type OnNodesChange } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState<Node[]>([]);\n *  const [edges, setEdges] = useState<Edge[]>([]);\n *  const onNodesChange: OnNodesChange = useCallback(\n *    (changes) => {\n *      setNodes((oldNodes) => applyNodeChanges(changes, oldNodes));\n *    },\n *    [setNodes],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link NodeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyNodeChanges(changes, nodes) {\n    return applyChanges(changes, nodes);\n}\n/**\n * Drop in function that applies edge changes to an array of edges.\n * @public\n * @param changes - Array of changes to apply.\n * @param edges - Array of edge to apply the changes to.\n * @returns Array of updated edges.\n * @example\n * ```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyEdgeChanges } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState([]);\n *  const [edges, setEdges] = useState([]);\n *  const onEdgesChange = useCallback(\n *    (changes) => {\n *      setEdges((oldEdges) => applyEdgeChanges(changes, oldEdges));\n *    },\n *    [setEdges],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link EdgeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyEdgeChanges(changes, edges) {\n    return applyChanges(changes, edges);\n}\nfunction createSelectionChange(id, selected) {\n    return {\n        id,\n        type: 'select',\n        selected\n    };\n}\nfunction getSelectionChanges(items, selectedIds = new Set(), mutateItem = false) {\n    const changes = [];\n    for (const [id, item] of items){\n        const willBeSelected = selectedIds.has(id);\n        // we don't want to set all items to selected=false on the first selection\n        if (!(item.selected === undefined && !willBeSelected) && item.selected !== willBeSelected) {\n            if (mutateItem) {\n                /*\n                 * this hack is needed for nodes. When the user dragged a node, it's selected.\n                 * When another node gets dragged, we need to deselect the previous one,\n                 * in order to have only one selected node at a time - the onNodesChange callback comes too late here :/\n                 */ item.selected = willBeSelected;\n            }\n            changes.push(createSelectionChange(item.id, willBeSelected));\n        }\n    }\n    return changes;\n}\nfunction getElementsDiffChanges({ items = [], lookup }) {\n    const changes = [];\n    const itemsLookup = new Map(items.map((item)=>[\n            item.id,\n            item\n        ]));\n    for (const [index, item] of items.entries()){\n        const lookupItem = lookup.get(item.id);\n        const storeItem = lookupItem?.internals?.userNode ?? lookupItem;\n        if (storeItem !== undefined && storeItem !== item) {\n            changes.push({\n                id: item.id,\n                item: item,\n                type: 'replace'\n            });\n        }\n        if (storeItem === undefined) {\n            changes.push({\n                item: item,\n                type: 'add',\n                index\n            });\n        }\n    }\n    for (const [id] of lookup){\n        const nextNode = itemsLookup.get(id);\n        if (nextNode === undefined) {\n            changes.push({\n                id,\n                type: 'remove'\n            });\n        }\n    }\n    return changes;\n}\nfunction elementToRemoveChange(item) {\n    return {\n        id: item.id,\n        type: 'remove'\n    };\n}\n/**\n * Test whether an object is usable as an [`Node`](/api-reference/types/node).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Node`](/api-reference/types/node) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test.\n * @returns Tests whether the provided value can be used as a `Node`. If you're using TypeScript,\n * this function acts as a type guard and will narrow the type of the value to `Node` if it returns\n * `true`.\n *\n * @example\n * ```js\n *import { isNode } from '@xyflow/react';\n *\n *if (isNode(node)) {\n * // ...\n *}\n *```\n */ const isNode = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNodeBase)(element);\n/**\n * Test whether an object is usable as an [`Edge`](/api-reference/types/edge).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Edge`](/api-reference/types/edge) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns Tests whether the provided value can be used as an `Edge`. If you're using TypeScript,\n * this function acts as a type guard and will narrow the type of the value to `Edge` if it returns\n * `true`.\n *\n * @example\n * ```js\n *import { isEdge } from '@xyflow/react';\n *\n *if (isEdge(edge)) {\n * // ...\n *}\n *```\n */ const isEdge = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeBase)(element);\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nfunction fixedForwardRef(render) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(render);\n}\n// we need this hook to prevent a warning when using react-flow in SSR\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n/**\n * This hook returns a queue that can be used to batch updates.\n *\n * @param runQueue - a function that gets called when the queue is flushed\n * @internal\n *\n * @returns a Queue object\n */ function useQueue(runQueue) {\n    /*\n     * Because we're using a ref above, we need some way to let React know when to\n     * actually process the queue. We increment this number any time we mutate the\n     * queue, creating a new state to trigger the layout effect below.\n     * Using a boolean dirty flag here instead would lead to issues related to\n     * automatic batching. (https://github.com/xyflow/xyflow/issues/4779)\n     */ const [serial, setSerial] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(BigInt(0));\n    /*\n     * A reference of all the batched updates to process before the next render. We\n     * want a reference here so multiple synchronous calls to `setNodes` etc can be\n     * batched together.\n     */ const [queue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"useQueue.useState\": ()=>createQueue({\n                \"useQueue.useState\": ()=>setSerial({\n                        \"useQueue.useState\": (n)=>n + BigInt(1)\n                    }[\"useQueue.useState\"])\n            }[\"useQueue.useState\"])\n    }[\"useQueue.useState\"]);\n    /*\n     * Layout effects are guaranteed to run before the next render which means we\n     * shouldn't run into any issues with stale state or weird issues that come from\n     * rendering things one frame later than expected (we used to use `setTimeout`).\n     */ useIsomorphicLayoutEffect({\n        \"useQueue.useIsomorphicLayoutEffect\": ()=>{\n            const queueItems = queue.get();\n            if (queueItems.length) {\n                runQueue(queueItems);\n                queue.reset();\n            }\n        }\n    }[\"useQueue.useIsomorphicLayoutEffect\"], [\n        serial\n    ]);\n    return queue;\n}\nfunction createQueue(cb) {\n    let queue = [];\n    return {\n        get: ()=>queue,\n        reset: ()=>{\n            queue = [];\n        },\n        push: (item)=>{\n            queue.push(item);\n            cb();\n        }\n    };\n}\nconst BatchContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n/**\n * This is a context provider that holds and processes the node and edge update queues\n * that are needed to handle setNodes, addNodes, setEdges and addEdges.\n *\n * @internal\n */ function BatchProvider({ children }) {\n    const store = useStoreApi();\n    const nodeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"BatchProvider.useCallback[nodeQueueHandler]\": (queueItems)=>{\n            const { nodes = [], setNodes, hasDefaultNodes, onNodesChange, nodeLookup, fitViewQueued } = store.getState();\n            /*\n         * This is essentially an `Array.reduce` in imperative clothing. Processing\n         * this queue is a relatively hot path so we'd like to avoid the overhead of\n         * array methods where we can.\n         */ let next = nodes;\n            for (const payload of queueItems){\n                next = typeof payload === 'function' ? payload(next) : payload;\n            }\n            const changes = getElementsDiffChanges({\n                items: next,\n                lookup: nodeLookup\n            });\n            if (hasDefaultNodes) {\n                setNodes(next);\n            }\n            // We only want to fire onNodesChange if there are changes to the nodes\n            if (changes.length > 0) {\n                onNodesChange?.(changes);\n            } else if (fitViewQueued) {\n                // If there are no changes to the nodes, we still need to call setNodes\n                // to trigger a re-render and fitView.\n                window.requestAnimationFrame({\n                    \"BatchProvider.useCallback[nodeQueueHandler]\": ()=>{\n                        const { fitViewQueued, nodes, setNodes } = store.getState();\n                        if (fitViewQueued) {\n                            setNodes(nodes);\n                        }\n                    }\n                }[\"BatchProvider.useCallback[nodeQueueHandler]\"]);\n            }\n        }\n    }[\"BatchProvider.useCallback[nodeQueueHandler]\"], []);\n    const nodeQueue = useQueue(nodeQueueHandler);\n    const edgeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"BatchProvider.useCallback[edgeQueueHandler]\": (queueItems)=>{\n            const { edges = [], setEdges, hasDefaultEdges, onEdgesChange, edgeLookup } = store.getState();\n            let next = edges;\n            for (const payload of queueItems){\n                next = typeof payload === 'function' ? payload(next) : payload;\n            }\n            if (hasDefaultEdges) {\n                setEdges(next);\n            } else if (onEdgesChange) {\n                onEdgesChange(getElementsDiffChanges({\n                    items: next,\n                    lookup: edgeLookup\n                }));\n            }\n        }\n    }[\"BatchProvider.useCallback[edgeQueueHandler]\"], []);\n    const edgeQueue = useQueue(edgeQueueHandler);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"BatchProvider.useMemo[value]\": ()=>({\n                nodeQueue,\n                edgeQueue\n            })\n    }[\"BatchProvider.useMemo[value]\"], []);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchContext.Provider, {\n        value: value,\n        children: children\n    });\n}\nfunction useBatchContext() {\n    const batchContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(BatchContext);\n    if (!batchContext) {\n        throw new Error('useBatchContext must be used within a BatchProvider');\n    }\n    return batchContext;\n}\nconst selector$k = (s)=>!!s.panZoom;\n/**\n * This hook returns a ReactFlowInstance that can be used to update nodes and edges, manipulate the viewport, or query the current state of the flow.\n *\n * @public\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { useReactFlow } from '@xyflow/react';\n *\n *export function NodeCounter() {\n *  const reactFlow = useReactFlow();\n *  const [count, setCount] = useState(0);\n *  const countNodes = useCallback(() => {\n *    setCount(reactFlow.getNodes().length);\n *    // you need to pass it as a dependency if you are using it with useEffect or useCallback\n *    // because at the first render, it's not initialized yet and some functions might not work.\n *  }, [reactFlow]);\n *\n *  return (\n *    <div>\n *      <button onClick={countNodes}>Update count</button>\n *      <p>There are {count} nodes in the flow.</p>\n *    </div>\n *  );\n *}\n *```\n */ function useReactFlow() {\n    const viewportHelper = useViewportHelper();\n    const store = useStoreApi();\n    const batchContext = useBatchContext();\n    const viewportInitialized = useStore(selector$k);\n    const generalHelper = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useReactFlow.useMemo[generalHelper]\": ()=>{\n            const getInternalNode = {\n                \"useReactFlow.useMemo[generalHelper].getInternalNode\": (id)=>store.getState().nodeLookup.get(id)\n            }[\"useReactFlow.useMemo[generalHelper].getInternalNode\"];\n            const setNodes = {\n                \"useReactFlow.useMemo[generalHelper].setNodes\": (payload)=>{\n                    batchContext.nodeQueue.push(payload);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].setNodes\"];\n            const setEdges = {\n                \"useReactFlow.useMemo[generalHelper].setEdges\": (payload)=>{\n                    batchContext.edgeQueue.push(payload);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].setEdges\"];\n            const getNodeRect = {\n                \"useReactFlow.useMemo[generalHelper].getNodeRect\": (node)=>{\n                    const { nodeLookup, nodeOrigin } = store.getState();\n                    const nodeToUse = isNode(node) ? node : nodeLookup.get(node.id);\n                    const position = nodeToUse.parentId ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, nodeLookup, nodeOrigin) : nodeToUse.position;\n                    const nodeWithPosition = {\n                        ...nodeToUse,\n                        position,\n                        width: nodeToUse.measured?.width ?? nodeToUse.width,\n                        height: nodeToUse.measured?.height ?? nodeToUse.height\n                    };\n                    return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(nodeWithPosition);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].getNodeRect\"];\n            const updateNode = {\n                \"useReactFlow.useMemo[generalHelper].updateNode\": (id, nodeUpdate, options = {\n                    replace: false\n                })=>{\n                    setNodes({\n                        \"useReactFlow.useMemo[generalHelper].updateNode\": (prevNodes)=>prevNodes.map({\n                                \"useReactFlow.useMemo[generalHelper].updateNode\": (node)=>{\n                                    if (node.id === id) {\n                                        const nextNode = typeof nodeUpdate === 'function' ? nodeUpdate(node) : nodeUpdate;\n                                        return options.replace && isNode(nextNode) ? nextNode : {\n                                            ...node,\n                                            ...nextNode\n                                        };\n                                    }\n                                    return node;\n                                }\n                            }[\"useReactFlow.useMemo[generalHelper].updateNode\"])\n                    }[\"useReactFlow.useMemo[generalHelper].updateNode\"]);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].updateNode\"];\n            const updateEdge = {\n                \"useReactFlow.useMemo[generalHelper].updateEdge\": (id, edgeUpdate, options = {\n                    replace: false\n                })=>{\n                    setEdges({\n                        \"useReactFlow.useMemo[generalHelper].updateEdge\": (prevEdges)=>prevEdges.map({\n                                \"useReactFlow.useMemo[generalHelper].updateEdge\": (edge)=>{\n                                    if (edge.id === id) {\n                                        const nextEdge = typeof edgeUpdate === 'function' ? edgeUpdate(edge) : edgeUpdate;\n                                        return options.replace && isEdge(nextEdge) ? nextEdge : {\n                                            ...edge,\n                                            ...nextEdge\n                                        };\n                                    }\n                                    return edge;\n                                }\n                            }[\"useReactFlow.useMemo[generalHelper].updateEdge\"])\n                    }[\"useReactFlow.useMemo[generalHelper].updateEdge\"]);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].updateEdge\"];\n            return {\n                getNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>store.getState().nodes.map({\n                            \"useReactFlow.useMemo[generalHelper]\": (n)=>({\n                                    ...n\n                                })\n                        }[\"useReactFlow.useMemo[generalHelper]\"])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNode: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id)=>getInternalNode(id)?.internals.userNode\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getInternalNode,\n                getEdges: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>{\n                        const { edges = [] } = store.getState();\n                        return edges.map({\n                            \"useReactFlow.useMemo[generalHelper]\": (e)=>({\n                                    ...e\n                                })\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getEdge: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id)=>store.getState().edgeLookup.get(id)\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                setNodes,\n                setEdges,\n                addNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (payload)=>{\n                        const newNodes = Array.isArray(payload) ? payload : [\n                            payload\n                        ];\n                        batchContext.nodeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (nodes)=>[\n                                    ...nodes,\n                                    ...newNodes\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                addEdges: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (payload)=>{\n                        const newEdges = Array.isArray(payload) ? payload : [\n                            payload\n                        ];\n                        batchContext.edgeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (edges)=>[\n                                    ...edges,\n                                    ...newEdges\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                toObject: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>{\n                        const { nodes = [], edges = [], transform } = store.getState();\n                        const [x, y, zoom] = transform;\n                        return {\n                            nodes: nodes.map({\n                                \"useReactFlow.useMemo[generalHelper]\": (n)=>({\n                                        ...n\n                                    })\n                            }[\"useReactFlow.useMemo[generalHelper]\"]),\n                            edges: edges.map({\n                                \"useReactFlow.useMemo[generalHelper]\": (e)=>({\n                                        ...e\n                                    })\n                            }[\"useReactFlow.useMemo[generalHelper]\"]),\n                            viewport: {\n                                x,\n                                y,\n                                zoom\n                            }\n                        };\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                deleteElements: ({\n                    \"useReactFlow.useMemo[generalHelper]\": async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] })=>{\n                        const { nodes, edges, onNodesDelete, onEdgesDelete, triggerNodeChanges, triggerEdgeChanges, onDelete, onBeforeDelete } = store.getState();\n                        const { nodes: matchingNodes, edges: matchingEdges } = await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElementsToRemove)({\n                            nodesToRemove,\n                            edgesToRemove,\n                            nodes,\n                            edges,\n                            onBeforeDelete\n                        });\n                        const hasMatchingEdges = matchingEdges.length > 0;\n                        const hasMatchingNodes = matchingNodes.length > 0;\n                        if (hasMatchingEdges) {\n                            const edgeChanges = matchingEdges.map(elementToRemoveChange);\n                            onEdgesDelete?.(matchingEdges);\n                            triggerEdgeChanges(edgeChanges);\n                        }\n                        if (hasMatchingNodes) {\n                            const nodeChanges = matchingNodes.map(elementToRemoveChange);\n                            onNodesDelete?.(matchingNodes);\n                            triggerNodeChanges(nodeChanges);\n                        }\n                        if (hasMatchingNodes || hasMatchingEdges) {\n                            onDelete?.({\n                                nodes: matchingNodes,\n                                edges: matchingEdges\n                            });\n                        }\n                        return {\n                            deletedNodes: matchingNodes,\n                            deletedEdges: matchingEdges\n                        };\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getIntersectingNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodeOrRect, partially = true, nodes)=>{\n                        const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                        const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                        const hasNodesOption = nodes !== undefined;\n                        if (!nodeRect) {\n                            return [];\n                        }\n                        return (nodes || store.getState().nodes).filter({\n                            \"useReactFlow.useMemo[generalHelper]\": (n)=>{\n                                const internalNode = store.getState().nodeLookup.get(n.id);\n                                if (internalNode && !isRect && (n.id === nodeOrRect.id || !internalNode.internals.positionAbsolute)) {\n                                    return false;\n                                }\n                                const currNodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(hasNodesOption ? n : internalNode);\n                                const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(currNodeRect, nodeRect);\n                                const partiallyVisible = partially && overlappingArea > 0;\n                                return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                isNodeIntersecting: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodeOrRect, area, partially = true)=>{\n                        const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                        const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                        if (!nodeRect) {\n                            return false;\n                        }\n                        const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(nodeRect, area);\n                        const partiallyVisible = partially && overlappingArea > 0;\n                        return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                updateNode,\n                updateNodeData: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id, dataUpdate, options = {\n                        replace: false\n                    })=>{\n                        updateNode(id, {\n                            \"useReactFlow.useMemo[generalHelper]\": (node)=>{\n                                const nextData = typeof dataUpdate === 'function' ? dataUpdate(node) : dataUpdate;\n                                return options.replace ? {\n                                    ...node,\n                                    data: nextData\n                                } : {\n                                    ...node,\n                                    data: {\n                                        ...node.data,\n                                        ...nextData\n                                    }\n                                };\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"], options);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                updateEdge,\n                updateEdgeData: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id, dataUpdate, options = {\n                        replace: false\n                    })=>{\n                        updateEdge(id, {\n                            \"useReactFlow.useMemo[generalHelper]\": (edge)=>{\n                                const nextData = typeof dataUpdate === 'function' ? dataUpdate(edge) : dataUpdate;\n                                return options.replace ? {\n                                    ...edge,\n                                    data: nextData\n                                } : {\n                                    ...edge,\n                                    data: {\n                                        ...edge.data,\n                                        ...nextData\n                                    }\n                                };\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"], options);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNodesBounds: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodes)=>{\n                        const { nodeLookup, nodeOrigin } = store.getState();\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds)(nodes, {\n                            nodeLookup,\n                            nodeOrigin\n                        });\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getHandleConnections: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ({ type, id, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}-${type}${id ? `-${id}` : ''}`)?.values() ?? [])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNodeConnections: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ({ type, handleId, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}${type ? handleId ? `-${type}-${handleId}` : `-${type}` : ''}`)?.values() ?? [])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                fitView: ({\n                    \"useReactFlow.useMemo[generalHelper]\": async (options)=>{\n                        // We either create a new Promise or reuse the existing one\n                        // Even if fitView is called multiple times in a row, we only end up with a single Promise\n                        const fitViewResolver = store.getState().fitViewResolver ?? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.withResolvers)();\n                        // We schedule a fitView by setting fitViewQueued and triggering a setNodes\n                        store.setState({\n                            fitViewQueued: true,\n                            fitViewOptions: options,\n                            fitViewResolver\n                        });\n                        batchContext.nodeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (nodes)=>[\n                                    ...nodes\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                        return fitViewResolver.promise;\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"]\n            };\n        }\n    }[\"useReactFlow.useMemo[generalHelper]\"], []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useReactFlow.useMemo\": ()=>{\n            return {\n                ...generalHelper,\n                ...viewportHelper,\n                viewportInitialized\n            };\n        }\n    }[\"useReactFlow.useMemo\"], [\n        viewportInitialized\n    ]);\n}\nconst selected = (item)=>item.selected;\nconst win$1 =  false ? 0 : undefined;\n/**\n * Hook for handling global key events.\n *\n * @internal\n */ function useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }) {\n    const store = useStoreApi();\n    const { deleteElements } = useReactFlow();\n    const deleteKeyPressed = useKeyPress(deleteKeyCode, {\n        actInsideInputWithModifier: false\n    });\n    const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode, {\n        target: win$1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useGlobalKeyHandler.useEffect\": ()=>{\n            if (deleteKeyPressed) {\n                const { edges, nodes } = store.getState();\n                deleteElements({\n                    nodes: nodes.filter(selected),\n                    edges: edges.filter(selected)\n                });\n                store.setState({\n                    nodesSelectionActive: false\n                });\n            }\n        }\n    }[\"useGlobalKeyHandler.useEffect\"], [\n        deleteKeyPressed\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useGlobalKeyHandler.useEffect\": ()=>{\n            store.setState({\n                multiSelectionActive: multiSelectionKeyPressed\n            });\n        }\n    }[\"useGlobalKeyHandler.useEffect\"], [\n        multiSelectionKeyPressed\n    ]);\n}\n/**\n * Hook for handling resize events.\n *\n * @internal\n */ function useResizeHandler(domNode) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useResizeHandler.useEffect\": ()=>{\n            const updateDimensions = {\n                \"useResizeHandler.useEffect.updateDimensions\": ()=>{\n                    if (!domNode.current) {\n                        return false;\n                    }\n                    const size = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getDimensions)(domNode.current);\n                    if (size.height === 0 || size.width === 0) {\n                        store.getState().onError?.('004', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error004']());\n                    }\n                    store.setState({\n                        width: size.width || 500,\n                        height: size.height || 500\n                    });\n                }\n            }[\"useResizeHandler.useEffect.updateDimensions\"];\n            if (domNode.current) {\n                updateDimensions();\n                window.addEventListener('resize', updateDimensions);\n                const resizeObserver = new ResizeObserver({\n                    \"useResizeHandler.useEffect\": ()=>updateDimensions()\n                }[\"useResizeHandler.useEffect\"]);\n                resizeObserver.observe(domNode.current);\n                return ({\n                    \"useResizeHandler.useEffect\": ()=>{\n                        window.removeEventListener('resize', updateDimensions);\n                        if (resizeObserver && domNode.current) {\n                            resizeObserver.unobserve(domNode.current);\n                        }\n                    }\n                })[\"useResizeHandler.useEffect\"];\n            }\n        }\n    }[\"useResizeHandler.useEffect\"], []);\n}\nconst containerStyle = {\n    position: 'absolute',\n    width: '100%',\n    height: '100%',\n    top: 0,\n    left: 0\n};\nconst selector$j = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        lib: s.lib\n    });\nfunction ZoomPane({ onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance }) {\n    const store = useStoreApi();\n    const zoomPane = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { userSelectionActive, lib } = useStore(selector$j, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);\n    const panZoom = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    useResizeHandler(zoomPane);\n    const onTransformChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ZoomPane.useCallback[onTransformChange]\": (transform)=>{\n            onViewportChange?.({\n                x: transform[0],\n                y: transform[1],\n                zoom: transform[2]\n            });\n            if (!isControlledViewport) {\n                store.setState({\n                    transform\n                });\n            }\n        }\n    }[\"ZoomPane.useCallback[onTransformChange]\"], [\n        onViewportChange,\n        isControlledViewport\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ZoomPane.useEffect\": ()=>{\n            if (zoomPane.current) {\n                panZoom.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYPanZoom)({\n                    domNode: zoomPane.current,\n                    minZoom,\n                    maxZoom,\n                    translateExtent,\n                    viewport: defaultViewport,\n                    paneClickDistance,\n                    onDraggingChange: {\n                        \"ZoomPane.useEffect\": (paneDragging)=>store.setState({\n                                paneDragging\n                            })\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoomStart: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChangeStart, onMoveStart } = store.getState();\n                            onMoveStart?.(event, vp);\n                            onViewportChangeStart?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoom: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChange, onMove } = store.getState();\n                            onMove?.(event, vp);\n                            onViewportChange?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoomEnd: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChangeEnd, onMoveEnd } = store.getState();\n                            onMoveEnd?.(event, vp);\n                            onViewportChangeEnd?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"]\n                });\n                const { x, y, zoom } = panZoom.current.getViewport();\n                store.setState({\n                    panZoom: panZoom.current,\n                    transform: [\n                        x,\n                        y,\n                        zoom\n                    ],\n                    domNode: zoomPane.current.closest('.react-flow')\n                });\n                return ({\n                    \"ZoomPane.useEffect\": ()=>{\n                        panZoom.current?.destroy();\n                    }\n                })[\"ZoomPane.useEffect\"];\n            }\n        }\n    }[\"ZoomPane.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ZoomPane.useEffect\": ()=>{\n            panZoom.current?.update({\n                onPaneContextMenu,\n                zoomOnScroll,\n                zoomOnPinch,\n                panOnScroll,\n                panOnScrollSpeed,\n                panOnScrollMode,\n                zoomOnDoubleClick,\n                panOnDrag,\n                zoomActivationKeyPressed,\n                preventScrolling,\n                noPanClassName,\n                userSelectionActive,\n                noWheelClassName,\n                lib,\n                onTransformChange\n            });\n        }\n    }[\"ZoomPane.useEffect\"], [\n        onPaneContextMenu,\n        zoomOnScroll,\n        zoomOnPinch,\n        panOnScroll,\n        panOnScrollSpeed,\n        panOnScrollMode,\n        zoomOnDoubleClick,\n        panOnDrag,\n        zoomActivationKeyPressed,\n        preventScrolling,\n        noPanClassName,\n        userSelectionActive,\n        noWheelClassName,\n        lib,\n        onTransformChange\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__renderer\",\n        ref: zoomPane,\n        style: containerStyle,\n        children: children\n    });\n}\nconst selector$i = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        userSelectionRect: s.userSelectionRect\n    });\nfunction UserSelection() {\n    const { userSelectionActive, userSelectionRect } = useStore(selector$i, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const isActive = userSelectionActive && userSelectionRect;\n    if (!isActive) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__selection react-flow__container\",\n        style: {\n            width: userSelectionRect.width,\n            height: userSelectionRect.height,\n            transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`\n        }\n    });\n}\nconst wrapHandler = (handler, containerRef)=>{\n    return (event)=>{\n        if (event.target !== containerRef.current) {\n            return;\n        }\n        handler?.(event);\n    };\n};\nconst selector$h = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        elementsSelectable: s.elementsSelectable,\n        connectionInProgress: s.connection.inProgress,\n        dragging: s.paneDragging\n    });\nfunction Pane({ isSelecting, selectionKeyPressed, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panOnDrag, selectionOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children }) {\n    const store = useStoreApi();\n    const { userSelectionActive, elementsSelectable, dragging, connectionInProgress } = useStore(selector$h, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive);\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const selectedNodeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    const selectedEdgeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    // Used to prevent click events when the user lets go of the selectionKey during a selection\n    const selectionInProgress = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const selectionStarted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const onClick = (event)=>{\n        // We prevent click events when the user let go of the selectionKey during a selection\n        // We also prevent click events when a connection is in progress\n        if (selectionInProgress.current || connectionInProgress) {\n            selectionInProgress.current = false;\n            return;\n        }\n        onPaneClick?.(event);\n        store.getState().resetSelectedElements();\n        store.setState({\n            nodesSelectionActive: false\n        });\n    };\n    const onContextMenu = (event)=>{\n        if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {\n            event.preventDefault();\n            return;\n        }\n        onPaneContextMenu?.(event);\n    };\n    const onWheel = onPaneScroll ? (event)=>onPaneScroll(event) : undefined;\n    const onPointerDown = (event)=>{\n        const { resetSelectedElements, domNode } = store.getState();\n        containerBounds.current = domNode?.getBoundingClientRect();\n        if (!elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container.current || !containerBounds.current) {\n            return;\n        }\n        event.target?.setPointerCapture?.(event.pointerId);\n        selectionStarted.current = true;\n        selectionInProgress.current = false;\n        const { x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        resetSelectedElements();\n        store.setState({\n            userSelectionRect: {\n                width: 0,\n                height: 0,\n                startX: x,\n                startY: y,\n                x,\n                y\n            }\n        });\n        onSelectionStart?.(event);\n    };\n    const onPointerMove = (event)=>{\n        const { userSelectionRect, transform, nodeLookup, edgeLookup, connectionLookup, triggerNodeChanges, triggerEdgeChanges, defaultEdgeOptions } = store.getState();\n        if (!containerBounds.current || !userSelectionRect) {\n            return;\n        }\n        selectionInProgress.current = true;\n        const { x: mouseX, y: mouseY } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        const { startX, startY } = userSelectionRect;\n        const nextUserSelectRect = {\n            startX,\n            startY,\n            x: mouseX < startX ? mouseX : startX,\n            y: mouseY < startY ? mouseY : startY,\n            width: Math.abs(mouseX - startX),\n            height: Math.abs(mouseY - startY)\n        };\n        const prevSelectedNodeIds = selectedNodeIds.current;\n        const prevSelectedEdgeIds = selectedEdgeIds.current;\n        selectedNodeIds.current = new Set((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(nodeLookup, nextUserSelectRect, transform, selectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Partial, true).map((node)=>node.id));\n        selectedEdgeIds.current = new Set();\n        const edgesSelectable = defaultEdgeOptions?.selectable ?? true;\n        // We look for all edges connected to the selected nodes\n        for (const nodeId of selectedNodeIds.current){\n            const connections = connectionLookup.get(nodeId);\n            if (!connections) continue;\n            for (const { edgeId } of connections.values()){\n                const edge = edgeLookup.get(edgeId);\n                if (edge && (edge.selectable ?? edgesSelectable)) {\n                    selectedEdgeIds.current.add(edgeId);\n                }\n            }\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedNodeIds, selectedNodeIds.current)) {\n            const changes = getSelectionChanges(nodeLookup, selectedNodeIds.current, true);\n            triggerNodeChanges(changes);\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedEdgeIds, selectedEdgeIds.current)) {\n            const changes = getSelectionChanges(edgeLookup, selectedEdgeIds.current);\n            triggerEdgeChanges(changes);\n        }\n        store.setState({\n            userSelectionRect: nextUserSelectRect,\n            userSelectionActive: true,\n            nodesSelectionActive: false\n        });\n    };\n    const onPointerUp = (event)=>{\n        if (event.button !== 0 || !selectionStarted.current) {\n            return;\n        }\n        event.target?.releasePointerCapture?.(event.pointerId);\n        const { userSelectionRect } = store.getState();\n        /*\n         * We only want to trigger click functions when in selection mode if\n         * the user did not move the mouse.\n         */ if (!userSelectionActive && userSelectionRect && event.target === container.current) {\n            onClick?.(event);\n        }\n        store.setState({\n            userSelectionActive: false,\n            userSelectionRect: null,\n            nodesSelectionActive: selectedNodeIds.current.size > 0\n        });\n        onSelectionEnd?.(event);\n        /*\n         * If the user kept holding the selectionKey during the selection,\n         * we need to reset the selectionInProgress, so the next click event is not prevented\n         */ if (selectionKeyPressed || selectionOnDrag) {\n            selectionInProgress.current = false;\n        }\n        selectionStarted.current = false;\n    };\n    const draggable = panOnDrag === true || Array.isArray(panOnDrag) && panOnDrag.includes(0);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__pane',\n            {\n                draggable,\n                dragging,\n                selection: isSelecting\n            }\n        ]),\n        onClick: hasActiveSelection ? undefined : wrapHandler(onClick, container),\n        onContextMenu: wrapHandler(onContextMenu, container),\n        onWheel: wrapHandler(onWheel, container),\n        onPointerEnter: hasActiveSelection ? undefined : onPaneMouseEnter,\n        onPointerDown: hasActiveSelection ? onPointerDown : onPaneMouseMove,\n        onPointerMove: hasActiveSelection ? onPointerMove : onPaneMouseMove,\n        onPointerUp: hasActiveSelection ? onPointerUp : undefined,\n        onPointerLeave: onPaneMouseLeave,\n        ref: container,\n        style: containerStyle,\n        children: [\n            children,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UserSelection, {})\n        ]\n    });\n}\n/*\n * this handler is called by\n * 1. the click handler when node is not draggable or selectNodesOnDrag = false\n * or\n * 2. the on drag start handler when node is draggable and selectNodesOnDrag = true\n */ function handleNodeClick({ id, store, unselect = false, nodeRef }) {\n    const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeLookup, onError } = store.getState();\n    const node = nodeLookup.get(id);\n    if (!node) {\n        onError?.('012', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error012'](id));\n        return;\n    }\n    store.setState({\n        nodesSelectionActive: false\n    });\n    if (!node.selected) {\n        addSelectedNodes([\n            id\n        ]);\n    } else if (unselect || node.selected && multiSelectionActive) {\n        unselectNodesAndEdges({\n            nodes: [\n                node\n            ],\n            edges: []\n        });\n        requestAnimationFrame(()=>nodeRef?.current?.blur());\n    }\n}\n/**\n * Hook for calling XYDrag helper from @xyflow/system.\n *\n * @internal\n */ function useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, nodeClickDistance }) {\n    const store = useStoreApi();\n    const [dragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const xyDrag = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useDrag.useEffect\": ()=>{\n            xyDrag.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYDrag)({\n                getStoreItems: {\n                    \"useDrag.useEffect\": ()=>store.getState()\n                }[\"useDrag.useEffect\"],\n                onNodeMouseDown: {\n                    \"useDrag.useEffect\": (id)=>{\n                        handleNodeClick({\n                            id,\n                            store,\n                            nodeRef\n                        });\n                    }\n                }[\"useDrag.useEffect\"],\n                onDragStart: {\n                    \"useDrag.useEffect\": ()=>{\n                        setDragging(true);\n                    }\n                }[\"useDrag.useEffect\"],\n                onDragStop: {\n                    \"useDrag.useEffect\": ()=>{\n                        setDragging(false);\n                    }\n                }[\"useDrag.useEffect\"]\n            });\n        }\n    }[\"useDrag.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useDrag.useEffect\": ()=>{\n            if (disabled) {\n                xyDrag.current?.destroy();\n            } else if (nodeRef.current) {\n                xyDrag.current?.update({\n                    noDragClassName,\n                    handleSelector,\n                    domNode: nodeRef.current,\n                    isSelectable,\n                    nodeId,\n                    nodeClickDistance\n                });\n                return ({\n                    \"useDrag.useEffect\": ()=>{\n                        xyDrag.current?.destroy();\n                    }\n                })[\"useDrag.useEffect\"];\n            }\n        }\n    }[\"useDrag.useEffect\"], [\n        noDragClassName,\n        handleSelector,\n        disabled,\n        isSelectable,\n        nodeRef,\n        nodeId\n    ]);\n    return dragging;\n}\nconst selectedAndDraggable = (nodesDraggable)=>(n)=>n.selected && (n.draggable || nodesDraggable && typeof n.draggable === 'undefined');\n/**\n * Hook for updating node positions by passing a direction and factor\n *\n * @internal\n * @returns function for updating node positions\n */ function useMoveSelectedNodes() {\n    const store = useStoreApi();\n    const moveSelectedNodes = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useMoveSelectedNodes.useCallback[moveSelectedNodes]\": (params)=>{\n            const { nodeExtent, snapToGrid, snapGrid, nodesDraggable, onError, updateNodePositions, nodeLookup, nodeOrigin } = store.getState();\n            const nodeUpdates = new Map();\n            const isSelected = selectedAndDraggable(nodesDraggable);\n            /*\n         * by default a node moves 5px on each key press\n         * if snap grid is enabled, we use that for the velocity\n         */ const xVelo = snapToGrid ? snapGrid[0] : 5;\n            const yVelo = snapToGrid ? snapGrid[1] : 5;\n            const xDiff = params.direction.x * xVelo * params.factor;\n            const yDiff = params.direction.y * yVelo * params.factor;\n            for (const [, node] of nodeLookup){\n                if (!isSelected(node)) {\n                    continue;\n                }\n                let nextPosition = {\n                    x: node.internals.positionAbsolute.x + xDiff,\n                    y: node.internals.positionAbsolute.y + yDiff\n                };\n                if (snapToGrid) {\n                    nextPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.snapPosition)(nextPosition, snapGrid);\n                }\n                const { position, positionAbsolute } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.calculateNodePosition)({\n                    nodeId: node.id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent,\n                    nodeOrigin,\n                    onError\n                });\n                node.position = position;\n                node.internals.positionAbsolute = positionAbsolute;\n                nodeUpdates.set(node.id, node);\n            }\n            updateNodePositions(nodeUpdates);\n        }\n    }[\"useMoveSelectedNodes.useCallback[moveSelectedNodes]\"], []);\n    return moveSelectedNodes;\n}\nconst NodeIdContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider = NodeIdContext.Provider;\nNodeIdContext.Consumer;\n/**\n * You can use this hook to get the id of the node it is used inside. It is useful\n * if you need the node's id deeper in the render tree but don't want to manually\n * drill down the id as a prop.\n *\n * @public\n * @returns The id for a node in the flow.\n *\n * @example\n *```jsx\n *import { useNodeId } from '@xyflow/react';\n *\n *export default function CustomNode() {\n *  return (\n *    <div>\n *      <span>This node has an id of </span>\n *      <NodeIdDisplay />\n *    </div>\n *  );\n *}\n *\n *function NodeIdDisplay() {\n *  const nodeId = useNodeId();\n *\n *  return <span>{nodeId}</span>;\n *}\n *```\n */ const useNodeId = ()=>{\n    const nodeId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NodeIdContext);\n    return nodeId;\n};\nconst selector$g = (s)=>({\n        connectOnClick: s.connectOnClick,\n        noPanClassName: s.noPanClassName,\n        rfId: s.rfId\n    });\nconst connectingSelector = (nodeId, handleId, type)=>(state)=>{\n        const { connectionClickStartHandle: clickHandle, connectionMode, connection } = state;\n        const { fromHandle, toHandle, isValid } = connection;\n        const connectingTo = toHandle?.nodeId === nodeId && toHandle?.id === handleId && toHandle?.type === type;\n        return {\n            connectingFrom: fromHandle?.nodeId === nodeId && fromHandle?.id === handleId && fromHandle?.type === type,\n            connectingTo,\n            clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.id === handleId && clickHandle?.type === type,\n            isPossibleEndHandle: connectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict ? fromHandle?.type !== type : nodeId !== fromHandle?.nodeId || handleId !== fromHandle?.id,\n            connectionInProcess: !!fromHandle,\n            clickConnectionInProcess: !!clickHandle,\n            valid: connectingTo && isValid\n        };\n    };\nfunction HandleComponent({ type = 'source', position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id, onConnect, children, className, onMouseDown, onTouchStart, ...rest }, ref) {\n    const handleId = id || null;\n    const isTarget = type === 'target';\n    const store = useStoreApi();\n    const nodeId = useNodeId();\n    const { connectOnClick, noPanClassName, rfId } = useStore(selector$g, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { connectingFrom, connectingTo, clickConnecting, isPossibleEndHandle, connectionInProcess, clickConnectionInProcess, valid } = useStore(connectingSelector(nodeId, handleId, type), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!nodeId) {\n        store.getState().onError?.('010', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error010']());\n    }\n    const onConnectExtended = (params)=>{\n        const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();\n        const edgeParams = {\n            ...defaultEdgeOptions,\n            ...params\n        };\n        if (hasDefaultEdges) {\n            const { edges, setEdges } = store.getState();\n            setEdges((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge)(edgeParams, edges));\n        }\n        onConnectAction?.(edgeParams);\n        onConnect?.(edgeParams);\n    };\n    const onPointerDown = (event)=>{\n        if (!nodeId) {\n            return;\n        }\n        const isMouseTriggered = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMouseEvent)(event.nativeEvent);\n        if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {\n            const currentStore = store.getState();\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n                autoPanOnConnect: currentStore.autoPanOnConnect,\n                connectionMode: currentStore.connectionMode,\n                connectionRadius: currentStore.connectionRadius,\n                domNode: currentStore.domNode,\n                nodeLookup: currentStore.nodeLookup,\n                lib: currentStore.lib,\n                isTarget,\n                handleId,\n                nodeId,\n                flowId: currentStore.rfId,\n                panBy: currentStore.panBy,\n                cancelConnection: currentStore.cancelConnection,\n                onConnectStart: currentStore.onConnectStart,\n                onConnectEnd: currentStore.onConnectEnd,\n                updateConnection: currentStore.updateConnection,\n                onConnect: onConnectExtended,\n                isValidConnection: isValidConnection || currentStore.isValidConnection,\n                getTransform: ()=>store.getState().transform,\n                getFromHandle: ()=>store.getState().connection.fromHandle,\n                autoPanSpeed: currentStore.autoPanSpeed\n            });\n        }\n        if (isMouseTriggered) {\n            onMouseDown?.(event);\n        } else {\n            onTouchStart?.(event);\n        }\n    };\n    const onClick = (event)=>{\n        const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, lib, rfId: flowId, nodeLookup, connection: connectionState } = store.getState();\n        if (!nodeId || !connectionClickStartHandle && !isConnectableStart) {\n            return;\n        }\n        if (!connectionClickStartHandle) {\n            onClickConnectStart?.(event.nativeEvent, {\n                nodeId,\n                handleId,\n                handleType: type\n            });\n            store.setState({\n                connectionClickStartHandle: {\n                    nodeId,\n                    type,\n                    id: handleId\n                }\n            });\n            return;\n        }\n        const doc = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getHostForElement)(event.target);\n        const isValidConnectionHandler = isValidConnection || isValidConnectionStore;\n        const { connection, isValid } = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.isValid(event.nativeEvent, {\n            handle: {\n                nodeId,\n                id: handleId,\n                type\n            },\n            connectionMode,\n            fromNodeId: connectionClickStartHandle.nodeId,\n            fromHandleId: connectionClickStartHandle.id || null,\n            fromType: connectionClickStartHandle.type,\n            isValidConnection: isValidConnectionHandler,\n            flowId,\n            doc,\n            lib,\n            nodeLookup\n        });\n        if (isValid && connection) {\n            onConnectExtended(connection);\n        }\n        const connectionClone = structuredClone(connectionState);\n        delete connectionClone.inProgress;\n        connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null;\n        onClickConnectEnd?.(event, connectionClone);\n        store.setState({\n            connectionClickStartHandle: null\n        });\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-handleid\": handleId,\n        \"data-nodeid\": nodeId,\n        \"data-handlepos\": position,\n        \"data-id\": `${rfId}-${nodeId}-${handleId}-${type}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__handle',\n            `react-flow__handle-${position}`,\n            'nodrag',\n            noPanClassName,\n            className,\n            {\n                source: !isTarget,\n                target: isTarget,\n                connectable: isConnectable,\n                connectablestart: isConnectableStart,\n                connectableend: isConnectableEnd,\n                clickconnecting: clickConnecting,\n                connectingfrom: connectingFrom,\n                connectingto: connectingTo,\n                valid,\n                /*\n                 * shows where you can start a connection from\n                 * and where you can end it while connecting\n                 */ connectionindicator: isConnectable && (!connectionInProcess || isPossibleEndHandle) && (connectionInProcess || clickConnectionInProcess ? isConnectableEnd : isConnectableStart)\n            }\n        ]),\n        onMouseDown: onPointerDown,\n        onTouchStart: onPointerDown,\n        onClick: connectOnClick ? onClick : undefined,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n}\n/**\n * The `<Handle />` component is used in your [custom nodes](/learn/customization/custom-nodes)\n * to define connection points.\n *\n *@public\n *\n *@example\n *\n *```jsx\n *import { Handle, Position } from '@xyflow/react';\n *\n *export function CustomNode({ data }) {\n *  return (\n *    <>\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *```\n */ const Handle = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(fixedForwardRef(HandleComponent));\nfunction InputNode({ data, isConnectable, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction DefaultNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction GroupNode() {\n    return null;\n}\nfunction OutputNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label\n        ]\n    });\n}\nconst arrowKeyDiffs = {\n    ArrowUp: {\n        x: 0,\n        y: -1\n    },\n    ArrowDown: {\n        x: 0,\n        y: 1\n    },\n    ArrowLeft: {\n        x: -1,\n        y: 0\n    },\n    ArrowRight: {\n        x: 1,\n        y: 0\n    }\n};\nconst builtinNodeTypes = {\n    input: InputNode,\n    default: DefaultNode,\n    output: OutputNode,\n    group: GroupNode\n};\nfunction getNodeInlineStyleDimensions(node) {\n    if (node.internals.handleBounds === undefined) {\n        return {\n            width: node.width ?? node.initialWidth ?? node.style?.width,\n            height: node.height ?? node.initialHeight ?? node.style?.height\n        };\n    }\n    return {\n        width: node.width ?? node.style?.width,\n        height: node.height ?? node.style?.height\n    };\n}\nconst selector$f = (s)=>{\n    const { width, height, x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n        filter: (node)=>!!node.selected\n    });\n    return {\n        width: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(width) ? width : null,\n        height: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(height) ? height : null,\n        userSelectionActive: s.userSelectionActive,\n        transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]}) translate(${x}px,${y}px)`\n    };\n};\nfunction NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {\n    const store = useStoreApi();\n    const { width, height, transformString, userSelectionActive } = useStore(selector$f, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const moveSelectedNodes = useMoveSelectedNodes();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NodesSelection.useEffect\": ()=>{\n            if (!disableKeyboardA11y) {\n                nodeRef.current?.focus({\n                    preventScroll: true\n                });\n            }\n        }\n    }[\"NodesSelection.useEffect\"], [\n        disableKeyboardA11y\n    ]);\n    useDrag({\n        nodeRef\n    });\n    if (userSelectionActive || !width || !height) {\n        return null;\n    }\n    const onContextMenu = onSelectionContextMenu ? (event)=>{\n        const selectedNodes = store.getState().nodes.filter((n)=>n.selected);\n        onSelectionContextMenu(event, selectedNodes);\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            event.preventDefault();\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__nodesselection',\n            'react-flow__container',\n            noPanClassName\n        ]),\n        style: {\n            transform: transformString\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            ref: nodeRef,\n            className: \"react-flow__nodesselection-rect\",\n            onContextMenu: onContextMenu,\n            tabIndex: disableKeyboardA11y ? undefined : -1,\n            onKeyDown: disableKeyboardA11y ? undefined : onKeyDown,\n            style: {\n                width,\n                height\n            }\n        })\n    });\n}\nconst win =  false ? 0 : undefined;\nconst selector$e = (s)=>{\n    return {\n        nodesSelectionActive: s.nodesSelectionActive,\n        userSelectionActive: s.userSelectionActive\n    };\n};\nfunction FlowRendererComponent({ children, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport }) {\n    const { nodesSelectionActive, userSelectionActive } = useStore(selector$e);\n    const selectionKeyPressed = useKeyPress(selectionKeyCode, {\n        target: win\n    });\n    const panActivationKeyPressed = useKeyPress(panActivationKeyCode, {\n        target: win\n    });\n    const panOnDrag = panActivationKeyPressed || _panOnDrag;\n    const panOnScroll = panActivationKeyPressed || _panOnScroll;\n    const _selectionOnDrag = selectionOnDrag && panOnDrag !== true;\n    const isSelecting = selectionKeyPressed || userSelectionActive || _selectionOnDrag;\n    useGlobalKeyHandler({\n        deleteKeyCode,\n        multiSelectionKeyCode\n    });\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ZoomPane, {\n        onPaneContextMenu: onPaneContextMenu,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnDrag: !selectionKeyPressed && panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        preventScrolling: preventScrolling,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        onViewportChange: onViewportChange,\n        isControlledViewport: isControlledViewport,\n        paneClickDistance: paneClickDistance,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Pane, {\n            onSelectionStart: onSelectionStart,\n            onSelectionEnd: onSelectionEnd,\n            onPaneClick: onPaneClick,\n            onPaneMouseEnter: onPaneMouseEnter,\n            onPaneMouseMove: onPaneMouseMove,\n            onPaneMouseLeave: onPaneMouseLeave,\n            onPaneContextMenu: onPaneContextMenu,\n            onPaneScroll: onPaneScroll,\n            panOnDrag: panOnDrag,\n            isSelecting: !!isSelecting,\n            selectionMode: selectionMode,\n            selectionKeyPressed: selectionKeyPressed,\n            selectionOnDrag: _selectionOnDrag,\n            children: [\n                children,\n                nodesSelectionActive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodesSelection, {\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\nFlowRendererComponent.displayName = 'FlowRenderer';\nconst FlowRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(FlowRendererComponent);\nconst selector$d = (onlyRenderVisible)=>(s)=>{\n        return onlyRenderVisible ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(s.nodeLookup, {\n            x: 0,\n            y: 0,\n            width: s.width,\n            height: s.height\n        }, s.transform, true).map((node)=>node.id) : Array.from(s.nodeLookup.keys());\n    };\n/**\n * Hook for getting the visible node ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible node ids\n */ function useVisibleNodeIds(onlyRenderVisible) {\n    const nodeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(selector$d(onlyRenderVisible), [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodeIds;\n}\nconst selector$c = (s)=>s.updateNodeInternals;\nfunction useResizeObserver() {\n    const updateNodeInternals = useStore(selector$c);\n    const [resizeObserver] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"useResizeObserver.useState\": ()=>{\n            if (typeof ResizeObserver === 'undefined') {\n                return null;\n            }\n            return new ResizeObserver({\n                \"useResizeObserver.useState\": (entries)=>{\n                    const updates = new Map();\n                    entries.forEach({\n                        \"useResizeObserver.useState\": (entry)=>{\n                            const id = entry.target.getAttribute('data-id');\n                            updates.set(id, {\n                                id,\n                                nodeElement: entry.target,\n                                force: true\n                            });\n                        }\n                    }[\"useResizeObserver.useState\"]);\n                    updateNodeInternals(updates);\n                }\n            }[\"useResizeObserver.useState\"]);\n        }\n    }[\"useResizeObserver.useState\"]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useResizeObserver.useEffect\": ()=>{\n            return ({\n                \"useResizeObserver.useEffect\": ()=>{\n                    resizeObserver?.disconnect();\n                }\n            })[\"useResizeObserver.useEffect\"];\n        }\n    }[\"useResizeObserver.useEffect\"], [\n        resizeObserver\n    ]);\n    return resizeObserver;\n}\n/**\n * Hook to handle the resize observation + internal updates for the passed node.\n *\n * @internal\n * @returns nodeRef - reference to the node element\n */ function useNodeObserver({ node, nodeType, hasDimensions, resizeObserver }) {\n    const store = useStoreApi();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const observedNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const prevSourcePosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.sourcePosition);\n    const prevTargetPosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.targetPosition);\n    const prevType = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeType);\n    const isInitialized = hasDimensions && !!node.internals.handleBounds;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            if (nodeRef.current && !node.hidden && (!isInitialized || observedNode.current !== nodeRef.current)) {\n                if (observedNode.current) {\n                    resizeObserver?.unobserve(observedNode.current);\n                }\n                resizeObserver?.observe(nodeRef.current);\n                observedNode.current = nodeRef.current;\n            }\n        }\n    }[\"useNodeObserver.useEffect\"], [\n        isInitialized,\n        node.hidden\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            return ({\n                \"useNodeObserver.useEffect\": ()=>{\n                    if (observedNode.current) {\n                        resizeObserver?.unobserve(observedNode.current);\n                        observedNode.current = null;\n                    }\n                }\n            })[\"useNodeObserver.useEffect\"];\n        }\n    }[\"useNodeObserver.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            if (nodeRef.current) {\n                /*\n             * when the user programmatically changes the source or handle position, we need to update the internals\n             * to make sure the edges are updated correctly\n             */ const typeChanged = prevType.current !== nodeType;\n                const sourcePosChanged = prevSourcePosition.current !== node.sourcePosition;\n                const targetPosChanged = prevTargetPosition.current !== node.targetPosition;\n                if (typeChanged || sourcePosChanged || targetPosChanged) {\n                    prevType.current = nodeType;\n                    prevSourcePosition.current = node.sourcePosition;\n                    prevTargetPosition.current = node.targetPosition;\n                    store.getState().updateNodeInternals(new Map([\n                        [\n                            node.id,\n                            {\n                                id: node.id,\n                                nodeElement: nodeRef.current,\n                                force: true\n                            }\n                        ]\n                    ]));\n                }\n            }\n        }\n    }[\"useNodeObserver.useEffect\"], [\n        node.id,\n        nodeType,\n        node.sourcePosition,\n        node.targetPosition\n    ]);\n    return nodeRef;\n}\nfunction NodeWrapper({ id, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, nodesDraggable, elementsSelectable, nodesConnectable, nodesFocusable, resizeObserver, noDragClassName, noPanClassName, disableKeyboardA11y, rfId, nodeTypes, nodeClickDistance, onError }) {\n    const { node, internals, isParent } = useStore({\n        \"NodeWrapper.useStore\": (s)=>{\n            const node = s.nodeLookup.get(id);\n            const isParent = s.parentLookup.has(id);\n            return {\n                node,\n                internals: node.internals,\n                isParent\n            };\n        }\n    }[\"NodeWrapper.useStore\"], zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    let nodeType = node.type || 'default';\n    let NodeComponent = nodeTypes?.[nodeType] || builtinNodeTypes[nodeType];\n    if (NodeComponent === undefined) {\n        onError?.('003', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error003'](nodeType));\n        nodeType = 'default';\n        NodeComponent = builtinNodeTypes.default;\n    }\n    const isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === 'undefined');\n    const isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === 'undefined');\n    const isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === 'undefined');\n    const isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable === 'undefined');\n    const store = useStoreApi();\n    const hasDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node);\n    const nodeRef = useNodeObserver({\n        node,\n        nodeType,\n        hasDimensions,\n        resizeObserver\n    });\n    const dragging = useDrag({\n        nodeRef,\n        disabled: node.hidden || !isDraggable,\n        noDragClassName,\n        handleSelector: node.dragHandle,\n        nodeId: id,\n        isSelectable,\n        nodeClickDistance\n    });\n    const moveSelectedNodes = useMoveSelectedNodes();\n    if (node.hidden) {\n        return null;\n    }\n    const nodeDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n    const inlineDimensions = getNodeInlineStyleDimensions(node);\n    const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;\n    const onMouseEnterHandler = onMouseEnter ? (event)=>onMouseEnter(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseMoveHandler = onMouseMove ? (event)=>onMouseMove(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseLeaveHandler = onMouseLeave ? (event)=>onMouseLeave(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onContextMenuHandler = onContextMenu ? (event)=>onContextMenu(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onDoubleClickHandler = onDoubleClick ? (event)=>onDoubleClick(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onSelectNodeHandler = (event)=>{\n        const { selectNodesOnDrag, nodeDragThreshold } = store.getState();\n        if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {\n            /*\n             * this handler gets called by XYDrag on drag start when selectNodesOnDrag=true\n             * here we only need to call it when selectNodesOnDrag=false\n             */ handleNodeClick({\n                id,\n                store,\n                nodeRef\n            });\n        }\n        if (onClick) {\n            onClick(event, {\n                ...internals.userNode\n            });\n        }\n    };\n    const onKeyDown = (event)=>{\n        if ((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event.nativeEvent) || disableKeyboardA11y) {\n            return;\n        }\n        if (_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const unselect = event.key === 'Escape';\n            handleNodeClick({\n                id,\n                store,\n                unselect,\n                nodeRef\n            });\n        } else if (isDraggable && node.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            // prevent default scrolling behavior on arrow key press when node is moved\n            event.preventDefault();\n            store.setState({\n                ariaLiveMessage: `Moved selected node ${event.key.replace('Arrow', '').toLowerCase()}. New position, x: ${~~internals.positionAbsolute.x}, y: ${~~internals.positionAbsolute.y}`\n            });\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__node',\n            `react-flow__node-${nodeType}`,\n            {\n                // this is overwritable by passing `nopan` as a class name\n                [noPanClassName]: isDraggable\n            },\n            node.className,\n            {\n                selected: node.selected,\n                selectable: isSelectable,\n                parent: isParent,\n                draggable: isDraggable,\n                dragging\n            }\n        ]),\n        ref: nodeRef,\n        style: {\n            zIndex: internals.z,\n            transform: `translate(${internals.positionAbsolute.x}px,${internals.positionAbsolute.y}px)`,\n            pointerEvents: hasPointerEvents ? 'all' : 'none',\n            visibility: hasDimensions ? 'visible' : 'hidden',\n            ...node.style,\n            ...inlineDimensions\n        },\n        \"data-id\": id,\n        \"data-testid\": `rf__node-${id}`,\n        onMouseEnter: onMouseEnterHandler,\n        onMouseMove: onMouseMoveHandler,\n        onMouseLeave: onMouseLeaveHandler,\n        onContextMenu: onContextMenuHandler,\n        onClick: onSelectNodeHandler,\n        onDoubleClick: onDoubleClickHandler,\n        onKeyDown: isFocusable ? onKeyDown : undefined,\n        tabIndex: isFocusable ? 0 : undefined,\n        role: isFocusable ? 'button' : undefined,\n        \"aria-describedby\": disableKeyboardA11y ? undefined : `${ARIA_NODE_DESC_KEY}-${rfId}`,\n        \"aria-label\": node.ariaLabel,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider, {\n            value: id,\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n                id: id,\n                data: node.data,\n                type: nodeType,\n                positionAbsoluteX: internals.positionAbsolute.x,\n                positionAbsoluteY: internals.positionAbsolute.y,\n                selected: node.selected ?? false,\n                selectable: isSelectable,\n                draggable: isDraggable,\n                deletable: node.deletable ?? true,\n                isConnectable: isConnectable,\n                sourcePosition: node.sourcePosition,\n                targetPosition: node.targetPosition,\n                dragging: dragging,\n                dragHandle: node.dragHandle,\n                zIndex: internals.z,\n                parentId: node.parentId,\n                ...nodeDimensions\n            })\n        })\n    });\n}\nconst selector$b = (s)=>({\n        nodesDraggable: s.nodesDraggable,\n        nodesConnectable: s.nodesConnectable,\n        nodesFocusable: s.nodesFocusable,\n        elementsSelectable: s.elementsSelectable,\n        onError: s.onError\n    });\nfunction NodeRendererComponent(props) {\n    const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, onError } = useStore(selector$b, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeIds = useVisibleNodeIds(props.onlyRenderVisibleElements);\n    const resizeObserver = useResizeObserver();\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__nodes\",\n        style: containerStyle,\n        children: nodeIds.map((nodeId)=>{\n            return(/*\n             * The split of responsibilities between NodeRenderer and\n             * NodeComponentWrapper may appear weird. However, it’s designed to\n             * minimize the cost of updates when individual nodes change.\n             *\n             * For example, when you’re dragging a single node, that node gets\n             * updated multiple times per second. If `NodeRenderer` were to update\n             * every time, it would have to re-run the `nodes.map()` loop every\n             * time. This gets pricey with hundreds of nodes, especially if every\n             * loop cycle does more than just rendering a JSX element!\n             *\n             * As a result of this choice, we took the following implementation\n             * decisions:\n             * - NodeRenderer subscribes *only* to node IDs – and therefore\n             *   rerender *only* when visible nodes are added or removed.\n             * - NodeRenderer performs all operations the result of which can be\n             *   shared between nodes (such as creating the `ResizeObserver`\n             *   instance, or subscribing to `selector`). This means extra prop\n             *   drilling into `NodeComponentWrapper`, but it means we need to run\n             *   these operations only once – instead of once per node.\n             * - Any operations that you’d normally write inside `nodes.map` are\n             *   moved into `NodeComponentWrapper`. This ensures they are\n             *   memorized – so if `NodeRenderer` *has* to rerender, it only\n             *   needs to regenerate the list of nodes, nothing else.\n             */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeWrapper, {\n                id: nodeId,\n                nodeTypes: props.nodeTypes,\n                nodeExtent: props.nodeExtent,\n                onClick: props.onNodeClick,\n                onMouseEnter: props.onNodeMouseEnter,\n                onMouseMove: props.onNodeMouseMove,\n                onMouseLeave: props.onNodeMouseLeave,\n                onContextMenu: props.onNodeContextMenu,\n                onDoubleClick: props.onNodeDoubleClick,\n                noDragClassName: props.noDragClassName,\n                noPanClassName: props.noPanClassName,\n                rfId: props.rfId,\n                disableKeyboardA11y: props.disableKeyboardA11y,\n                resizeObserver: resizeObserver,\n                nodesDraggable: nodesDraggable,\n                nodesConnectable: nodesConnectable,\n                nodesFocusable: nodesFocusable,\n                elementsSelectable: elementsSelectable,\n                nodeClickDistance: props.nodeClickDistance,\n                onError: onError\n            }, nodeId));\n        })\n    });\n}\nNodeRendererComponent.displayName = 'NodeRenderer';\nconst NodeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeRendererComponent);\n/**\n * Hook for getting the visible edge ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible edge ids\n */ function useVisibleEdgeIds(onlyRenderVisible) {\n    const edgeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useVisibleEdgeIds.useStore[edgeIds]\": (s)=>{\n            if (!onlyRenderVisible) {\n                return s.edges.map({\n                    \"useVisibleEdgeIds.useStore[edgeIds]\": (edge)=>edge.id\n                }[\"useVisibleEdgeIds.useStore[edgeIds]\"]);\n            }\n            const visibleEdgeIds = [];\n            if (s.width && s.height) {\n                for (const edge of s.edges){\n                    const sourceNode = s.nodeLookup.get(edge.source);\n                    const targetNode = s.nodeLookup.get(edge.target);\n                    if (sourceNode && targetNode && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeVisible)({\n                        sourceNode,\n                        targetNode,\n                        width: s.width,\n                        height: s.height,\n                        transform: s.transform\n                    })) {\n                        visibleEdgeIds.push(edge.id);\n                    }\n                }\n            }\n            return visibleEdgeIds;\n        }\n    }[\"useVisibleEdgeIds.useStore[edgeIds]\"], [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edgeIds;\n}\nconst ArrowSymbol = ({ color = 'none', strokeWidth = 1 })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        style: {\n            stroke: color,\n            strokeWidth\n        },\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        fill: \"none\",\n        points: \"-5,-4 0,0 -5,4\"\n    });\n};\nconst ArrowClosedSymbol = ({ color = 'none', strokeWidth = 1 })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        style: {\n            stroke: color,\n            fill: color,\n            strokeWidth\n        },\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4 -5,-4\"\n    });\n};\nconst MarkerSymbols = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.Arrow]: ArrowSymbol,\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.ArrowClosed]: ArrowClosedSymbol\n};\nfunction useMarkerSymbol(type) {\n    const store = useStoreApi();\n    const symbol = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useMarkerSymbol.useMemo[symbol]\": ()=>{\n            const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);\n            if (!symbolExists) {\n                store.getState().onError?.('009', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error009'](type));\n                return null;\n            }\n            return MarkerSymbols[type];\n        }\n    }[\"useMarkerSymbol.useMemo[symbol]\"], [\n        type\n    ]);\n    return symbol;\n}\nconst Marker = ({ id, type, color, width = 12.5, height = 12.5, markerUnits = 'strokeWidth', strokeWidth, orient = 'auto-start-reverse' })=>{\n    const Symbol = useMarkerSymbol(type);\n    if (!Symbol) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"marker\", {\n        className: \"react-flow__arrowhead\",\n        id: id,\n        markerWidth: `${width}`,\n        markerHeight: `${height}`,\n        viewBox: \"-10 -10 20 20\",\n        markerUnits: markerUnits,\n        orient: orient,\n        refX: \"0\",\n        refY: \"0\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Symbol, {\n            color: color,\n            strokeWidth: strokeWidth\n        })\n    });\n};\n/*\n * when you have multiple flows on a page and you hide the first one, the other ones have no markers anymore\n * when they do have markers with the same ids. To prevent this the user can pass a unique id to the react flow wrapper\n * that we can then use for creating our unique marker ids\n */ const MarkerDefinitions = ({ defaultColor, rfId })=>{\n    const edges = useStore({\n        \"MarkerDefinitions.useStore[edges]\": (s)=>s.edges\n    }[\"MarkerDefinitions.useStore[edges]\"]);\n    const defaultEdgeOptions = useStore({\n        \"MarkerDefinitions.useStore[defaultEdgeOptions]\": (s)=>s.defaultEdgeOptions\n    }[\"MarkerDefinitions.useStore[defaultEdgeOptions]\"]);\n    const markers = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"MarkerDefinitions.useMemo[markers]\": ()=>{\n            const markers = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.createMarkerIds)(edges, {\n                id: rfId,\n                defaultColor,\n                defaultMarkerStart: defaultEdgeOptions?.markerStart,\n                defaultMarkerEnd: defaultEdgeOptions?.markerEnd\n            });\n            return markers;\n        }\n    }[\"MarkerDefinitions.useMemo[markers]\"], [\n        edges,\n        defaultEdgeOptions,\n        rfId,\n        defaultColor\n    ]);\n    if (!markers.length) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        className: \"react-flow__marker\",\n        \"aria-hidden\": \"true\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"defs\", {\n            children: markers.map((marker)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Marker, {\n                    id: marker.id,\n                    type: marker.type,\n                    color: marker.color,\n                    width: marker.width,\n                    height: marker.height,\n                    markerUnits: marker.markerUnits,\n                    strokeWidth: marker.strokeWidth,\n                    orient: marker.orient\n                }, marker.id))\n        })\n    });\n};\nMarkerDefinitions.displayName = 'MarkerDefinitions';\nvar MarkerDefinitions$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MarkerDefinitions);\nfunction EdgeTextComponent({ x, y, label, labelStyle, labelShowBg = true, labelBgStyle, labelBgPadding = [\n    2,\n    4\n], labelBgBorderRadius = 2, children, className, ...rest }) {\n    const [edgeTextBbox, setEdgeTextBbox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 1,\n        y: 0,\n        width: 0,\n        height: 0\n    });\n    const edgeTextClasses = (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n        'react-flow__edge-textwrapper',\n        className\n    ]);\n    const edgeTextRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"EdgeTextComponent.useEffect\": ()=>{\n            if (edgeTextRef.current) {\n                const textBbox = edgeTextRef.current.getBBox();\n                setEdgeTextBbox({\n                    x: textBbox.x,\n                    y: textBbox.y,\n                    width: textBbox.width,\n                    height: textBbox.height\n                });\n            }\n        }\n    }[\"EdgeTextComponent.useEffect\"], [\n        label\n    ]);\n    if (!label) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n        transform: `translate(${x - edgeTextBbox.width / 2} ${y - edgeTextBbox.height / 2})`,\n        className: edgeTextClasses,\n        visibility: edgeTextBbox.width ? 'visible' : 'hidden',\n        ...rest,\n        children: [\n            labelShowBg && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                width: edgeTextBbox.width + 2 * labelBgPadding[0],\n                x: -labelBgPadding[0],\n                y: -labelBgPadding[1],\n                height: edgeTextBbox.height + 2 * labelBgPadding[1],\n                className: \"react-flow__edge-textbg\",\n                style: labelBgStyle,\n                rx: labelBgBorderRadius,\n                ry: labelBgBorderRadius\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"text\", {\n                className: \"react-flow__edge-text\",\n                y: edgeTextBbox.height / 2,\n                dy: \"0.3em\",\n                ref: edgeTextRef,\n                style: labelStyle,\n                children: label\n            }),\n            children\n        ]\n    });\n}\nEdgeTextComponent.displayName = 'EdgeText';\n/**\n * You can use the `<EdgeText />` component as a helper component to display text\n * within your custom edges.\n *\n * @public\n *\n * @example\n * ```jsx\n * import { EdgeText } from '@xyflow/react';\n *\n * export function CustomEdgeLabel({ label }) {\n *   return (\n *     <EdgeText\n *       x={100}\n *       y={100}\n *       label={label}\n *       labelStyle={{ fill: 'white' }}\n *       labelShowBg\n *       labelBgStyle={{ fill: 'red' }}\n *       labelBgPadding={[2, 4]}\n *       labelBgBorderRadius={2}\n *     />\n *   );\n * }\n *```\n */ const EdgeText = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeTextComponent);\n/**\n * The `<BaseEdge />` component gets used internally for all the edges. It can be\n * used inside a custom edge and handles the invisible helper edge and the edge label\n * for you.\n *\n * @public\n * @example\n * ```jsx\n *import { BaseEdge } from '@xyflow/react';\n *\n *export function CustomEdge({ sourceX, sourceY, targetX, targetY, ...props }) {\n *  const [edgePath] = getStraightPath({\n *    sourceX,\n *    sourceY,\n *    targetX,\n *    targetY,\n *  });\n *\n *  return <BaseEdge path={edgePath} {...props} />;\n *}\n *```\n *\n * @remarks If you want to use an edge marker with the [`<BaseEdge />`](/api-reference/components/base-edge) component,\n * you can pass the `markerStart` or `markerEnd` props passed to your custom edge\n * through to the [`<BaseEdge />`](/api-reference/components/base-edge) component.\n * You can see all the props passed to a custom edge by looking at the [`EdgeProps`](/api-reference/types/edge-props) type.\n */ function BaseEdge({ path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, interactionWidth = 20, ...props }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                ...props,\n                d: path,\n                fill: \"none\",\n                className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                    'react-flow__edge-path',\n                    props.className\n                ])\n            }),\n            interactionWidth && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: path,\n                fill: \"none\",\n                strokeOpacity: 0,\n                strokeWidth: interactionWidth,\n                className: \"react-flow__edge-interaction\"\n            }),\n            label && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelX) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelY) ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeText, {\n                x: labelX,\n                y: labelY,\n                label: label,\n                labelStyle: labelStyle,\n                labelShowBg: labelShowBg,\n                labelBgStyle: labelBgStyle,\n                labelBgPadding: labelBgPadding,\n                labelBgBorderRadius: labelBgBorderRadius\n            }) : null\n        ]\n    });\n}\nfunction getControl({ pos, x1, y1, x2, y2 }) {\n    if (pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left || pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) {\n        return [\n            0.5 * (x1 + x2),\n            y1\n        ];\n    }\n    return [\n        x1,\n        0.5 * (y1 + y2)\n    ];\n}\n/**\n * The `getSimpleBezierPath` util returns everything you need to render a simple\n * bezier edge between two nodes.\n * @public\n * @returns\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n */ function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetX, targetY, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    const [sourceControlX, sourceControlY] = getControl({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY\n    });\n    const [targetControlX, targetControlY] = getControl({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY\n    });\n    const [labelX, labelY, offsetX, offsetY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter)({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nfunction createSimpleBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = getSimpleBezierPath({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst SimpleBezierEdge = createSimpleBezierEdge({\n    isInternal: false\n});\nconst SimpleBezierEdgeInternal = createSimpleBezierEdge({\n    isInternal: true\n});\nSimpleBezierEdge.displayName = 'SimpleBezierEdge';\nSimpleBezierEdgeInternal.displayName = 'SimpleBezierEdgeInternal';\nfunction createSmoothStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            borderRadius: pathOptions?.borderRadius,\n            offset: pathOptions?.offset\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a smooth step edge.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { SmoothStepEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <SmoothStepEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const SmoothStepEdge = createSmoothStepEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const SmoothStepEdgeInternal = createSmoothStepEdge({\n    isInternal: true\n});\nSmoothStepEdge.displayName = 'SmoothStepEdge';\nSmoothStepEdgeInternal.displayName = 'SmoothStepEdgeInternal';\nfunction createStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, ...props })=>{\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SmoothStepEdge, {\n            ...props,\n            id: _id,\n            pathOptions: (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n                \"createStepEdge.useMemo\": ()=>({\n                        borderRadius: 0,\n                        offset: props.pathOptions?.offset\n                    })\n            }[\"createStepEdge.useMemo\"], [\n                props.pathOptions?.offset\n            ])\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a step edge.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { StepEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <StepEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const StepEdge = createStepEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const StepEdgeInternal = createStepEdge({\n    isInternal: true\n});\nStepEdge.displayName = 'StepEdge';\nStepEdgeInternal.displayName = 'StepEdgeInternal';\nfunction createStraightEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)({\n            sourceX,\n            sourceY,\n            targetX,\n            targetY\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a straight line.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { StraightEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY }) {\n *   return (\n *     <StraightEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *     />\n *   );\n * }\n * ```\n */ const StraightEdge = createStraightEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const StraightEdgeInternal = createStraightEdge({\n    isInternal: true\n});\nStraightEdge.displayName = 'StraightEdge';\nStraightEdgeInternal.displayName = 'StraightEdgeInternal';\nfunction createBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            curvature: pathOptions?.curvature\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a bezier curve.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { BezierEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <BezierEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const BezierEdge = createBezierEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const BezierEdgeInternal = createBezierEdge({\n    isInternal: true\n});\nBezierEdge.displayName = 'BezierEdge';\nBezierEdgeInternal.displayName = 'BezierEdgeInternal';\nconst builtinEdgeTypes = {\n    default: BezierEdgeInternal,\n    straight: StraightEdgeInternal,\n    step: StepEdgeInternal,\n    smoothstep: SmoothStepEdgeInternal,\n    simplebezier: SimpleBezierEdgeInternal\n};\nconst nullPosition = {\n    sourceX: null,\n    sourceY: null,\n    targetX: null,\n    targetY: null,\n    sourcePosition: null,\n    targetPosition: null\n};\nconst shiftX = (x, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left) return x - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) return x + shift;\n    return x;\n};\nconst shiftY = (y, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top) return y - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom) return y + shift;\n    return y;\n};\nconst EdgeUpdaterClassName = 'react-flow__edgeupdater';\n/**\n * @internal\n */ function EdgeAnchor({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            EdgeUpdaterClassName,\n            `${EdgeUpdaterClassName}-${type}`\n        ]),\n        cx: shiftX(centerX, radius, position),\n        cy: shiftY(centerY, radius, position),\n        r: radius,\n        stroke: \"transparent\",\n        fill: \"transparent\"\n    });\n}\nfunction EdgeUpdateAnchors({ isReconnectable, reconnectRadius, edge, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, onReconnect, onReconnectStart, onReconnectEnd, setReconnecting, setUpdateHover }) {\n    const store = useStoreApi();\n    const handleEdgeUpdater = (event, oppositeHandle)=>{\n        // avoid triggering edge updater if mouse btn is not left\n        if (event.button !== 0) {\n            return;\n        }\n        const { autoPanOnConnect, domNode, isValidConnection, connectionMode, connectionRadius, lib, onConnectStart, onConnectEnd, cancelConnection, nodeLookup, rfId: flowId, panBy, updateConnection } = store.getState();\n        const isTarget = oppositeHandle.type === 'target';\n        setReconnecting(true);\n        onReconnectStart?.(event, edge, oppositeHandle.type);\n        const _onReconnectEnd = (evt, connectionState)=>{\n            setReconnecting(false);\n            onReconnectEnd?.(evt, edge, oppositeHandle.type, connectionState);\n        };\n        const onConnectEdge = (connection)=>onReconnect?.(edge, connection);\n        _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n            autoPanOnConnect,\n            connectionMode,\n            connectionRadius,\n            domNode,\n            handleId: oppositeHandle.id,\n            nodeId: oppositeHandle.nodeId,\n            nodeLookup,\n            isTarget,\n            edgeUpdaterType: oppositeHandle.type,\n            lib,\n            flowId,\n            cancelConnection,\n            panBy,\n            isValidConnection,\n            onConnect: onConnectEdge,\n            onConnectStart,\n            onConnectEnd,\n            onReconnectEnd: _onReconnectEnd,\n            updateConnection,\n            getTransform: ()=>store.getState().transform,\n            getFromHandle: ()=>store.getState().connection.fromHandle\n        });\n    };\n    const onReconnectSourceMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.target,\n            id: edge.targetHandle ?? null,\n            type: 'target'\n        });\n    const onReconnectTargetMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.source,\n            id: edge.sourceHandle ?? null,\n            type: 'source'\n        });\n    const onReconnectMouseEnter = ()=>setUpdateHover(true);\n    const onReconnectMouseOut = ()=>setUpdateHover(false);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (isReconnectable === true || isReconnectable === 'source') && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: sourcePosition,\n                centerX: sourceX,\n                centerY: sourceY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectSourceMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"source\"\n            }),\n            (isReconnectable === true || isReconnectable === 'target') && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: targetPosition,\n                centerX: targetX,\n                centerY: targetY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectTargetMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"target\"\n            })\n        ]\n    });\n}\nfunction EdgeWrapper({ id, edgesFocusable, edgesReconnectable, elementsSelectable, onClick, onDoubleClick, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, rfId, edgeTypes, noPanClassName, onError, disableKeyboardA11y }) {\n    let edge = useStore({\n        \"EdgeWrapper.useStore[edge]\": (s)=>s.edgeLookup.get(id)\n    }[\"EdgeWrapper.useStore[edge]\"]);\n    const defaultEdgeOptions = useStore({\n        \"EdgeWrapper.useStore[defaultEdgeOptions]\": (s)=>s.defaultEdgeOptions\n    }[\"EdgeWrapper.useStore[defaultEdgeOptions]\"]);\n    edge = defaultEdgeOptions ? {\n        ...defaultEdgeOptions,\n        ...edge\n    } : edge;\n    let edgeType = edge.type || 'default';\n    let EdgeComponent = edgeTypes?.[edgeType] || builtinEdgeTypes[edgeType];\n    if (EdgeComponent === undefined) {\n        onError?.('011', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error011'](edgeType));\n        edgeType = 'default';\n        EdgeComponent = builtinEdgeTypes.default;\n    }\n    const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable === 'undefined');\n    const isReconnectable = typeof onReconnect !== 'undefined' && (edge.reconnectable || edgesReconnectable && typeof edge.reconnectable === 'undefined');\n    const isSelectable = !!(edge.selectable || elementsSelectable && typeof edge.selectable === 'undefined');\n    const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [updateHover, setUpdateHover] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [reconnecting, setReconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const store = useStoreApi();\n    const { zIndex, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition } = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EdgeWrapper.useStore.useCallback\": (store)=>{\n            const sourceNode = store.nodeLookup.get(edge.source);\n            const targetNode = store.nodeLookup.get(edge.target);\n            if (!sourceNode || !targetNode) {\n                return {\n                    zIndex: edge.zIndex,\n                    ...nullPosition\n                };\n            }\n            const edgePosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgePosition)({\n                id,\n                sourceNode,\n                targetNode,\n                sourceHandle: edge.sourceHandle || null,\n                targetHandle: edge.targetHandle || null,\n                connectionMode: store.connectionMode,\n                onError\n            });\n            const zIndex = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElevatedEdgeZIndex)({\n                selected: edge.selected,\n                zIndex: edge.zIndex,\n                sourceNode,\n                targetNode,\n                elevateOnSelect: store.elevateEdgesOnSelect\n            });\n            return {\n                zIndex,\n                ...edgePosition || nullPosition\n            };\n        }\n    }[\"EdgeWrapper.useStore.useCallback\"], [\n        edge.source,\n        edge.target,\n        edge.sourceHandle,\n        edge.targetHandle,\n        edge.selected,\n        edge.zIndex\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const markerStartUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"EdgeWrapper.useMemo[markerStartUrl]\": ()=>edge.markerStart ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerStart, rfId)}')` : undefined\n    }[\"EdgeWrapper.useMemo[markerStartUrl]\"], [\n        edge.markerStart,\n        rfId\n    ]);\n    const markerEndUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"EdgeWrapper.useMemo[markerEndUrl]\": ()=>edge.markerEnd ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerEnd, rfId)}')` : undefined\n    }[\"EdgeWrapper.useMemo[markerEndUrl]\"], [\n        edge.markerEnd,\n        rfId\n    ]);\n    if (edge.hidden || sourceX === null || sourceY === null || targetX === null || targetY === null) {\n        return null;\n    }\n    const onEdgeClick = (event)=>{\n        const { addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();\n        if (isSelectable) {\n            store.setState({\n                nodesSelectionActive: false\n            });\n            if (edge.selected && multiSelectionActive) {\n                unselectNodesAndEdges({\n                    nodes: [],\n                    edges: [\n                        edge\n                    ]\n                });\n                edgeRef.current?.blur();\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n        if (onClick) {\n            onClick(event, edge);\n        }\n    };\n    const onEdgeDoubleClick = onDoubleClick ? (event)=>{\n        onDoubleClick(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeContextMenu = onContextMenu ? (event)=>{\n        onContextMenu(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseEnter = onMouseEnter ? (event)=>{\n        onMouseEnter(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseMove = onMouseMove ? (event)=>{\n        onMouseMove(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseLeave = onMouseLeave ? (event)=>{\n        onMouseLeave(event, {\n            ...edge\n        });\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (!disableKeyboardA11y && _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const { unselectNodesAndEdges, addSelectedEdges } = store.getState();\n            const unselect = event.key === 'Escape';\n            if (unselect) {\n                edgeRef.current?.blur();\n                unselectNodesAndEdges({\n                    edges: [\n                        edge\n                    ]\n                });\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: {\n            zIndex\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                'react-flow__edge',\n                `react-flow__edge-${edgeType}`,\n                edge.className,\n                noPanClassName,\n                {\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    inactive: !isSelectable && !onClick,\n                    updating: updateHover,\n                    selectable: isSelectable\n                }\n            ]),\n            onClick: onEdgeClick,\n            onDoubleClick: onEdgeDoubleClick,\n            onContextMenu: onEdgeContextMenu,\n            onMouseEnter: onEdgeMouseEnter,\n            onMouseMove: onEdgeMouseMove,\n            onMouseLeave: onEdgeMouseLeave,\n            onKeyDown: isFocusable ? onKeyDown : undefined,\n            tabIndex: isFocusable ? 0 : undefined,\n            role: isFocusable ? 'button' : 'img',\n            \"data-id\": id,\n            \"data-testid\": `rf__edge-${id}`,\n            \"aria-label\": edge.ariaLabel === null ? undefined : edge.ariaLabel || `Edge from ${edge.source} to ${edge.target}`,\n            \"aria-describedby\": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : undefined,\n            ref: edgeRef,\n            children: [\n                !reconnecting && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeComponent, {\n                    id: id,\n                    source: edge.source,\n                    target: edge.target,\n                    type: edge.type,\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    selectable: isSelectable,\n                    deletable: edge.deletable ?? true,\n                    label: edge.label,\n                    labelStyle: edge.labelStyle,\n                    labelShowBg: edge.labelShowBg,\n                    labelBgStyle: edge.labelBgStyle,\n                    labelBgPadding: edge.labelBgPadding,\n                    labelBgBorderRadius: edge.labelBgBorderRadius,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    data: edge.data,\n                    style: edge.style,\n                    sourceHandleId: edge.sourceHandle,\n                    targetHandleId: edge.targetHandle,\n                    markerStart: markerStartUrl,\n                    markerEnd: markerEndUrl,\n                    pathOptions: 'pathOptions' in edge ? edge.pathOptions : undefined,\n                    interactionWidth: edge.interactionWidth\n                }),\n                isReconnectable && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeUpdateAnchors, {\n                    edge: edge,\n                    isReconnectable: isReconnectable,\n                    reconnectRadius: reconnectRadius,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    setUpdateHover: setUpdateHover,\n                    setReconnecting: setReconnecting\n                })\n            ]\n        })\n    });\n}\nconst selector$a = (s)=>({\n        edgesFocusable: s.edgesFocusable,\n        edgesReconnectable: s.edgesReconnectable,\n        elementsSelectable: s.elementsSelectable,\n        connectionMode: s.connectionMode,\n        onError: s.onError\n    });\nfunction EdgeRendererComponent({ defaultMarkerColor, onlyRenderVisibleElements, rfId, edgeTypes, noPanClassName, onReconnect, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, reconnectRadius, onEdgeDoubleClick, onReconnectStart, onReconnectEnd, disableKeyboardA11y }) {\n    const { edgesFocusable, edgesReconnectable, elementsSelectable, onError } = useStore(selector$a, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const edgeIds = useVisibleEdgeIds(onlyRenderVisibleElements);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: \"react-flow__edges\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MarkerDefinitions$1, {\n                defaultColor: defaultMarkerColor,\n                rfId: rfId\n            }),\n            edgeIds.map((id)=>{\n                return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeWrapper, {\n                    id: id,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    noPanClassName: noPanClassName,\n                    onReconnect: onReconnect,\n                    onContextMenu: onEdgeContextMenu,\n                    onMouseEnter: onEdgeMouseEnter,\n                    onMouseMove: onEdgeMouseMove,\n                    onMouseLeave: onEdgeMouseLeave,\n                    onClick: onEdgeClick,\n                    reconnectRadius: reconnectRadius,\n                    onDoubleClick: onEdgeDoubleClick,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    rfId: rfId,\n                    onError: onError,\n                    edgeTypes: edgeTypes,\n                    disableKeyboardA11y: disableKeyboardA11y\n                }, id);\n            })\n        ]\n    });\n}\nEdgeRendererComponent.displayName = 'EdgeRenderer';\nconst EdgeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeRendererComponent);\nconst selector$9 = (s)=>`translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;\nfunction Viewport({ children }) {\n    const transform = useStore(selector$9);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__viewport xyflow__viewport react-flow__container\",\n        style: {\n            transform\n        },\n        children: children\n    });\n}\n/**\n * Hook for calling onInit handler.\n *\n * @internal\n */ function useOnInitHandler(onInit) {\n    const rfInstance = useReactFlow();\n    const isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnInitHandler.useEffect\": ()=>{\n            if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {\n                setTimeout({\n                    \"useOnInitHandler.useEffect\": ()=>onInit(rfInstance)\n                }[\"useOnInitHandler.useEffect\"], 1);\n                isInitialized.current = true;\n            }\n        }\n    }[\"useOnInitHandler.useEffect\"], [\n        onInit,\n        rfInstance.viewportInitialized\n    ]);\n}\nconst selector$8 = (state)=>state.panZoom?.syncViewport;\n/**\n * Hook for syncing the viewport with the panzoom instance.\n *\n * @internal\n * @param viewport\n */ function useViewportSync(viewport) {\n    const syncViewport = useStore(selector$8);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useViewportSync.useEffect\": ()=>{\n            if (viewport) {\n                syncViewport?.(viewport);\n                store.setState({\n                    transform: [\n                        viewport.x,\n                        viewport.y,\n                        viewport.zoom\n                    ]\n                });\n            }\n        }\n    }[\"useViewportSync.useEffect\"], [\n        viewport,\n        syncViewport\n    ]);\n    return null;\n}\nfunction storeSelector$1(s) {\n    return s.connection.inProgress ? {\n        ...s.connection,\n        to: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(s.connection.to, s.transform)\n    } : {\n        ...s.connection\n    };\n}\nfunction getSelector(connectionSelector) {\n    if (connectionSelector) {\n        const combinedSelector = (s)=>{\n            const connection = storeSelector$1(s);\n            return connectionSelector(connection);\n        };\n        return combinedSelector;\n    }\n    return storeSelector$1;\n}\n/**\n * The `useConnection` hook returns the current connection when there is an active\n * connection interaction. If no connection interaction is active, it returns null\n * for every property. A typical use case for this hook is to colorize handles\n * based on a certain condition (e.g. if the connection is valid or not).\n *\n * @public\n * @param connectionSelector - An optional selector function used to extract a slice of the\n * `ConnectionState` data. Using a selector can prevent component re-renders where data you don't\n * otherwise care about might change. If a selector is not provided, the entire `ConnectionState`\n * object is returned unchanged.\n * @example\n *\n * ```tsx\n *import { useConnection } from '@xyflow/react';\n *\n *function App() {\n *  const connection = useConnection();\n *\n *  return (\n *    <div> {connection ? `Someone is trying to make a connection from ${connection.fromNode} to this one.` : 'There are currently no incoming connections!'}\n *\n *   </div>\n *   );\n * }\n * ```\n *\n * @returns ConnectionState\n */ function useConnection(connectionSelector) {\n    const combinedSelector = getSelector(connectionSelector);\n    return useStore(combinedSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n}\nconst selector$7 = (s)=>({\n        nodesConnectable: s.nodesConnectable,\n        isValid: s.connection.isValid,\n        inProgress: s.connection.inProgress,\n        width: s.width,\n        height: s.height\n    });\nfunction ConnectionLineWrapper({ containerStyle, style, type, component }) {\n    const { nodesConnectable, width, height, isValid, inProgress } = useStore(selector$7, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const renderConnection = !!(width && nodesConnectable && inProgress);\n    if (!renderConnection) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: containerStyle,\n        width: width,\n        height: height,\n        className: \"react-flow__connectionline react-flow__container\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                'react-flow__connection',\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid)\n            ]),\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLine, {\n                style: style,\n                type: type,\n                CustomComponent: component,\n                isValid: isValid\n            })\n        })\n    });\n}\nconst ConnectionLine = ({ style, type = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, CustomComponent, isValid })=>{\n    const { inProgress, from, fromNode, fromHandle, fromPosition, to, toNode, toHandle, toPosition } = useConnection();\n    if (!inProgress) {\n        return;\n    }\n    if (CustomComponent) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomComponent, {\n            connectionLineType: type,\n            connectionLineStyle: style,\n            fromNode: fromNode,\n            fromHandle: fromHandle,\n            fromX: from.x,\n            fromY: from.y,\n            toX: to.x,\n            toY: to.y,\n            fromPosition: fromPosition,\n            toPosition: toPosition,\n            connectionStatus: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid),\n            toNode: toNode,\n            toHandle: toHandle\n        });\n    }\n    let path = '';\n    const pathParams = {\n        sourceX: from.x,\n        sourceY: from.y,\n        sourcePosition: fromPosition,\n        targetX: to.x,\n        targetY: to.y,\n        targetPosition: toPosition\n    };\n    switch(type){\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SimpleBezier:\n            [path] = getSimpleBezierPath(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Step:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n                ...pathParams,\n                borderRadius: 0\n            });\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SmoothStep:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)(pathParams);\n            break;\n        default:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)(pathParams);\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: path,\n        fill: \"none\",\n        className: \"react-flow__connection-path\",\n        style: style\n    });\n};\nConnectionLine.displayName = 'ConnectionLine';\nconst emptyTypes = {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodeOrEdgeTypesWarning(nodeOrEdgeTypes = emptyTypes) {\n    const typesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeOrEdgeTypes);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeOrEdgeTypesWarning.useEffect\": ()=>{\n            if (true) {\n                const usedKeys = new Set([\n                    ...Object.keys(typesRef.current),\n                    ...Object.keys(nodeOrEdgeTypes)\n                ]);\n                for (const key of usedKeys){\n                    if (typesRef.current[key] !== nodeOrEdgeTypes[key]) {\n                        store.getState().onError?.('002', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error002']());\n                        break;\n                    }\n                }\n                typesRef.current = nodeOrEdgeTypes;\n            }\n        }\n    }[\"useNodeOrEdgeTypesWarning.useEffect\"], [\n        nodeOrEdgeTypes\n    ]);\n}\nfunction useStylesLoadedWarning() {\n    const store = useStoreApi();\n    const checked = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useStylesLoadedWarning.useEffect\": ()=>{\n            if (true) {\n                if (!checked.current) {\n                    const pane = document.querySelector('.react-flow__pane');\n                    if (pane && !(window.getComputedStyle(pane).zIndex === '1')) {\n                        store.getState().onError?.('013', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error013']('react'));\n                    }\n                    checked.current = true;\n                }\n            }\n        }\n    }[\"useStylesLoadedWarning.useEffect\"], []);\n}\nfunction GraphViewComponent({ nodeTypes, edgeTypes, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, nodeExtent, rfId, viewport, onViewportChange }) {\n    useNodeOrEdgeTypesWarning(nodeTypes);\n    useNodeOrEdgeTypesWarning(edgeTypes);\n    useStylesLoadedWarning();\n    useOnInitHandler(onInit);\n    useViewportSync(viewport);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FlowRenderer, {\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneContextMenu: onPaneContextMenu,\n        onPaneScroll: onPaneScroll,\n        paneClickDistance: paneClickDistance,\n        deleteKeyCode: deleteKeyCode,\n        selectionKeyCode: selectionKeyCode,\n        selectionOnDrag: selectionOnDrag,\n        selectionMode: selectionMode,\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        multiSelectionKeyCode: multiSelectionKeyCode,\n        panActivationKeyCode: panActivationKeyCode,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        panOnDrag: panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        onSelectionContextMenu: onSelectionContextMenu,\n        preventScrolling: preventScrolling,\n        noDragClassName: noDragClassName,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        disableKeyboardA11y: disableKeyboardA11y,\n        onViewportChange: onViewportChange,\n        isControlledViewport: !!viewport,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Viewport, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeRenderer, {\n                    edgeTypes: edgeTypes,\n                    onEdgeClick: onEdgeClick,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLineWrapper, {\n                    style: connectionLineStyle,\n                    type: connectionLineType,\n                    component: connectionLineComponent,\n                    containerStyle: connectionLineContainerStyle\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__edgelabel-renderer\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeRenderer, {\n                    nodeTypes: nodeTypes,\n                    onNodeClick: onNodeClick,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    nodeClickDistance: nodeClickDistance,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    noPanClassName: noPanClassName,\n                    noDragClassName: noDragClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__viewport-portal\"\n                })\n            ]\n        })\n    });\n}\nGraphViewComponent.displayName = 'GraphView';\nconst GraphView = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(GraphViewComponent);\nconst getInitialState = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom = 0.5, maxZoom = 2, nodeOrigin, nodeExtent } = {})=>{\n    const nodeLookup = new Map();\n    const parentLookup = new Map();\n    const connectionLookup = new Map();\n    const edgeLookup = new Map();\n    const storeEdges = defaultEdges ?? edges ?? [];\n    const storeNodes = defaultNodes ?? nodes ?? [];\n    const storeNodeOrigin = nodeOrigin ?? [\n        0,\n        0\n    ];\n    const storeNodeExtent = nodeExtent ?? _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent;\n    (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, storeEdges);\n    const nodesInitialized = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(storeNodes, nodeLookup, parentLookup, {\n        nodeOrigin: storeNodeOrigin,\n        nodeExtent: storeNodeExtent,\n        elevateNodesOnSelect: false\n    });\n    let transform = [\n        0,\n        0,\n        1\n    ];\n    if (fitView && width && height) {\n        const bounds = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodeLookup, {\n            filter: (node)=>!!((node.width || node.initialWidth) && (node.height || node.initialHeight))\n        });\n        const { x, y, zoom } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, fitViewOptions?.padding ?? 0.1);\n        transform = [\n            x,\n            y,\n            zoom\n        ];\n    }\n    return {\n        rfId: '1',\n        width: 0,\n        height: 0,\n        transform,\n        nodes: storeNodes,\n        nodesInitialized,\n        nodeLookup,\n        parentLookup,\n        edges: storeEdges,\n        edgeLookup,\n        connectionLookup,\n        onNodesChange: null,\n        onEdgesChange: null,\n        hasDefaultNodes: defaultNodes !== undefined,\n        hasDefaultEdges: defaultEdges !== undefined,\n        panZoom: null,\n        minZoom,\n        maxZoom,\n        translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n        nodeExtent: storeNodeExtent,\n        nodesSelectionActive: false,\n        userSelectionActive: false,\n        userSelectionRect: null,\n        connectionMode: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict,\n        domNode: null,\n        paneDragging: false,\n        noPanClassName: 'nopan',\n        nodeOrigin: storeNodeOrigin,\n        nodeDragThreshold: 1,\n        snapGrid: [\n            15,\n            15\n        ],\n        snapToGrid: false,\n        nodesDraggable: true,\n        nodesConnectable: true,\n        nodesFocusable: true,\n        edgesFocusable: true,\n        edgesReconnectable: true,\n        elementsSelectable: true,\n        elevateNodesOnSelect: true,\n        elevateEdgesOnSelect: false,\n        selectNodesOnDrag: true,\n        multiSelectionActive: false,\n        fitViewQueued: fitView ?? false,\n        fitViewOptions,\n        fitViewResolver: null,\n        connection: {\n            ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n        },\n        connectionClickStartHandle: null,\n        connectOnClick: true,\n        ariaLiveMessage: '',\n        autoPanOnConnect: true,\n        autoPanOnNodeDrag: true,\n        autoPanSpeed: 15,\n        connectionRadius: 20,\n        onError: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.devWarn,\n        isValidConnection: undefined,\n        onSelectionChangeHandlers: [],\n        lib: 'react',\n        debug: false\n    };\n};\nconst createStore = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent })=>(0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.createWithEqualityFn)((set, get)=>{\n        async function resolveFitView() {\n            const { nodeLookup, panZoom, fitViewOptions, fitViewResolver, width, height, minZoom, maxZoom } = get();\n            if (!panZoom) {\n                return;\n            }\n            await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.fitViewport)({\n                nodes: nodeLookup,\n                width,\n                height,\n                panZoom,\n                minZoom,\n                maxZoom\n            }, fitViewOptions);\n            fitViewResolver?.resolve(true);\n            /**\n         * wait for the fitViewport to resolve before deleting the resolver,\n         * we want to reuse the old resolver if the user calls fitView again in the mean time\n         */ set({\n                fitViewResolver: null\n            });\n        }\n        return {\n            ...getInitialState({\n                nodes,\n                edges,\n                width,\n                height,\n                fitView,\n                fitViewOptions,\n                minZoom,\n                maxZoom,\n                nodeOrigin,\n                nodeExtent,\n                defaultNodes,\n                defaultEdges\n            }),\n            setNodes: (nodes)=>{\n                const { nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, fitViewQueued } = get();\n                /*\n             * setNodes() is called exclusively in response to user actions:\n             * - either when the `<ReactFlow nodes>` prop is updated in the controlled ReactFlow setup,\n             * - or when the user calls something like `reactFlowInstance.setNodes()` in an uncontrolled ReactFlow setup.\n             *\n             * When this happens, we take the note objects passed by the user and extend them with fields\n             * relevant for internal React Flow operations.\n             */ const nodesInitialized = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: true\n                });\n                if (fitViewQueued && nodesInitialized) {\n                    resolveFitView();\n                    set({\n                        nodes,\n                        nodesInitialized,\n                        fitViewQueued: false,\n                        fitViewOptions: undefined\n                    });\n                } else {\n                    set({\n                        nodes,\n                        nodesInitialized\n                    });\n                }\n            },\n            setEdges: (edges)=>{\n                const { connectionLookup, edgeLookup } = get();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, edges);\n                set({\n                    edges\n                });\n            },\n            setDefaultNodesAndEdges: (nodes, edges)=>{\n                if (nodes) {\n                    const { setNodes } = get();\n                    setNodes(nodes);\n                    set({\n                        hasDefaultNodes: true\n                    });\n                }\n                if (edges) {\n                    const { setEdges } = get();\n                    setEdges(edges);\n                    set({\n                        hasDefaultEdges: true\n                    });\n                }\n            },\n            /*\n         * Every node gets registerd at a ResizeObserver. Whenever a node\n         * changes its dimensions, this function is called to measure the\n         * new dimensions and update the nodes.\n         */ updateNodeInternals: (updates)=>{\n                const { triggerNodeChanges, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent, debug, fitViewQueued } = get();\n                const { changes, updatedInternals } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateNodeInternals)(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent);\n                if (!updatedInternals) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateAbsolutePositions)(nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent\n                });\n                if (fitViewQueued) {\n                    resolveFitView();\n                    set({\n                        fitViewQueued: false,\n                        fitViewOptions: undefined\n                    });\n                } else {\n                    // we always want to trigger useStore calls whenever updateNodeInternals is called\n                    set({});\n                }\n                if (changes?.length > 0) {\n                    if (debug) {\n                        console.log('React Flow: trigger node changes', changes);\n                    }\n                    triggerNodeChanges?.(changes);\n                }\n            },\n            updateNodePositions: (nodeDragItems, dragging = false)=>{\n                const parentExpandChildren = [];\n                const changes = [];\n                const { nodeLookup, triggerNodeChanges } = get();\n                for (const [id, dragItem] of nodeDragItems){\n                    // we are using the nodelookup to be sure to use the current expandParent and parentId value\n                    const node = nodeLookup.get(id);\n                    const expandParent = !!(node?.expandParent && node?.parentId && dragItem?.position);\n                    const change = {\n                        id,\n                        type: 'position',\n                        position: expandParent ? {\n                            x: Math.max(0, dragItem.position.x),\n                            y: Math.max(0, dragItem.position.y)\n                        } : dragItem.position,\n                        dragging\n                    };\n                    if (expandParent && node.parentId) {\n                        parentExpandChildren.push({\n                            id,\n                            parentId: node.parentId,\n                            rect: {\n                                ...dragItem.internals.positionAbsolute,\n                                width: dragItem.measured.width ?? 0,\n                                height: dragItem.measured.height ?? 0\n                            }\n                        });\n                    }\n                    changes.push(change);\n                }\n                if (parentExpandChildren.length > 0) {\n                    const { parentLookup, nodeOrigin } = get();\n                    const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n                    changes.push(...parentExpandChanges);\n                }\n                triggerNodeChanges(changes);\n            },\n            triggerNodeChanges: (changes)=>{\n                const { onNodesChange, setNodes, nodes, hasDefaultNodes, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultNodes) {\n                        const updatedNodes = applyNodeChanges(changes, nodes);\n                        setNodes(updatedNodes);\n                    }\n                    if (debug) {\n                        console.log('React Flow: trigger node changes', changes);\n                    }\n                    onNodesChange?.(changes);\n                }\n            },\n            triggerEdgeChanges: (changes)=>{\n                const { onEdgesChange, setEdges, edges, hasDefaultEdges, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultEdges) {\n                        const updatedEdges = applyEdgeChanges(changes, edges);\n                        setEdges(updatedEdges);\n                    }\n                    if (debug) {\n                        console.log('React Flow: trigger edge changes', changes);\n                    }\n                    onEdgesChange?.(changes);\n                }\n            },\n            addSelectedNodes: (selectedNodeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const nodeChanges = selectedNodeIds.map((nodeId)=>createSelectionChange(nodeId, true));\n                    triggerNodeChanges(nodeChanges);\n                    return;\n                }\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set([\n                    ...selectedNodeIds\n                ]), true));\n                triggerEdgeChanges(getSelectionChanges(edgeLookup));\n            },\n            addSelectedEdges: (selectedEdgeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const changedEdges = selectedEdgeIds.map((edgeId)=>createSelectionChange(edgeId, true));\n                    triggerEdgeChanges(changedEdges);\n                    return;\n                }\n                triggerEdgeChanges(getSelectionChanges(edgeLookup, new Set([\n                    ...selectedEdgeIds\n                ])));\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set(), true));\n            },\n            unselectNodesAndEdges: ({ nodes, edges } = {})=>{\n                const { edges: storeEdges, nodes: storeNodes, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                const nodesToUnselect = nodes ? nodes : storeNodes;\n                const edgesToUnselect = edges ? edges : storeEdges;\n                const nodeChanges = nodesToUnselect.map((n)=>{\n                    const internalNode = nodeLookup.get(n.id);\n                    if (internalNode) {\n                        /*\n                     * we need to unselect the internal node that was selected previously before we\n                     * send the change to the user to prevent it to be selected while dragging the new node\n                     */ internalNode.selected = false;\n                    }\n                    return createSelectionChange(n.id, false);\n                });\n                const edgeChanges = edgesToUnselect.map((edge)=>createSelectionChange(edge.id, false));\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setMinZoom: (minZoom)=>{\n                const { panZoom, maxZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    minZoom\n                });\n            },\n            setMaxZoom: (maxZoom)=>{\n                const { panZoom, minZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    maxZoom\n                });\n            },\n            setTranslateExtent: (translateExtent)=>{\n                get().panZoom?.setTranslateExtent(translateExtent);\n                set({\n                    translateExtent\n                });\n            },\n            setPaneClickDistance: (clickDistance)=>{\n                get().panZoom?.setClickDistance(clickDistance);\n            },\n            resetSelectedElements: ()=>{\n                const { edges, nodes, triggerNodeChanges, triggerEdgeChanges, elementsSelectable } = get();\n                if (!elementsSelectable) {\n                    return;\n                }\n                const nodeChanges = nodes.reduce((res, node)=>node.selected ? [\n                        ...res,\n                        createSelectionChange(node.id, false)\n                    ] : res, []);\n                const edgeChanges = edges.reduce((res, edge)=>edge.selected ? [\n                        ...res,\n                        createSelectionChange(edge.id, false)\n                    ] : res, []);\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setNodeExtent: (nextNodeExtent)=>{\n                const { nodes, nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, nodeExtent } = get();\n                if (nextNodeExtent[0][0] === nodeExtent[0][0] && nextNodeExtent[0][1] === nodeExtent[0][1] && nextNodeExtent[1][0] === nodeExtent[1][0] && nextNodeExtent[1][1] === nodeExtent[1][1]) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent: nextNodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: false\n                });\n                set({\n                    nodeExtent: nextNodeExtent\n                });\n            },\n            panBy: (delta)=>{\n                const { transform, width, height, panZoom, translateExtent } = get();\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.panBy)({\n                    delta,\n                    panZoom,\n                    transform,\n                    translateExtent,\n                    width,\n                    height\n                });\n            },\n            cancelConnection: ()=>{\n                set({\n                    connection: {\n                        ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n                    }\n                });\n            },\n            updateConnection: (connection)=>{\n                set({\n                    connection\n                });\n            },\n            reset: ()=>set({\n                    ...getInitialState()\n                })\n        };\n    }, Object.is);\n/**\n * The `<ReactFlowProvider />` component is a [context provider](https://react.dev/learn/passing-data-deeply-with-context#)\n * that makes it possible to access a flow's internal state outside of the\n * [`<ReactFlow />`](/api-reference/react-flow) component. Many of the hooks we\n * provide rely on this component to work.\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow, ReactFlowProvider, useNodes } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlowProvider>\n *      <ReactFlow nodes={...} edges={...} />\n *      <Sidebar />\n *    </ReactFlowProvider>\n *  );\n *}\n *\n *function Sidebar() {\n *  // This hook will only work if the component it's used in is a child of a\n *  // <ReactFlowProvider />.\n *  const nodes = useNodes()\n *\n *  return <aside>do something with nodes</aside>;\n *}\n *```\n *\n * @remarks If you're using a router and want your flow's state to persist across routes,\n * it's vital that you place the `<ReactFlowProvider />` component _outside_ of\n * your router. If you have multiple flows on the same page you will need to use a separate\n * `<ReactFlowProvider />` for each flow.\n */ function ReactFlowProvider({ initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, initialMinZoom: minZoom, initialMaxZoom: maxZoom, initialFitViewOptions: fitViewOptions, fitView, nodeOrigin, nodeExtent, children }) {\n    const [store] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"ReactFlowProvider.useState\": ()=>createStore({\n                nodes,\n                edges,\n                defaultNodes,\n                defaultEdges,\n                width,\n                height,\n                fitView,\n                minZoom,\n                maxZoom,\n                fitViewOptions,\n                nodeOrigin,\n                nodeExtent\n            })\n    }[\"ReactFlowProvider.useState\"]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider$1, {\n        value: store,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchProvider, {\n            children: children\n        })\n    });\n}\nfunction Wrapper({ children, nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent }) {\n    const isWrapped = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (isWrapped) {\n        /*\n         * we need to wrap it with a fragment because it's not allowed for children to be a ReactNode\n         * https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051\n         */ return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: children\n        });\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ReactFlowProvider, {\n        initialNodes: nodes,\n        initialEdges: edges,\n        defaultNodes: defaultNodes,\n        defaultEdges: defaultEdges,\n        initialWidth: width,\n        initialHeight: height,\n        fitView: fitView,\n        initialFitViewOptions: fitViewOptions,\n        initialMinZoom: minZoom,\n        initialMaxZoom: maxZoom,\n        nodeOrigin: nodeOrigin,\n        nodeExtent: nodeExtent,\n        children: children\n    });\n}\nconst wrapperStyle = {\n    width: '100%',\n    height: '100%',\n    overflow: 'hidden',\n    position: 'relative',\n    zIndex: 0\n};\nfunction ReactFlow({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes, edgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onBeforeDelete, connectionMode, connectionLineType = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = 'Backspace', selectionKeyCode = 'Shift', selectionOnDrag = false, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panActivationKeyCode = 'Space', multiSelectionKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? 'Meta' : 'Control', zoomActivationKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? 'Meta' : 'Control', snapToGrid, snapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag, nodesDraggable, nodesConnectable, nodesFocusable, nodeOrigin = defaultNodeOrigin, edgesFocusable, edgesReconnectable, elementsSelectable = true, defaultViewport: defaultViewport$1 = defaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = '#b1b1b7', zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance = 0, nodeClickDistance = 0, children, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius = 10, onNodesChange, onEdgesChange, noDragClassName = 'nodrag', noWheelClassName = 'nowheel', noPanClassName = 'nopan', fitView, fitViewOptions, connectOnClick, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect, elevateEdgesOnSelect, disableKeyboardA11y = false, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, connectionRadius, isValidConnection, onError, style, id, nodeDragThreshold, viewport, onViewportChange, width, height, colorMode = 'light', debug, onScroll, ...rest }, ref) {\n    const rfId = id || '1';\n    const colorModeClassName = useColorModeClass(colorMode);\n    // Undo scroll events, preventing viewport from shifting when nodes outside of it are focused\n    const wrapperOnScroll = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ReactFlow.useCallback[wrapperOnScroll]\": (e)=>{\n            e.currentTarget.scrollTo({\n                top: 0,\n                left: 0,\n                behavior: 'instant'\n            });\n            onScroll?.(e);\n        }\n    }[\"ReactFlow.useCallback[wrapperOnScroll]\"], [\n        onScroll\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-testid\": \"rf__wrapper\",\n        ...rest,\n        onScroll: wrapperOnScroll,\n        style: {\n            ...style,\n            ...wrapperStyle\n        },\n        ref: ref,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow',\n            className,\n            colorModeClassName\n        ]),\n        id: id,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Wrapper, {\n            nodes: nodes,\n            edges: edges,\n            width: width,\n            height: height,\n            fitView: fitView,\n            fitViewOptions: fitViewOptions,\n            minZoom: minZoom,\n            maxZoom: maxZoom,\n            nodeOrigin: nodeOrigin,\n            nodeExtent: nodeExtent,\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(GraphView, {\n                    onInit: onInit,\n                    onNodeClick: onNodeClick,\n                    onEdgeClick: onEdgeClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    nodeTypes: nodeTypes,\n                    edgeTypes: edgeTypes,\n                    connectionLineType: connectionLineType,\n                    connectionLineStyle: connectionLineStyle,\n                    connectionLineComponent: connectionLineComponent,\n                    connectionLineContainerStyle: connectionLineContainerStyle,\n                    selectionKeyCode: selectionKeyCode,\n                    selectionOnDrag: selectionOnDrag,\n                    selectionMode: selectionMode,\n                    deleteKeyCode: deleteKeyCode,\n                    multiSelectionKeyCode: multiSelectionKeyCode,\n                    panActivationKeyCode: panActivationKeyCode,\n                    zoomActivationKeyCode: zoomActivationKeyCode,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    defaultViewport: defaultViewport$1,\n                    translateExtent: translateExtent,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    preventScrolling: preventScrolling,\n                    zoomOnScroll: zoomOnScroll,\n                    zoomOnPinch: zoomOnPinch,\n                    zoomOnDoubleClick: zoomOnDoubleClick,\n                    panOnScroll: panOnScroll,\n                    panOnScrollSpeed: panOnScrollSpeed,\n                    panOnScrollMode: panOnScrollMode,\n                    panOnDrag: panOnDrag,\n                    onPaneClick: onPaneClick,\n                    onPaneMouseEnter: onPaneMouseEnter,\n                    onPaneMouseMove: onPaneMouseMove,\n                    onPaneMouseLeave: onPaneMouseLeave,\n                    onPaneScroll: onPaneScroll,\n                    onPaneContextMenu: onPaneContextMenu,\n                    paneClickDistance: paneClickDistance,\n                    nodeClickDistance: nodeClickDistance,\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    onSelectionStart: onSelectionStart,\n                    onSelectionEnd: onSelectionEnd,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noDragClassName: noDragClassName,\n                    noWheelClassName: noWheelClassName,\n                    noPanClassName: noPanClassName,\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    viewport: viewport,\n                    onViewportChange: onViewportChange\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StoreUpdater, {\n                    nodes: nodes,\n                    edges: edges,\n                    defaultNodes: defaultNodes,\n                    defaultEdges: defaultEdges,\n                    onConnect: onConnect,\n                    onConnectStart: onConnectStart,\n                    onConnectEnd: onConnectEnd,\n                    onClickConnectStart: onClickConnectStart,\n                    onClickConnectEnd: onClickConnectEnd,\n                    nodesDraggable: nodesDraggable,\n                    nodesConnectable: nodesConnectable,\n                    nodesFocusable: nodesFocusable,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    elevateNodesOnSelect: elevateNodesOnSelect,\n                    elevateEdgesOnSelect: elevateEdgesOnSelect,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    nodeExtent: nodeExtent,\n                    onNodesChange: onNodesChange,\n                    onEdgesChange: onEdgesChange,\n                    snapToGrid: snapToGrid,\n                    snapGrid: snapGrid,\n                    connectionMode: connectionMode,\n                    translateExtent: translateExtent,\n                    connectOnClick: connectOnClick,\n                    defaultEdgeOptions: defaultEdgeOptions,\n                    fitView: fitView,\n                    fitViewOptions: fitViewOptions,\n                    onNodesDelete: onNodesDelete,\n                    onEdgesDelete: onEdgesDelete,\n                    onDelete: onDelete,\n                    onNodeDragStart: onNodeDragStart,\n                    onNodeDrag: onNodeDrag,\n                    onNodeDragStop: onNodeDragStop,\n                    onSelectionDrag: onSelectionDrag,\n                    onSelectionDragStart: onSelectionDragStart,\n                    onSelectionDragStop: onSelectionDragStop,\n                    onMove: onMove,\n                    onMoveStart: onMoveStart,\n                    onMoveEnd: onMoveEnd,\n                    noPanClassName: noPanClassName,\n                    nodeOrigin: nodeOrigin,\n                    rfId: rfId,\n                    autoPanOnConnect: autoPanOnConnect,\n                    autoPanOnNodeDrag: autoPanOnNodeDrag,\n                    autoPanSpeed: autoPanSpeed,\n                    onError: onError,\n                    connectionRadius: connectionRadius,\n                    isValidConnection: isValidConnection,\n                    selectNodesOnDrag: selectNodesOnDrag,\n                    nodeDragThreshold: nodeDragThreshold,\n                    onBeforeDelete: onBeforeDelete,\n                    paneClickDistance: paneClickDistance,\n                    debug: debug\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListener, {\n                    onSelectionChange: onSelectionChange\n                }),\n                children,\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Attribution, {\n                    proOptions: proOptions,\n                    position: attributionPosition\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(A11yDescriptions, {\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\n/**\n * The `<ReactFlow />` component is the heart of your React Flow application.\n * It renders your nodes and edges and handles user interaction\n *\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (<ReactFlow\n *    nodes={...}\n *    edges={...}\n *    onNodesChange={...}\n *    ...\n *  />);\n *}\n *```\n */ var index = fixedForwardRef(ReactFlow);\nconst selector$6 = (s)=>s.domNode?.querySelector('.react-flow__edgelabel-renderer');\n/**\n * Edges are SVG-based. If you want to render more complex labels you can use the\n * `<EdgeLabelRenderer />` component to access a div based renderer. This component\n * is a portal that renders the label in a `<div />` that is positioned on top of\n * the edges. You can see an example usage of the component in the\n * [edge label renderer example](/examples/edges/edge-label-renderer).\n * @public\n *\n * @example\n * ```jsx\n * import React from 'react';\n * import { getBezierPath, EdgeLabelRenderer, BaseEdge } from '@xyflow/react';\n *\n * export function CustomEdge({ id, data, ...props }) {\n *   const [edgePath, labelX, labelY] = getBezierPath(props);\n *\n *   return (\n *     <>\n *       <BaseEdge id={id} path={edgePath} />\n *       <EdgeLabelRenderer>\n *         <div\n *           style={{\n *             position: 'absolute',\n *             transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n *             background: '#ffcc00',\n *             padding: 10,\n *         }}\n *           className=\"nodrag nopan\"\n *         >\n *          {data.label}\n *         </div>\n *       </EdgeLabelRenderer>\n *     </>\n *   );\n * };\n * ```\n *\n * @remarks The `<EdgeLabelRenderer />` has no pointer events by default. If you want to\n * add mouse interactions you need to set the style `pointerEvents: all` and add\n * the `nopan` class on the label or the element you want to interact with.\n */ function EdgeLabelRenderer({ children }) {\n    const edgeLabelRenderer = useStore(selector$6);\n    if (!edgeLabelRenderer) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, edgeLabelRenderer);\n}\nconst selector$5 = (s)=>s.domNode?.querySelector('.react-flow__viewport-portal');\n/**\n * The `<ViewportPortal />` component can be used to add components to the same viewport\n * of the flow where nodes and edges are rendered. This is useful when you want to render\n * your own components that are adhere to the same coordinate system as the nodes & edges\n * and are also affected by zooming and panning\n * @public\n * @example\n *\n * ```jsx\n *import React from 'react';\n *import { ViewportPortal } from '@xyflow/react';\n *\n *export default function () {\n *  return (\n *    <ViewportPortal>\n *      <div\n *        style={{ transform: 'translate(100px, 100px)', position: 'absolute' }}\n *      >\n *        This div is positioned at [100, 100] on the flow.\n *      </div>\n *    </ViewportPortal>\n *  );\n *}\n *```\n */ function ViewportPortal({ children }) {\n    const viewPortalDiv = useStore(selector$5);\n    if (!viewPortalDiv) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, viewPortalDiv);\n}\n/**\n * When you programmatically add or remove handles to a node or update a node's\n * handle position, you need to let React Flow know about it using this hook. This\n * will update the internal dimensions of the node and properly reposition handles\n * on the canvas if necessary.\n *\n * @public\n * @returns Use this function to tell React Flow to update the internal state of one or more nodes\n * that you have changed programmatically.\n *\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { Handle, useUpdateNodeInternals } from '@xyflow/react';\n *\n *export default function RandomHandleNode({ id }) {\n *  const updateNodeInternals = useUpdateNodeInternals();\n *  const [handleCount, setHandleCount] = useState(0);\n *  const randomizeHandleCount = useCallback(() => {\n *   setHandleCount(Math.floor(Math.random() * 10));\n *    updateNodeInternals(id);\n *  }, [id, updateNodeInternals]);\n *\n *  return (\n *    <>\n *      {Array.from({ length: handleCount }).map((_, index) => (\n *        <Handle\n *          key={index}\n *          type=\"target\"\n *          position=\"left\"\n *          id={`handle-${index}`}\n *        />\n *      ))}\n *\n *      <div>\n *        <button onClick={randomizeHandleCount}>Randomize handle count</button>\n *        <p>There are {handleCount} handles on this node.</p>\n *      </div>\n *    </>\n *  );\n *}\n *```\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useUpdateNodeInternals() {\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useUpdateNodeInternals.useCallback\": (id)=>{\n            const { domNode, updateNodeInternals } = store.getState();\n            const updateIds = Array.isArray(id) ? id : [\n                id\n            ];\n            const updates = new Map();\n            updateIds.forEach({\n                \"useUpdateNodeInternals.useCallback\": (updateId)=>{\n                    const nodeElement = domNode?.querySelector(`.react-flow__node[data-id=\"${updateId}\"]`);\n                    if (nodeElement) {\n                        updates.set(updateId, {\n                            id: updateId,\n                            nodeElement,\n                            force: true\n                        });\n                    }\n                }\n            }[\"useUpdateNodeInternals.useCallback\"]);\n            requestAnimationFrame({\n                \"useUpdateNodeInternals.useCallback\": ()=>updateNodeInternals(updates, {\n                        triggerFitView: false\n                    })\n            }[\"useUpdateNodeInternals.useCallback\"]);\n        }\n    }[\"useUpdateNodeInternals.useCallback\"], []);\n}\nconst nodesSelector = (state)=>state.nodes;\n/**\n * This hook returns an array of the current nodes. Components that use this hook\n * will re-render **whenever any node changes**, including when a node is selected\n * or moved.\n *\n * @public\n * @returns An array of all nodes currently in the flow.\n *\n * @example\n * ```jsx\n *import { useNodes } from '@xyflow/react';\n *\n *export default function() {\n *  const nodes = useNodes();\n *\n *  return <div>There are currently {nodes.length} nodes!</div>;\n *}\n *```\n */ function useNodes() {\n    const nodes = useStore(nodesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodes;\n}\nconst edgesSelector = (state)=>state.edges;\n/**\n * This hook returns an array of the current edges. Components that use this hook\n * will re-render **whenever any edge changes**.\n *\n * @public\n * @returns An array of all edges currently in the flow.\n *\n * @example\n * ```tsx\n *import { useEdges } from '@xyflow/react';\n *\n *export default function () {\n *  const edges = useEdges();\n *\n *  return <div>There are currently {edges.length} edges!</div>;\n *}\n *```\n */ function useEdges() {\n    const edges = useStore(edgesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edges;\n}\nconst viewportSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2]\n    });\n/**\n * The `useViewport` hook is a convenient way to read the current state of the\n * {@link Viewport} in a component. Components that use this hook\n * will re-render **whenever the viewport changes**.\n *\n * @public\n * @returns The current viewport.\n *\n * @example\n *\n *```jsx\n *import { useViewport } from '@xyflow/react';\n *\n *export default function ViewportDisplay() {\n *  const { x, y, zoom } = useViewport();\n *\n *  return (\n *    <div>\n *      <p>\n *        The viewport is currently at ({x}, {y}) and zoomed to {zoom}.\n *      </p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useViewport() {\n    const viewport = useStore(viewportSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return viewport;\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @returns\n * - `nodes`: The current array of nodes. You might pass this directly to the `nodes` prop of your\n * `<ReactFlow />` component, or you may want to manipulate it first to perform some layouting,\n * for example.\n * - `setNodes`: A function that you can use to update the nodes. You can pass it a new array of\n * nodes or a callback that receives the current array of nodes and returns a new array of nodes.\n * This is the same as the second element of the tuple returned by React's `useState` hook.\n * - `onNodesChange`: A handy callback that can take an array of `NodeChanges` and update the nodes\n * state accordingly. You'll typically pass this directly to the `onNodesChange` prop of your\n * `<ReactFlow />` component.\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useNodesState(initialNodes) {\n    const [nodes, setNodes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialNodes);\n    const onNodesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useNodesState.useCallback[onNodesChange]\": (changes)=>setNodes({\n                \"useNodesState.useCallback[onNodesChange]\": (nds)=>applyNodeChanges(changes, nds)\n            }[\"useNodesState.useCallback[onNodesChange]\"])\n    }[\"useNodesState.useCallback[onNodesChange]\"], []);\n    return [\n        nodes,\n        setNodes,\n        onNodesChange\n    ];\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @returns\n * - `edges`: The current array of edges. You might pass this directly to the `edges` prop of your\n * `<ReactFlow />` component, or you may want to manipulate it first to perform some layouting,\n * for example.\n *\n * - `setEdges`: A function that you can use to update the edges. You can pass it a new array of\n * edges or a callback that receives the current array of edges and returns a new array of edges.\n * This is the same as the second element of the tuple returned by React's `useState` hook.\n *\n * - `onEdgesChange`: A handy callback that can take an array of `EdgeChanges` and update the edges\n * state accordingly. You'll typically pass this directly to the `onEdgesChange` prop of your\n * `<ReactFlow />` component.\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useEdgesState(initialEdges) {\n    const [edges, setEdges] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialEdges);\n    const onEdgesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useEdgesState.useCallback[onEdgesChange]\": (changes)=>setEdges({\n                \"useEdgesState.useCallback[onEdgesChange]\": (eds)=>applyEdgeChanges(changes, eds)\n            }[\"useEdgesState.useCallback[onEdgesChange]\"])\n    }[\"useEdgesState.useCallback[onEdgesChange]\"], []);\n    return [\n        edges,\n        setEdges,\n        onEdgesChange\n    ];\n}\n/**\n * The `useOnViewportChange` hook lets you listen for changes to the viewport such\n * as panning and zooming. You can provide a callback for each phase of a viewport\n * change: `onStart`, `onChange`, and `onEnd`.\n *\n * @public\n * @example\n * ```jsx\n *import { useCallback } from 'react';\n *import { useOnViewportChange } from '@xyflow/react';\n *\n *function ViewportChangeLogger() {\n *  useOnViewportChange({\n *    onStart: (viewport: Viewport) => console.log('start', viewport),\n *    onChange: (viewport: Viewport) => console.log('change', viewport),\n *    onEnd: (viewport: Viewport) => console.log('end', viewport),\n *  });\n *\n *  return null;\n *}\n *```\n */ function useOnViewportChange({ onStart, onChange, onEnd }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChangeStart: onStart\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onStart\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChange: onChange\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChangeEnd: onEnd\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onEnd\n    ]);\n}\n/**\n * This hook lets you listen for changes to both node and edge selection. As the\n *name implies, the callback you provide will be called whenever the selection of\n *_either_ nodes or edges changes.\n *\n * @public\n * @example\n * ```jsx\n *import { useState } from 'react';\n *import { ReactFlow, useOnSelectionChange } from '@xyflow/react';\n *\n *function SelectionDisplay() {\n *  const [selectedNodes, setSelectedNodes] = useState([]);\n *  const [selectedEdges, setSelectedEdges] = useState([]);\n *\n *  // the passed handler has to be memoized, otherwise the hook will not work correctly\n *  const onChange = useCallback(({ nodes, edges }) => {\n *    setSelectedNodes(nodes.map((node) => node.id));\n *    setSelectedEdges(edges.map((edge) => edge.id));\n *  }, []);\n *\n *  useOnSelectionChange({\n *    onChange,\n *  });\n *\n *  return (\n *    <div>\n *      <p>Selected nodes: {selectedNodes.join(', ')}</p>\n *      <p>Selected edges: {selectedEdges.join(', ')}</p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks You need to memoize the passed `onChange` handler, otherwise the hook will not work correctly.\n */ function useOnSelectionChange({ onChange }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnSelectionChange.useEffect\": ()=>{\n            const nextOnSelectionChangeHandlers = [\n                ...store.getState().onSelectionChangeHandlers,\n                onChange\n            ];\n            store.setState({\n                onSelectionChangeHandlers: nextOnSelectionChangeHandlers\n            });\n            return ({\n                \"useOnSelectionChange.useEffect\": ()=>{\n                    const nextHandlers = store.getState().onSelectionChangeHandlers.filter({\n                        \"useOnSelectionChange.useEffect.nextHandlers\": (fn)=>fn !== onChange\n                    }[\"useOnSelectionChange.useEffect.nextHandlers\"]);\n                    store.setState({\n                        onSelectionChangeHandlers: nextHandlers\n                    });\n                }\n            })[\"useOnSelectionChange.useEffect\"];\n        }\n    }[\"useOnSelectionChange.useEffect\"], [\n        onChange\n    ]);\n}\nconst selector$4 = (options)=>(s)=>{\n        if (!options.includeHiddenNodes) {\n            return s.nodesInitialized;\n        }\n        if (s.nodeLookup.size === 0) {\n            return false;\n        }\n        for (const [, { internals }] of s.nodeLookup){\n            if (internals.handleBounds === undefined || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(internals.userNode)) {\n                return false;\n            }\n        }\n        return true;\n    };\n/**\n * This hook tells you whether all the nodes in a flow have been measured and given\n *a width and height. When you add a node to the flow, this hook will return\n *`false` and then `true` again once the node has been measured.\n *\n * @public\n * @returns Whether or not the nodes have been initialized by the `<ReactFlow />` component and\n * given a width and height.\n *\n * @example\n * ```jsx\n *import { useReactFlow, useNodesInitialized } from '@xyflow/react';\n *import { useEffect, useState } from 'react';\n *\n *const options = {\n *  includeHiddenNodes: false,\n *};\n *\n *export default function useLayout() {\n *  const { getNodes } = useReactFlow();\n *  const nodesInitialized = useNodesInitialized(options);\n *  const [layoutedNodes, setLayoutedNodes] = useState(getNodes());\n *\n *  useEffect(() => {\n *    if (nodesInitialized) {\n *      setLayoutedNodes(yourLayoutingFunction(getNodes()));\n *    }\n *  }, [nodesInitialized]);\n *\n *  return layoutedNodes;\n *}\n *```\n */ function useNodesInitialized(options = {\n    includeHiddenNodes: false\n}) {\n    const initialized = useStore(selector$4(options));\n    return initialized;\n}\n/**\n * Hook to check if a <Handle /> is connected to another <Handle /> and get the connections.\n *\n * @public\n * @deprecated Use `useNodeConnections` instead.\n * @returns An array with handle connections.\n */ function useHandleConnections({ type, id, nodeId, onConnect, onDisconnect }) {\n    console.warn('[DEPRECATED] `useHandleConnections` is deprecated. Instead use `useNodeConnections` https://reactflow.dev/api-reference/hooks/useNodeConnections');\n    const _nodeId = useNodeId();\n    const currentNodeId = nodeId ?? _nodeId;\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore({\n        \"useHandleConnections.useStore[connections]\": (state)=>state.connectionLookup.get(`${currentNodeId}-${type}${id ? `-${id}` : ''}`)\n    }[\"useHandleConnections.useStore[connections]\"], _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useHandleConnections.useEffect\": ()=>{\n            // @todo dicuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n            if (prevConnections.current && prevConnections.current !== connections) {\n                const _connections = connections ?? new Map();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n            }\n            prevConnections.current = connections ?? new Map();\n        }\n    }[\"useHandleConnections.useEffect\"], [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useHandleConnections.useMemo\": ()=>Array.from(connections?.values() ?? [])\n    }[\"useHandleConnections.useMemo\"], [\n        connections\n    ]);\n}\nconst error014 = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error014']();\n/**\n * This hook returns an array of connections on a specific node, handle type ('source', 'target') or handle ID.\n *\n * @public\n * @returns An array with connections.\n *\n * @example\n * ```jsx\n *import { useNodeConnections } from '@xyflow/react';\n *\n *export default function () {\n *  const connections = useNodeConnections({\n *    handleType: 'target',\n *    handleId: 'my-handle',\n *  });\n *\n *  return (\n *    <div>There are currently {connections.length} incoming connections!</div>\n *  );\n *}\n *```\n */ function useNodeConnections({ id, handleType, handleId, onConnect, onDisconnect } = {}) {\n    const nodeId = useNodeId();\n    const currentNodeId = id ?? nodeId;\n    if (!currentNodeId) {\n        throw new Error(error014);\n    }\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore({\n        \"useNodeConnections.useStore[connections]\": (state)=>state.connectionLookup.get(`${currentNodeId}${handleType ? handleId ? `-${handleType}-${handleId}` : `-${handleType}` : ''}`)\n    }[\"useNodeConnections.useStore[connections]\"], _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeConnections.useEffect\": ()=>{\n            // @todo discuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n            if (prevConnections.current && prevConnections.current !== connections) {\n                const _connections = connections ?? new Map();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n            }\n            prevConnections.current = connections ?? new Map();\n        }\n    }[\"useNodeConnections.useEffect\"], [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useNodeConnections.useMemo\": ()=>Array.from(connections?.values() ?? [])\n    }[\"useNodeConnections.useMemo\"], [\n        connections\n    ]);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodesData(nodeIds) {\n    const nodesData = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useNodesData.useStore[nodesData]\": (s)=>{\n            const data = [];\n            const isArrayOfIds = Array.isArray(nodeIds);\n            const _nodeIds = isArrayOfIds ? nodeIds : [\n                nodeIds\n            ];\n            for (const nodeId of _nodeIds){\n                const node = s.nodeLookup.get(nodeId);\n                if (node) {\n                    data.push({\n                        id: node.id,\n                        type: node.type,\n                        data: node.data\n                    });\n                }\n            }\n            return isArrayOfIds ? data : data[0] ?? null;\n        }\n    }[\"useNodesData.useStore[nodesData]\"], [\n        nodeIds\n    ]), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.shallowNodeData);\n    return nodesData;\n}\n/**\n * This hook returns the internal representation of a specific node.\n * Components that use this hook will re-render **whenever the node changes**,\n * including when a node is selected or moved.\n *\n * @public\n * @param id - The ID of a node you want to observe.\n * @returns The `InternalNode` object for the node with the given ID.\n *\n * @example\n * ```tsx\n *import { useInternalNode } from '@xyflow/react';\n *\n *export default function () {\n *  const internalNode = useInternalNode('node-1');\n *  const absolutePosition = internalNode.internals.positionAbsolute;\n *\n *  return (\n *    <div>\n *      The absolute position of the node is at:\n *      <p>x: {absolutePosition.x}</p>\n *      <p>y: {absolutePosition.y}</p>\n *    </div>\n *  );\n *}\n *```\n */ function useInternalNode(id) {\n    const node = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useInternalNode.useStore[node]\": (s)=>s.nodeLookup.get(id)\n    }[\"useInternalNode.useStore[node]\"], [\n        id\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return node;\n}\nfunction LinePattern({ dimensions, lineWidth, variant, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        strokeWidth: lineWidth,\n        d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__background-pattern',\n            variant,\n            className\n        ])\n    });\n}\nfunction DotPattern({ radius, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        cx: radius,\n        cy: radius,\n        r: radius,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__background-pattern',\n            'dots',\n            className\n        ])\n    });\n}\n/**\n * The three variants are exported as an enum for convenience. You can either import\n * the enum and use it like `BackgroundVariant.Lines` or you can use the raw string\n * value directly.\n * @public\n */ var BackgroundVariant;\n(function(BackgroundVariant) {\n    BackgroundVariant[\"Lines\"] = \"lines\";\n    BackgroundVariant[\"Dots\"] = \"dots\";\n    BackgroundVariant[\"Cross\"] = \"cross\";\n})(BackgroundVariant || (BackgroundVariant = {}));\nconst defaultSize = {\n    [BackgroundVariant.Dots]: 1,\n    [BackgroundVariant.Lines]: 1,\n    [BackgroundVariant.Cross]: 6\n};\nconst selector$3 = (s)=>({\n        transform: s.transform,\n        patternId: `pattern-${s.rfId}`\n    });\nfunction BackgroundComponent({ id, variant = BackgroundVariant.Dots, // only used for dots and cross\ngap = 20, // only used for lines and cross\nsize, lineWidth = 1, offset = 0, color, bgColor, style, className, patternClassName }) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { transform, patternId } = useStore(selector$3, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const patternSize = size || defaultSize[variant];\n    const isDots = variant === BackgroundVariant.Dots;\n    const isCross = variant === BackgroundVariant.Cross;\n    const gapXY = Array.isArray(gap) ? gap : [\n        gap,\n        gap\n    ];\n    const scaledGap = [\n        gapXY[0] * transform[2] || 1,\n        gapXY[1] * transform[2] || 1\n    ];\n    const scaledSize = patternSize * transform[2];\n    const offsetXY = Array.isArray(offset) ? offset : [\n        offset,\n        offset\n    ];\n    const patternDimensions = isCross ? [\n        scaledSize,\n        scaledSize\n    ] : scaledGap;\n    const scaledOffset = [\n        offsetXY[0] * transform[2] || 1 + patternDimensions[0] / 2,\n        offsetXY[1] * transform[2] || 1 + patternDimensions[1] / 2\n    ];\n    const _patternId = `${patternId}${id ? id : ''}`;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__background',\n            className\n        ]),\n        style: {\n            ...style,\n            ...containerStyle,\n            '--xy-background-color-props': bgColor,\n            '--xy-background-pattern-color-props': color\n        },\n        ref: ref,\n        \"data-testid\": \"rf__background\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pattern\", {\n                id: _patternId,\n                x: transform[0] % scaledGap[0],\n                y: transform[1] % scaledGap[1],\n                width: scaledGap[0],\n                height: scaledGap[1],\n                patternUnits: \"userSpaceOnUse\",\n                patternTransform: `translate(-${scaledOffset[0]},-${scaledOffset[1]})`,\n                children: isDots ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DotPattern, {\n                    radius: scaledSize / 2,\n                    className: patternClassName\n                }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LinePattern, {\n                    dimensions: patternDimensions,\n                    lineWidth: lineWidth,\n                    variant: variant,\n                    className: patternClassName\n                })\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                x: \"0\",\n                y: \"0\",\n                width: \"100%\",\n                height: \"100%\",\n                fill: `url(#${_patternId})`\n            })\n        ]\n    });\n}\nBackgroundComponent.displayName = 'Background';\n/**\n * The `<Background />` component makes it convenient to render different types of backgrounds common in node-based UIs. It comes with three variants: lines, dots and cross.\n *\n * @example\n *\n * A simple example of how to use the Background component.\n *\n * ```tsx\n * import { useState } from 'react';\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background color=\"#ccc\" variant={BackgroundVariant.Dots} />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @example\n *\n * In this example you can see how to combine multiple backgrounds\n *\n * ```tsx\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n * import '@xyflow/react/dist/style.css';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background\n *         id=\"1\"\n *         gap={10}\n *         color=\"#f1f1f1\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *       <Background\n *         id=\"2\"\n *         gap={100}\n *         color=\"#ccc\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @remarks\n *\n * When combining multiple <Background /> components it’s important to give each of them a unique id prop!\n *\n */ const Background = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(BackgroundComponent);\nfunction PlusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z\"\n        })\n    });\n}\nfunction MinusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 5\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M0 0h32v4.2H0z\"\n        })\n    });\n}\nfunction FitViewIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 30\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z\"\n        })\n    });\n}\nfunction LockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z\"\n        })\n    });\n}\nfunction UnlockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z\"\n        })\n    });\n}\n/**\n * You can add buttons to the control panel by using the `<ControlButton />` component\n * and pass it as a child to the [`<Controls />`](/api-reference/components/controls) component.\n *\n * @public\n * @example\n *```jsx\n *import { MagicWand } from '@radix-ui/react-icons'\n *import { ReactFlow, Controls, ControlButton } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls>\n *        <ControlButton onClick={() => alert('Something magical just happened. ✨')}>\n *          <MagicWand />\n *        </ControlButton>\n *      </Controls>\n *    </ReactFlow>\n *  )\n *}\n *```\n */ function ControlButton({ children, className, ...rest }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n        type: \"button\",\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__controls-button',\n            className\n        ]),\n        ...rest,\n        children: children\n    });\n}\nconst selector$2 = (s)=>({\n        isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,\n        minZoomReached: s.transform[2] <= s.minZoom,\n        maxZoomReached: s.transform[2] >= s.maxZoom\n    });\nfunction ControlsComponent({ style, showZoom = true, showFitView = true, showInteractive = true, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children, position = 'bottom-left', orientation = 'vertical', 'aria-label': ariaLabel = 'React Flow controls' }) {\n    const store = useStoreApi();\n    const { isInteractive, minZoomReached, maxZoomReached } = useStore(selector$2, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { zoomIn, zoomOut, fitView } = useReactFlow();\n    const onZoomInHandler = ()=>{\n        zoomIn();\n        onZoomIn?.();\n    };\n    const onZoomOutHandler = ()=>{\n        zoomOut();\n        onZoomOut?.();\n    };\n    const onFitViewHandler = ()=>{\n        fitView(fitViewOptions);\n        onFitView?.();\n    };\n    const onToggleInteractivity = ()=>{\n        store.setState({\n            nodesDraggable: !isInteractive,\n            nodesConnectable: !isInteractive,\n            elementsSelectable: !isInteractive\n        });\n        onInteractiveChange?.(!isInteractive);\n    };\n    const orientationClass = orientation === 'horizontal' ? 'horizontal' : 'vertical';\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Panel, {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__controls',\n            orientationClass,\n            className\n        ]),\n        position: position,\n        style: style,\n        \"data-testid\": \"rf__controls\",\n        \"aria-label\": ariaLabel,\n        children: [\n            showZoom && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomInHandler,\n                        className: \"react-flow__controls-zoomin\",\n                        title: \"zoom in\",\n                        \"aria-label\": \"zoom in\",\n                        disabled: maxZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PlusIcon, {})\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomOutHandler,\n                        className: \"react-flow__controls-zoomout\",\n                        title: \"zoom out\",\n                        \"aria-label\": \"zoom out\",\n                        disabled: minZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MinusIcon, {})\n                    })\n                ]\n            }),\n            showFitView && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-fitview\",\n                onClick: onFitViewHandler,\n                title: \"fit view\",\n                \"aria-label\": \"fit view\",\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FitViewIcon, {})\n            }),\n            showInteractive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-interactive\",\n                onClick: onToggleInteractivity,\n                title: \"toggle interactivity\",\n                \"aria-label\": \"toggle interactivity\",\n                children: isInteractive ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnlockIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LockIcon, {})\n            }),\n            children\n        ]\n    });\n}\nControlsComponent.displayName = 'Controls';\n/**\n * The `<Controls />` component renders a small panel that contains convenient\n * buttons to zoom in, zoom out, fit the view, and lock the viewport.\n *\n * @public\n * @example\n *```tsx\n *import { ReactFlow, Controls } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls />\n *    </ReactFlow>\n *  )\n *}\n *```\n *\n * @remarks To extend or customise the controls, you can use the [`<ControlButton />`](/api-reference/components/control-button) component\n *\n */ const Controls = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ControlsComponent);\nfunction MiniMapNodeComponent({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, selected, onClick }) {\n    const { background, backgroundColor } = style || {};\n    const fill = color || background || backgroundColor;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__minimap-node',\n            {\n                selected\n            },\n            className\n        ]),\n        x: x,\n        y: y,\n        rx: borderRadius,\n        ry: borderRadius,\n        width: width,\n        height: height,\n        style: {\n            fill,\n            stroke: strokeColor,\n            strokeWidth\n        },\n        shapeRendering: shapeRendering,\n        onClick: onClick ? (event)=>onClick(event, id) : undefined\n    });\n}\nconst MiniMapNode = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodeComponent);\nconst selectorNodeIds = (s)=>s.nodes.map((node)=>node.id);\nconst getAttrFunction = (func)=>func instanceof Function ? func : ()=>func;\nfunction MiniMapNodes({ nodeStrokeColor, nodeColor, nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent: NodeComponent = MiniMapNode, onClick }) {\n    const nodeIds = useStore(selectorNodeIds, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeColorFunc = getAttrFunction(nodeColor);\n    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n    const nodeClassNameFunc = getAttrFunction(nodeClassName);\n    const shapeRendering =  true ? 'crispEdges' : 0;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: nodeIds.map((nodeId)=>/*\n         * The split of responsibilities between MiniMapNodes and\n         * NodeComponentWrapper may appear weird. However, it’s designed to\n         * minimize the cost of updates when individual nodes change.\n         *\n         * For more details, see a similar commit in `NodeRenderer/index.tsx`.\n         */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponentWrapper, {\n                id: nodeId,\n                nodeColorFunc: nodeColorFunc,\n                nodeStrokeColorFunc: nodeStrokeColorFunc,\n                nodeClassNameFunc: nodeClassNameFunc,\n                nodeBorderRadius: nodeBorderRadius,\n                nodeStrokeWidth: nodeStrokeWidth,\n                NodeComponent: NodeComponent,\n                onClick: onClick,\n                shapeRendering: shapeRendering\n            }, nodeId))\n    });\n}\nfunction NodeComponentWrapperInner({ id, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, shapeRendering, NodeComponent, onClick }) {\n    const { node, x, y, width, height } = useStore({\n        \"NodeComponentWrapperInner.useStore\": (s)=>{\n            const { internals } = s.nodeLookup.get(id);\n            const node = internals.userNode;\n            const { x, y } = internals.positionAbsolute;\n            const { width, height } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n            return {\n                node,\n                x,\n                y,\n                width,\n                height\n            };\n        }\n    }[\"NodeComponentWrapperInner.useStore\"], zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!node || node.hidden || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node)) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        style: node.style,\n        selected: !!node.selected,\n        className: nodeClassNameFunc(node),\n        color: nodeColorFunc(node),\n        borderRadius: nodeBorderRadius,\n        strokeColor: nodeStrokeColorFunc(node),\n        strokeWidth: nodeStrokeWidth,\n        shapeRendering: shapeRendering,\n        onClick: onClick,\n        id: node.id\n    });\n}\nconst NodeComponentWrapper = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeComponentWrapperInner);\nvar MiniMapNodes$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodes);\nconst defaultWidth = 200;\nconst defaultHeight = 150;\nconst filterHidden = (node)=>!node.hidden;\nconst selector$1 = (s)=>{\n    const viewBB = {\n        x: -s.transform[0] / s.transform[2],\n        y: -s.transform[1] / s.transform[2],\n        width: s.width / s.transform[2],\n        height: s.height / s.transform[2]\n    };\n    return {\n        viewBB,\n        boundingRect: s.nodeLookup.size > 0 ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBoundsOfRects)((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n            filter: filterHidden\n        }), viewBB) : viewBB,\n        rfId: s.rfId,\n        panZoom: s.panZoom,\n        translateExtent: s.translateExtent,\n        flowWidth: s.width,\n        flowHeight: s.height\n    };\n};\nconst ARIA_LABEL_KEY = 'react-flow__minimap-desc';\nfunction MiniMapComponent({ style, className, nodeStrokeColor, nodeColor, nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent, bgColor, maskColor, maskStrokeColor, maskStrokeWidth, position = 'bottom-right', onClick, onNodeClick, pannable = false, zoomable = false, ariaLabel = 'React Flow mini map', inversePan, zoomStep = 10, offsetScale = 5 }) {\n    const store = useStoreApi();\n    const svg = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { boundingRect, viewBB, rfId, panZoom, translateExtent, flowWidth, flowHeight } = useStore(selector$1, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const elementWidth = style?.width ?? defaultWidth;\n    const elementHeight = style?.height ?? defaultHeight;\n    const scaledWidth = boundingRect.width / elementWidth;\n    const scaledHeight = boundingRect.height / elementHeight;\n    const viewScale = Math.max(scaledWidth, scaledHeight);\n    const viewWidth = viewScale * elementWidth;\n    const viewHeight = viewScale * elementHeight;\n    const offset = offsetScale * viewScale;\n    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n    const width = viewWidth + offset * 2;\n    const height = viewHeight + offset * 2;\n    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;\n    const viewScaleRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const minimapInstance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    viewScaleRef.current = viewScale;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MiniMapComponent.useEffect\": ()=>{\n            if (svg.current && panZoom) {\n                minimapInstance.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYMinimap)({\n                    domNode: svg.current,\n                    panZoom,\n                    getTransform: {\n                        \"MiniMapComponent.useEffect\": ()=>store.getState().transform\n                    }[\"MiniMapComponent.useEffect\"],\n                    getViewScale: {\n                        \"MiniMapComponent.useEffect\": ()=>viewScaleRef.current\n                    }[\"MiniMapComponent.useEffect\"]\n                });\n                return ({\n                    \"MiniMapComponent.useEffect\": ()=>{\n                        minimapInstance.current?.destroy();\n                    }\n                })[\"MiniMapComponent.useEffect\"];\n            }\n        }\n    }[\"MiniMapComponent.useEffect\"], [\n        panZoom\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MiniMapComponent.useEffect\": ()=>{\n            minimapInstance.current?.update({\n                translateExtent,\n                width: flowWidth,\n                height: flowHeight,\n                inversePan,\n                pannable,\n                zoomStep,\n                zoomable\n            });\n        }\n    }[\"MiniMapComponent.useEffect\"], [\n        pannable,\n        zoomable,\n        inversePan,\n        zoomStep,\n        translateExtent,\n        flowWidth,\n        flowHeight\n    ]);\n    const onSvgClick = onClick ? (event)=>{\n        const [x, y] = minimapInstance.current?.pointer(event) || [\n            0,\n            0\n        ];\n        onClick(event, {\n            x,\n            y\n        });\n    } : undefined;\n    const onSvgNodeClick = onNodeClick ? (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"MiniMapComponent.useCallback\": (event, nodeId)=>{\n            const node = store.getState().nodeLookup.get(nodeId).internals.userNode;\n            onNodeClick(event, node);\n        }\n    }[\"MiniMapComponent.useCallback\"], []) : undefined;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        style: {\n            ...style,\n            '--xy-minimap-background-color-props': typeof bgColor === 'string' ? bgColor : undefined,\n            '--xy-minimap-mask-background-color-props': typeof maskColor === 'string' ? maskColor : undefined,\n            '--xy-minimap-mask-stroke-color-props': typeof maskStrokeColor === 'string' ? maskStrokeColor : undefined,\n            '--xy-minimap-mask-stroke-width-props': typeof maskStrokeWidth === 'number' ? maskStrokeWidth * viewScale : undefined,\n            '--xy-minimap-node-background-color-props': typeof nodeColor === 'string' ? nodeColor : undefined,\n            '--xy-minimap-node-stroke-color-props': typeof nodeStrokeColor === 'string' ? nodeStrokeColor : undefined,\n            '--xy-minimap-node-stroke-width-props': typeof nodeStrokeWidth === 'number' ? nodeStrokeWidth : undefined\n        },\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__minimap',\n            className\n        ]),\n        \"data-testid\": \"rf__minimap\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n            width: elementWidth,\n            height: elementHeight,\n            viewBox: `${x} ${y} ${width} ${height}`,\n            className: \"react-flow__minimap-svg\",\n            role: \"img\",\n            \"aria-labelledby\": labelledBy,\n            ref: svg,\n            onClick: onSvgClick,\n            children: [\n                ariaLabel && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"title\", {\n                    id: labelledBy,\n                    children: ariaLabel\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MiniMapNodes$1, {\n                    onClick: onSvgNodeClick,\n                    nodeColor: nodeColor,\n                    nodeStrokeColor: nodeStrokeColor,\n                    nodeBorderRadius: nodeBorderRadius,\n                    nodeClassName: nodeClassName,\n                    nodeStrokeWidth: nodeStrokeWidth,\n                    nodeComponent: nodeComponent\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    className: \"react-flow__minimap-mask\",\n                    d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z\n        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`,\n                    fillRule: \"evenodd\",\n                    pointerEvents: \"none\"\n                })\n            ]\n        })\n    });\n}\nMiniMapComponent.displayName = 'MiniMap';\n/**\n * The `<MiniMap />` component can be used to render an overview of your flow. It\n * renders each node as an SVG element and visualizes where the current viewport is\n * in relation to the rest of the flow.\n *\n * @public\n * @example\n *\n * ```jsx\n *import { ReactFlow, MiniMap } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]]} edges={[...]]}>\n *      <MiniMap nodeStrokeWidth={3} />\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const MiniMap = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapComponent);\nfunction ResizeControl({ nodeId, position, variant = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle, className, style = {}, children, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, resizeDirection, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    const contextNodeId = useNodeId();\n    const id = typeof nodeId === 'string' ? nodeId : contextNodeId;\n    const store = useStoreApi();\n    const resizeControlRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const defaultPosition = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line ? 'right' : 'bottom-right';\n    const controlPosition = position ?? defaultPosition;\n    const resizer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ResizeControl.useEffect\": ()=>{\n            if (!resizeControlRef.current || !id) {\n                return;\n            }\n            if (!resizer.current) {\n                resizer.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYResizer)({\n                    domNode: resizeControlRef.current,\n                    nodeId: id,\n                    getStoreItems: {\n                        \"ResizeControl.useEffect\": ()=>{\n                            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, domNode } = store.getState();\n                            return {\n                                nodeLookup,\n                                transform,\n                                snapGrid,\n                                snapToGrid,\n                                nodeOrigin,\n                                paneDomNode: domNode\n                            };\n                        }\n                    }[\"ResizeControl.useEffect\"],\n                    onChange: {\n                        \"ResizeControl.useEffect\": (change, childChanges)=>{\n                            const { triggerNodeChanges, nodeLookup, parentLookup, nodeOrigin } = store.getState();\n                            const changes = [];\n                            const nextPosition = {\n                                x: change.x,\n                                y: change.y\n                            };\n                            const node = nodeLookup.get(id);\n                            if (node && node.expandParent && node.parentId) {\n                                const origin = node.origin ?? nodeOrigin;\n                                const width = change.width ?? node.measured.width ?? 0;\n                                const height = change.height ?? node.measured.height ?? 0;\n                                const child = {\n                                    id: node.id,\n                                    parentId: node.parentId,\n                                    rect: {\n                                        width,\n                                        height,\n                                        ...(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)({\n                                            x: change.x ?? node.position.x,\n                                            y: change.y ?? node.position.y\n                                        }, {\n                                            width,\n                                            height\n                                        }, node.parentId, nodeLookup, origin)\n                                    }\n                                };\n                                const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)([\n                                    child\n                                ], nodeLookup, parentLookup, nodeOrigin);\n                                changes.push(...parentExpandChanges);\n                                /*\n                         * when the parent was expanded by the child node, its position will be clamped at\n                         * 0,0 when node origin is 0,0 and to width, height if it's 1,1\n                         */ nextPosition.x = change.x ? Math.max(origin[0] * width, change.x) : undefined;\n                                nextPosition.y = change.y ? Math.max(origin[1] * height, change.y) : undefined;\n                            }\n                            if (nextPosition.x !== undefined && nextPosition.y !== undefined) {\n                                const positionChange = {\n                                    id,\n                                    type: 'position',\n                                    position: {\n                                        ...nextPosition\n                                    }\n                                };\n                                changes.push(positionChange);\n                            }\n                            if (change.width !== undefined && change.height !== undefined) {\n                                const setAttributes = !resizeDirection ? true : resizeDirection === 'horizontal' ? 'width' : 'height';\n                                const dimensionChange = {\n                                    id,\n                                    type: 'dimensions',\n                                    resizing: true,\n                                    setAttributes,\n                                    dimensions: {\n                                        width: change.width,\n                                        height: change.height\n                                    }\n                                };\n                                changes.push(dimensionChange);\n                            }\n                            for (const childChange of childChanges){\n                                const positionChange = {\n                                    ...childChange,\n                                    type: 'position'\n                                };\n                                changes.push(positionChange);\n                            }\n                            triggerNodeChanges(changes);\n                        }\n                    }[\"ResizeControl.useEffect\"],\n                    onEnd: {\n                        \"ResizeControl.useEffect\": ({ width, height })=>{\n                            const dimensionChange = {\n                                id: id,\n                                type: 'dimensions',\n                                resizing: false,\n                                dimensions: {\n                                    width,\n                                    height\n                                }\n                            };\n                            store.getState().triggerNodeChanges([\n                                dimensionChange\n                            ]);\n                        }\n                    }[\"ResizeControl.useEffect\"]\n                });\n            }\n            resizer.current.update({\n                controlPosition,\n                boundaries: {\n                    minWidth,\n                    minHeight,\n                    maxWidth,\n                    maxHeight\n                },\n                keepAspectRatio,\n                resizeDirection,\n                onResizeStart,\n                onResize,\n                onResizeEnd,\n                shouldResize\n            });\n            return ({\n                \"ResizeControl.useEffect\": ()=>{\n                    resizer.current?.destroy();\n                }\n            })[\"ResizeControl.useEffect\"];\n        }\n    }[\"ResizeControl.useEffect\"], [\n        controlPosition,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        keepAspectRatio,\n        onResizeStart,\n        onResize,\n        onResizeEnd,\n        shouldResize\n    ]);\n    const positionClassNames = controlPosition.split('-');\n    const colorStyleProp = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line ? 'borderColor' : 'backgroundColor';\n    const controlStyle = color ? {\n        ...style,\n        [colorStyleProp]: color\n    } : style;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__resize-control',\n            'nodrag',\n            ...positionClassNames,\n            variant,\n            className\n        ]),\n        ref: resizeControlRef,\n        style: controlStyle,\n        children: children\n    });\n}\n/**\n * To create your own resizing UI, you can use the `NodeResizeControl` component where you can pass children (such as icons).\n * @public\n *\n */ const NodeResizeControl = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ResizeControl);\n/**\n * The `<NodeResizer />` component can be used to add a resize functionality to your\n * nodes. It renders draggable controls around the node to resize in all directions.\n * @public\n *\n * @example\n *```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeResizer } from '@xyflow/react';\n *\n *function ResizableNode({ data }) {\n *  return (\n *    <>\n *      <NodeResizer minWidth={100} minHeight={30} />\n *      <Handle type=\"target\" position={Position.Left} />\n *      <div style={{ padding: 10 }}>{data.label}</div>\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(ResizableNode);\n *```\n */ function NodeResizer({ nodeId, isVisible = true, handleClassName, handleStyle, lineClassName, lineStyle, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    if (!isVisible) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_LINE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: lineClassName,\n                    style: lineStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    variant: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position)),\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_HANDLE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: handleClassName,\n                    style: handleStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position))\n        ]\n    });\n}\nconst selector = (state)=>state.domNode?.querySelector('.react-flow__renderer');\nfunction NodeToolbarPortal({ children }) {\n    const wrapperRef = useStore(selector);\n    if (!wrapperRef) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, wrapperRef);\n}\nconst nodeEqualityFn = (a, b)=>a?.internals.positionAbsolute.x !== b?.internals.positionAbsolute.x || a?.internals.positionAbsolute.y !== b?.internals.positionAbsolute.y || a?.measured.width !== b?.measured.width || a?.measured.height !== b?.measured.height || a?.selected !== b?.selected || a?.internals.z !== b?.internals.z;\nconst nodesEqualityFn = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const [key, node] of a){\n        if (nodeEqualityFn(node, b.get(key))) {\n            return false;\n        }\n    }\n    return true;\n};\nconst storeSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2],\n        selectedNodesCount: state.nodes.filter((node)=>node.selected).length\n    });\n/**\n * This component can render a toolbar or tooltip to one side of a custom node. This\n * toolbar doesn't scale with the viewport so that the content is always visible.\n *\n * @public\n * @example\n * ```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeToolbar } from '@xyflow/react';\n *\n *function CustomNode({ data }) {\n *  return (\n *    <>\n *      <NodeToolbar isVisible={data.toolbarVisible} position={data.toolbarPosition}>\n *        <button>delete</button>\n *        <button>copy</button>\n *        <button>expand</button>\n *      </NodeToolbar>\n *\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(CustomNode);\n *```\n * @remarks By default, the toolbar is only visible when a node is selected. If multiple\n * nodes are selected it will not be visible to prevent overlapping toolbars or\n * clutter. You can override this behavior by setting the `isVisible` prop to `true`.\n */ function NodeToolbar({ nodeId, children, className, style, isVisible, position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, offset = 10, align = 'center', ...rest }) {\n    const contextNodeId = useNodeId();\n    const nodesSelector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"NodeToolbar.useCallback[nodesSelector]\": (state)=>{\n            const nodeIds = Array.isArray(nodeId) ? nodeId : [\n                nodeId || contextNodeId || ''\n            ];\n            const internalNodes = nodeIds.reduce({\n                \"NodeToolbar.useCallback[nodesSelector].internalNodes\": (res, id)=>{\n                    const node = state.nodeLookup.get(id);\n                    if (node) {\n                        res.set(node.id, node);\n                    }\n                    return res;\n                }\n            }[\"NodeToolbar.useCallback[nodesSelector].internalNodes\"], new Map());\n            return internalNodes;\n        }\n    }[\"NodeToolbar.useCallback[nodesSelector]\"], [\n        nodeId,\n        contextNodeId\n    ]);\n    const nodes = useStore(nodesSelector, nodesEqualityFn);\n    const { x, y, zoom, selectedNodesCount } = useStore(storeSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    // if isVisible is not set, we show the toolbar only if its node is selected and no other node is selected\n    const isActive = typeof isVisible === 'boolean' ? isVisible : nodes.size === 1 && nodes.values().next().value?.selected && selectedNodesCount === 1;\n    if (!isActive || !nodes.size) {\n        return null;\n    }\n    const nodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodes);\n    const nodesArray = Array.from(nodes.values());\n    const zIndex = Math.max(...nodesArray.map((node)=>node.internals.z + 1));\n    const wrapperStyle = {\n        position: 'absolute',\n        transform: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeToolbarTransform)(nodeRect, {\n            x,\n            y,\n            zoom\n        }, position, offset, align),\n        zIndex,\n        ...style\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeToolbarPortal, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            style: wrapperStyle,\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                'react-flow__node-toolbar',\n                className\n            ]),\n            ...rest,\n            \"data-id\": nodesArray.reduce((acc, node)=>`${acc}${node.id} `, '').trim(),\n            children: children\n        })\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvN0JBQ3dEO0FBQ2dGO0FBQzlHO0FBQ29wQztBQUM1MUI7QUFDL1A7QUFDekM7QUFDRDtBQUV6QyxNQUFNMkYsNkJBQWV4RixvREFBYUEsQ0FBQztBQUNuQyxNQUFNeUYsYUFBYUQsYUFBYUUsUUFBUTtBQUV4QyxNQUFNQyxzQkFBc0JoRix5REFBYSxDQUFDLFdBQVc7QUFDckQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FDRCxTQUFTaUYsU0FBU0MsUUFBUSxFQUFFQyxVQUFVO0lBQ2xDLE1BQU1DLFFBQVE5RixpREFBVUEsQ0FBQ3VGO0lBQ3pCLElBQUlPLFVBQVUsTUFBTTtRQUNoQixNQUFNLElBQUlDLE1BQU1MO0lBQ3BCO0lBQ0EsT0FBT1AsMkVBQXNCQSxDQUFDVyxPQUFPRixVQUFVQztBQUNuRDtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELFNBQVNHO0lBQ0wsTUFBTUYsUUFBUTlGLGlEQUFVQSxDQUFDdUY7SUFDekIsSUFBSU8sVUFBVSxNQUFNO1FBQ2hCLE1BQU0sSUFBSUMsTUFBTUw7SUFDcEI7SUFDQSxPQUFPekYsOENBQU9BOytCQUFDLElBQU87Z0JBQ2xCZ0csVUFBVUgsTUFBTUcsUUFBUTtnQkFDeEJDLFVBQVVKLE1BQU1JLFFBQVE7Z0JBQ3hCQyxXQUFXTCxNQUFNSyxTQUFTO1lBQzlCOzhCQUFJO1FBQUNMO0tBQU07QUFDZjtBQUVBLE1BQU1NLFFBQVE7SUFBRUMsU0FBUztBQUFPO0FBQ2hDLE1BQU1DLGdCQUFnQjtJQUNsQkMsVUFBVTtJQUNWQyxPQUFPO0lBQ1BDLFFBQVE7SUFDUkMsUUFBUSxDQUFDO0lBQ1RDLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxVQUFVO0lBQ1ZDLE1B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b0wsV0FBVzlNLHVFQUF1QkEsQ0FBQytWLFVBQVU7WUFBRWxRO1lBQUdDO1lBQUdDO1FBQUssR0FBR3JFLFVBQVUrdkIsUUFBUXVZO1FBQy9FamY7UUFDQSxHQUFHeHBCLEtBQUs7SUFDWjtJQUNBLE9BQVF0RyxzREFBR0EsQ0FBQ3d1QyxtQkFBbUI7UUFBRTdtQyxVQUFVM0gsc0RBQUdBLENBQUMsT0FBTztZQUFFc0csT0FBTzg2QjtZQUFjbjVCLFdBQVd0SCxvREFBRUEsQ0FBQztnQkFBQztnQkFBNEJzSDthQUFVO1lBQUcsR0FBR0MsSUFBSTtZQUFFLFdBQVcrbUMsV0FBV2xnQyxNQUFNLENBQUMsQ0FBQ21nQyxLQUFLam1DLE9BQVMsR0FBR2ltQyxNQUFNam1DLEtBQUt2QixFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSXluQyxJQUFJO1lBQUl4bkMsVUFBVUE7UUFBUztJQUFHO0FBQ3JQO0FBRWdxQiIsInNvdXJjZXMiOlsiL1VzZXJzL3VzZXIvbm90ZXNvbnVuaXZlcnNlL25vZGVfbW9kdWxlcy9AeHlmbG93L3JlYWN0L2Rpc3QvZXNtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiXG5pbXBvcnQgeyBqc3hzLCBGcmFnbWVudCwganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlTWVtbywgZm9yd2FyZFJlZiwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VMYXlvdXRFZmZlY3QsIHVzZUNhbGxiYWNrLCBtZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNjIGZyb20gJ2NsYXNzY2F0JztcbmltcG9ydCB7IGVycm9yTWVzc2FnZXMsIGluZmluaXRlRXh0ZW50LCBpc0lucHV0RE9NTm9kZSwgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIHBvaW50VG9SZW5kZXJlclBvaW50LCByZW5kZXJlclBvaW50VG9Qb2ludCwgaXNOb2RlQmFzZSwgaXNFZGdlQmFzZSwgZ2V0RWxlbWVudHNUb1JlbW92ZSwgaXNSZWN0T2JqZWN0LCBub2RlVG9SZWN0LCBnZXRPdmVybGFwcGluZ0FyZWEsIGdldE5vZGVzQm91bmRzLCB3aXRoUmVzb2x2ZXJzLCBldmFsdWF0ZUFic29sdXRlUG9zaXRpb24sIGdldERpbWVuc2lvbnMsIFhZUGFuWm9vbSwgUGFuT25TY3JvbGxNb2RlLCBTZWxlY3Rpb25Nb2RlLCBnZXRFdmVudFBvc2l0aW9uLCBnZXROb2Rlc0luc2lkZSwgYXJlU2V0c0VxdWFsLCBYWURyYWcsIHNuYXBQb3NpdGlvbiwgY2FsY3VsYXRlTm9kZVBvc2l0aW9uLCBQb3NpdGlvbiwgQ29ubmVjdGlvbk1vZGUsIGlzTW91c2VFdmVudCwgWFlIYW5kbGUsIGdldEhvc3RGb3JFbGVtZW50LCBhZGRFZGdlLCBnZXRJbnRlcm5hbE5vZGVzQm91bmRzLCBpc051bWVyaWMsIG5vZGVIYXNEaW1lbnNpb25zLCBnZXROb2RlRGltZW5zaW9ucywgZWxlbWVudFNlbGVjdGlvbktleXMsIGlzRWRnZVZpc2libGUsIE1hcmtlclR5cGUsIGNyZWF0ZU1hcmtlcklkcywgZ2V0QmV6aWVyRWRnZUNlbnRlciwgZ2V0U21vb3RoU3RlcFBhdGgsIGdldFN0cmFpZ2h0UGF0aCwgZ2V0QmV6aWVyUGF0aCwgZ2V0RWRnZVBvc2l0aW9uLCBnZXRFbGV2YXRlZEVkZ2VaSW5kZXgsIGdldE1hcmtlcklkLCBnZXRDb25uZWN0aW9uU3RhdHVzLCBDb25uZWN0aW9uTGluZVR5cGUsIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAsIGFkb3B0VXNlck5vZGVzLCBpbml0aWFsQ29ubmVjdGlvbiwgZGV2V2FybiwgdXBkYXRlTm9kZUludGVybmFscywgdXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMsIGhhbmRsZUV4cGFuZFBhcmVudCwgcGFuQnksIGZpdFZpZXdwb3J0LCBpc01hY09zLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsLCBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlLCBzaGFsbG93Tm9kZURhdGEsIFhZTWluaW1hcCwgZ2V0Qm91bmRzT2ZSZWN0cywgUmVzaXplQ29udHJvbFZhcmlhbnQsIFhZUmVzaXplciwgWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUywgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TLCBnZXROb2RlVG9vbGJhclRyYW5zZm9ybSB9IGZyb20gJ0B4eWZsb3cvc3lzdGVtJztcbmV4cG9ydCB7IENvbm5lY3Rpb25MaW5lVHlwZSwgQ29ubmVjdGlvbk1vZGUsIE1hcmtlclR5cGUsIFBhbk9uU2Nyb2xsTW9kZSwgUG9zaXRpb24sIFJlc2l6ZUNvbnRyb2xWYXJpYW50LCBTZWxlY3Rpb25Nb2RlLCBhZGRFZGdlLCBnZXRCZXppZXJFZGdlQ2VudGVyLCBnZXRCZXppZXJQYXRoLCBnZXRDb25uZWN0ZWRFZGdlcywgZ2V0RWRnZUNlbnRlciwgZ2V0SW5jb21lcnMsIGdldE5vZGVzQm91bmRzLCBnZXRPdXRnb2VycywgZ2V0U21vb3RoU3RlcFBhdGgsIGdldFN0cmFpZ2h0UGF0aCwgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIHJlY29ubmVjdEVkZ2UgfSBmcm9tICdAeHlmbG93L3N5c3RlbSc7XG5pbXBvcnQgeyB1c2VTdG9yZVdpdGhFcXVhbGl0eUZuLCBjcmVhdGVXaXRoRXF1YWxpdHlGbiB9IGZyb20gJ3p1c3RhbmQvdHJhZGl0aW9uYWwnO1xuaW1wb3J0IHsgc2hhbGxvdyB9IGZyb20gJ3p1c3RhbmQvc2hhbGxvdyc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuXG5jb25zdCBTdG9yZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgUHJvdmlkZXIkMSA9IFN0b3JlQ29udGV4dC5Qcm92aWRlcjtcblxuY29uc3QgenVzdGFuZEVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAxJ10oKTtcbi8qKlxuICogVGhpcyBob29rIGNhbiBiZSB1c2VkIHRvIHN1YnNjcmliZSB0byBpbnRlcm5hbCBzdGF0ZSBjaGFuZ2VzIG9mIHRoZSBSZWFjdCBGbG93XG4gKiBjb21wb25lbnQuIFRoZSBgdXNlU3RvcmVgIGhvb2sgaXMgcmUtZXhwb3J0ZWQgZnJvbSB0aGUgW1p1c3RhbmRdKGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvenVzdGFuZClcbiAqIHN0YXRlIG1hbmFnZW1lbnQgbGlicmFyeSwgc28geW91IHNob3VsZCBjaGVjayBvdXQgdGhlaXIgZG9jcyBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBzZWxlY3RvciAtIEEgc2VsZWN0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2xpY2Ugb2YgdGhlIGZsb3cncyBpbnRlcm5hbCBzdGF0ZS5cbiAqIEV4dHJhY3Rpbmcgb3IgdHJhbnNmb3JtaW5nIGp1c3QgdGhlIHN0YXRlIHlvdSBuZWVkIGlzIGEgZ29vZCBwcmFjdGljZSB0byBhdm9pZCB1bm5lY2Vzc2FyeVxuICogcmUtcmVuZGVycy5cbiAqIEBwYXJhbSBlcXVhbGl0eUZuIC0gQSBmdW5jdGlvbiB0byBjb21wYXJlIHRoZSBwcmV2aW91cyBhbmQgbmV4dCB2YWx1ZS4gVGhpcyBpcyBpbmNyZWRpYmx5IHVzZWZ1bFxuICogZm9yIHByZXZlbnRpbmcgdW5uZWNlc3NhcnkgcmUtcmVuZGVycy4gR29vZCBzZW5zaWJsZSBkZWZhdWx0cyBhcmUgdXNpbmcgYE9iamVjdC5pc2Agb3IgaW1wb3J0aW5nXG4gKiBgenVzdGFuZC9zaGFsbG93YCwgYnV0IHlvdSBjYW4gYmUgYXMgZ3JhbnVsYXIgYXMgeW91IGxpa2UuXG4gKiBAcmV0dXJucyBUaGUgc2VsZWN0ZWQgc3RhdGUgc2xpY2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBub2RlcyA9IHVzZVN0b3JlKChzdGF0ZSkgPT4gc3RhdGUubm9kZXMpO1xuICogYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIHNob3VsZCBvbmx5IGJlIHVzZWQgaWYgdGhlcmUgaXMgbm8gb3RoZXIgd2F5IHRvIGFjY2VzcyB0aGUgaW50ZXJuYWxcbiAqIHN0YXRlLiBGb3IgbWFueSBvZiB0aGUgY29tbW9uIHVzZSBjYXNlcywgdGhlcmUgYXJlIGRlZGljYXRlZCBob29rcyBhdmFpbGFibGVcbiAqIHN1Y2ggYXMge0BsaW5rIHVzZVJlYWN0Rmxvd30sIHtAbGluayB1c2VWaWV3cG9ydH0sIGV0Yy5cbiAqL1xuZnVuY3Rpb24gdXNlU3RvcmUoc2VsZWN0b3IsIGVxdWFsaXR5Rm4pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgICBpZiAoc3RvcmUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHp1c3RhbmRFcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlU3RvcmVXaXRoRXF1YWxpdHlGbihzdG9yZSwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4pO1xufVxuLyoqXG4gKiBJbiBzb21lIGNhc2VzLCB5b3UgbWlnaHQgbmVlZCB0byBhY2Nlc3MgdGhlIHN0b3JlIGRpcmVjdGx5LiBUaGlzIGhvb2sgcmV0dXJucyB0aGUgc3RvcmUgb2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIG9uIGRlbWFuZCB0byBhY2Nlc3MgdGhlIHN0YXRlIG9yIGRpc3BhdGNoIGFjdGlvbnMuXG4gKlxuICogQHJldHVybnMgVGhlIHN0b3JlIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICogYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIHNob3VsZCBvbmx5IGJlIHVzZWQgaWYgdGhlcmUgaXMgbm8gb3RoZXIgd2F5IHRvIGFjY2VzcyB0aGUgaW50ZXJuYWxcbiAqIHN0YXRlLiBGb3IgbWFueSBvZiB0aGUgY29tbW9uIHVzZSBjYXNlcywgdGhlcmUgYXJlIGRlZGljYXRlZCBob29rcyBhdmFpbGFibGVcbiAqIHN1Y2ggYXMge0BsaW5rIHVzZVJlYWN0Rmxvd30sIHtAbGluayB1c2VWaWV3cG9ydH0sIGV0Yy5cbiAqL1xuZnVuY3Rpb24gdXNlU3RvcmVBcGkoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKHN0b3JlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih6dXN0YW5kRXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBzZXRTdGF0ZTogc3RvcmUuc2V0U3RhdGUsXG4gICAgICAgIHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlLFxuICAgIH0pLCBbc3RvcmVdKTtcbn1cblxuY29uc3Qgc3R5bGUgPSB7IGRpc3BsYXk6ICdub25lJyB9O1xuY29uc3QgYXJpYUxpdmVTdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgbWFyZ2luOiAtMSxcbiAgICBib3JkZXI6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgY2xpcDogJ3JlY3QoMHB4LCAwcHgsIDBweCwgMHB4KScsXG4gICAgY2xpcFBhdGg6ICdpbnNldCgxMDAlKScsXG59O1xuY29uc3QgQVJJQV9OT0RFX0RFU0NfS0VZID0gJ3JlYWN0LWZsb3dfX25vZGUtZGVzYyc7XG5jb25zdCBBUklBX0VER0VfREVTQ19LRVkgPSAncmVhY3QtZmxvd19fZWRnZS1kZXNjJztcbmNvbnN0IEFSSUFfTElWRV9NRVNTQUdFID0gJ3JlYWN0LWZsb3dfX2FyaWEtbGl2ZSc7XG5jb25zdCBzZWxlY3RvciRvID0gKHMpID0+IHMuYXJpYUxpdmVNZXNzYWdlO1xuZnVuY3Rpb24gQXJpYUxpdmVNZXNzYWdlKHsgcmZJZCB9KSB7XG4gICAgY29uc3QgYXJpYUxpdmVNZXNzYWdlID0gdXNlU3RvcmUoc2VsZWN0b3Ikbyk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBpZDogYCR7QVJJQV9MSVZFX01FU1NBR0V9LSR7cmZJZH1gLCBcImFyaWEtbGl2ZVwiOiBcImFzc2VydGl2ZVwiLCBcImFyaWEtYXRvbWljXCI6IFwidHJ1ZVwiLCBzdHlsZTogYXJpYUxpdmVTdHlsZSwgY2hpbGRyZW46IGFyaWFMaXZlTWVzc2FnZSB9KSk7XG59XG5mdW5jdGlvbiBBMTF5RGVzY3JpcHRpb25zKHsgcmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeSB9KSB7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCB7IGlkOiBgJHtBUklBX05PREVfREVTQ19LRVl9LSR7cmZJZH1gLCBzdHlsZTogc3R5bGUsIGNoaWxkcmVuOiBbXCJQcmVzcyBlbnRlciBvciBzcGFjZSB0byBzZWxlY3QgYSBub2RlLlwiLCAhZGlzYWJsZUtleWJvYXJkQTExeSAmJiAnWW91IGNhbiB0aGVuIHVzZSB0aGUgYXJyb3cga2V5cyB0byBtb3ZlIHRoZSBub2RlIGFyb3VuZC4nLCBcIiBQcmVzcyBkZWxldGUgdG8gcmVtb3ZlIGl0IGFuZCBlc2NhcGUgdG8gY2FuY2VsLlwiLCAnICddIH0pLCBqc3goXCJkaXZcIiwgeyBpZDogYCR7QVJJQV9FREdFX0RFU0NfS0VZfS0ke3JmSWR9YCwgc3R5bGU6IHN0eWxlLCBjaGlsZHJlbjogXCJQcmVzcyBlbnRlciBvciBzcGFjZSB0byBzZWxlY3QgYW4gZWRnZS4gWW91IGNhbiB0aGVuIHByZXNzIGRlbGV0ZSB0byByZW1vdmUgaXQgb3IgZXNjYXBlIHRvIGNhbmNlbC5cIiB9KSwgIWRpc2FibGVLZXlib2FyZEExMXkgJiYganN4KEFyaWFMaXZlTWVzc2FnZSwgeyByZklkOiByZklkIH0pXSB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJG4gPSAocykgPT4gKHMudXNlclNlbGVjdGlvbkFjdGl2ZSA/ICdub25lJyA6ICdhbGwnKTtcbi8qKlxuICogVGhlIGA8UGFuZWwgLz5gIGNvbXBvbmVudCBoZWxwcyB5b3UgcG9zaXRpb24gY29udGVudCBhYm92ZSB0aGUgdmlld3BvcnQuXG4gKiBJdCBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIFtgPE1pbmlNYXAgLz5gXSgvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL21pbmltYXApXG4gKiBhbmQgW2A8Q29udHJvbHMgLz5gXSgvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2NvbnRyb2xzKSBjb21wb25lbnRzLlxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgQmFja2dyb3VuZCwgUGFuZWwgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3cgbm9kZXM9e1tdfSBmaXRWaWV3PlxuICogICAgICA8UGFuZWwgcG9zaXRpb249XCJ0b3AtbGVmdFwiPnRvcC1sZWZ0PC9QYW5lbD5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwidG9wLWNlbnRlclwiPnRvcC1jZW50ZXI8L1BhbmVsPlxuICogICAgICA8UGFuZWwgcG9zaXRpb249XCJ0b3AtcmlnaHRcIj50b3AtcmlnaHQ8L1BhbmVsPlxuICogICAgICA8UGFuZWwgcG9zaXRpb249XCJib3R0b20tbGVmdFwiPmJvdHRvbS1sZWZ0PC9QYW5lbD5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwiYm90dG9tLWNlbnRlclwiPmJvdHRvbS1jZW50ZXI8L1BhbmVsPlxuICogICAgICA8UGFuZWwgcG9zaXRpb249XCJib3R0b20tcmlnaHRcIj5ib3R0b20tcmlnaHQ8L1BhbmVsPlxuICogICAgPC9SZWFjdEZsb3c+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuY29uc3QgUGFuZWwgPSBmb3J3YXJkUmVmKCh7IHBvc2l0aW9uID0gJ3RvcC1sZWZ0JywgY2hpbGRyZW4sIGNsYXNzTmFtZSwgc3R5bGUsIC4uLnJlc3QgfSwgcmVmKSA9PiB7XG4gICAgY29uc3QgcG9pbnRlckV2ZW50cyA9IHVzZVN0b3JlKHNlbGVjdG9yJG4pO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2xhc3NlcyA9IGAke3Bvc2l0aW9ufWAuc3BsaXQoJy0nKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19wYW5lbCcsIGNsYXNzTmFtZSwgLi4ucG9zaXRpb25DbGFzc2VzXSksIHN0eWxlOiB7IC4uLnN0eWxlLCBwb2ludGVyRXZlbnRzIH0sIHJlZjogcmVmLCAuLi5yZXN0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufSk7XG5QYW5lbC5kaXNwbGF5TmFtZSA9ICdQYW5lbCc7XG5cbmZ1bmN0aW9uIEF0dHJpYnV0aW9uKHsgcHJvT3B0aW9ucywgcG9zaXRpb24gPSAnYm90dG9tLXJpZ2h0JyB9KSB7XG4gICAgaWYgKHByb09wdGlvbnM/LmhpZGVBdHRyaWJ1dGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goUGFuZWwsIHsgcG9zaXRpb246IHBvc2l0aW9uLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fYXR0cmlidXRpb25cIiwgXCJkYXRhLW1lc3NhZ2VcIjogXCJQbGVhc2Ugb25seSBoaWRlIHRoaXMgYXR0cmlidXRpb24gd2hlbiB5b3UgYXJlIHN1YnNjcmliZWQgdG8gUmVhY3QgRmxvdyBQcm86IGh0dHBzOi8vcHJvLnJlYWN0Zmxvdy5kZXZcIiwgY2hpbGRyZW46IGpzeChcImFcIiwgeyBocmVmOiBcImh0dHBzOi8vcmVhY3RmbG93LmRldlwiLCB0YXJnZXQ6IFwiX2JsYW5rXCIsIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCIsIFwiYXJpYS1sYWJlbFwiOiBcIlJlYWN0IEZsb3cgYXR0cmlidXRpb25cIiwgY2hpbGRyZW46IFwiUmVhY3QgRmxvd1wiIH0pIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkbSA9IChzKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IFtdO1xuICAgIGNvbnN0IHNlbGVjdGVkRWRnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFssIG5vZGVdIG9mIHMubm9kZUxvb2t1cCkge1xuICAgICAgICBpZiAobm9kZS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5wdXNoKG5vZGUuaW50ZXJuYWxzLnVzZXJOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFssIGVkZ2VdIG9mIHMuZWRnZUxvb2t1cCkge1xuICAgICAgICBpZiAoZWRnZS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWRFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHNlbGVjdGVkTm9kZXMsIHNlbGVjdGVkRWRnZXMgfTtcbn07XG5jb25zdCBzZWxlY3RJZCA9IChvYmopID0+IG9iai5pZDtcbmZ1bmN0aW9uIGFyZUVxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gKHNoYWxsb3coYS5zZWxlY3RlZE5vZGVzLm1hcChzZWxlY3RJZCksIGIuc2VsZWN0ZWROb2Rlcy5tYXAoc2VsZWN0SWQpKSAmJlxuICAgICAgICBzaGFsbG93KGEuc2VsZWN0ZWRFZGdlcy5tYXAoc2VsZWN0SWQpLCBiLnNlbGVjdGVkRWRnZXMubWFwKHNlbGVjdElkKSkpO1xufVxuZnVuY3Rpb24gU2VsZWN0aW9uTGlzdGVuZXJJbm5lcih7IG9uU2VsZWN0aW9uQ2hhbmdlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgc2VsZWN0ZWROb2Rlcywgc2VsZWN0ZWRFZGdlcyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkbSwgYXJlRXF1YWwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgbm9kZXM6IHNlbGVjdGVkTm9kZXMsIGVkZ2VzOiBzZWxlY3RlZEVkZ2VzIH07XG4gICAgICAgIG9uU2VsZWN0aW9uQ2hhbmdlPy4ocGFyYW1zKTtcbiAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzLmZvckVhY2goKGZuKSA9PiBmbihwYXJhbXMpKTtcbiAgICB9LCBbc2VsZWN0ZWROb2Rlcywgc2VsZWN0ZWRFZGdlcywgb25TZWxlY3Rpb25DaGFuZ2VdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IGNoYW5nZVNlbGVjdG9yID0gKHMpID0+ICEhcy5vblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzO1xuZnVuY3Rpb24gU2VsZWN0aW9uTGlzdGVuZXIoeyBvblNlbGVjdGlvbkNoYW5nZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlSGFzU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMgPSB1c2VTdG9yZShjaGFuZ2VTZWxlY3Rvcik7XG4gICAgaWYgKG9uU2VsZWN0aW9uQ2hhbmdlIHx8IHN0b3JlSGFzU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMpIHtcbiAgICAgICAgcmV0dXJuIGpzeChTZWxlY3Rpb25MaXN0ZW5lcklubmVyLCB7IG9uU2VsZWN0aW9uQ2hhbmdlOiBvblNlbGVjdGlvbkNoYW5nZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IGRlZmF1bHROb2RlT3JpZ2luID0gWzAsIDBdO1xuY29uc3QgZGVmYXVsdFZpZXdwb3J0ID0geyB4OiAwLCB5OiAwLCB6b29tOiAxIH07XG5cbi8qXG4gKiBUaGlzIGNvbXBvbmVudCBoZWxwcyB1cyB0byB1cGRhdGUgdGhlIHN0b3JlIHdpdGggdGhlIHZhbHVlcyBjb21pbmcgZnJvbSB0aGUgdXNlci5cbiAqIFdlIGRpc3Rpbmd1aXNoIGJldHdlZW4gdmFsdWVzIHdlIGNhbiB1cGRhdGUgZGlyZWN0bHkgd2l0aCBgdXNlRGlyZWN0U3RvcmVVcGRhdGVyYCAobGlrZSBgc25hcEdyaWRgKVxuICogYW5kIHZhbHVlcyB0aGF0IGhhdmUgYSBkZWRpY2F0ZWQgc2V0dGVyIGZ1bmN0aW9uIGluIHRoZSBzdG9yZSAobGlrZSBgc2V0Tm9kZXNgKS5cbiAqL1xuLy8gVGhlc2UgZmllbGRzIGV4aXN0IGluIHRoZSBnbG9iYWwgc3RvcmUsIGFuZCB3ZSBuZWVkIHRvIGtlZXAgdGhlbSB1cCB0byBkYXRlXG5jb25zdCByZWFjdEZsb3dGaWVsZHNUb1RyYWNrID0gW1xuICAgICdub2RlcycsXG4gICAgJ2VkZ2VzJyxcbiAgICAnZGVmYXVsdE5vZGVzJyxcbiAgICAnZGVmYXVsdEVkZ2VzJyxcbiAgICAnb25Db25uZWN0JyxcbiAgICAnb25Db25uZWN0U3RhcnQnLFxuICAgICdvbkNvbm5lY3RFbmQnLFxuICAgICdvbkNsaWNrQ29ubmVjdFN0YXJ0JyxcbiAgICAnb25DbGlja0Nvbm5lY3RFbmQnLFxuICAgICdub2Rlc0RyYWdnYWJsZScsXG4gICAgJ25vZGVzQ29ubmVjdGFibGUnLFxuICAgICdub2Rlc0ZvY3VzYWJsZScsXG4gICAgJ2VkZ2VzRm9jdXNhYmxlJyxcbiAgICAnZWRnZXNSZWNvbm5lY3RhYmxlJyxcbiAgICAnZWxldmF0ZU5vZGVzT25TZWxlY3QnLFxuICAgICdlbGV2YXRlRWRnZXNPblNlbGVjdCcsXG4gICAgJ21pblpvb20nLFxuICAgICdtYXhab29tJyxcbiAgICAnbm9kZUV4dGVudCcsXG4gICAgJ29uTm9kZXNDaGFuZ2UnLFxuICAgICdvbkVkZ2VzQ2hhbmdlJyxcbiAgICAnZWxlbWVudHNTZWxlY3RhYmxlJyxcbiAgICAnY29ubmVjdGlvbk1vZGUnLFxuICAgICdzbmFwR3JpZCcsXG4gICAgJ3NuYXBUb0dyaWQnLFxuICAgICd0cmFuc2xhdGVFeHRlbnQnLFxuICAgICdjb25uZWN0T25DbGljaycsXG4gICAgJ2RlZmF1bHRFZGdlT3B0aW9ucycsXG4gICAgJ2ZpdFZpZXcnLFxuICAgICdmaXRWaWV3T3B0aW9ucycsXG4gICAgJ29uTm9kZXNEZWxldGUnLFxuICAgICdvbkVkZ2VzRGVsZXRlJyxcbiAgICAnb25EZWxldGUnLFxuICAgICdvbk5vZGVEcmFnJyxcbiAgICAnb25Ob2RlRHJhZ1N0YXJ0JyxcbiAgICAnb25Ob2RlRHJhZ1N0b3AnLFxuICAgICdvblNlbGVjdGlvbkRyYWcnLFxuICAgICdvblNlbGVjdGlvbkRyYWdTdGFydCcsXG4gICAgJ29uU2VsZWN0aW9uRHJhZ1N0b3AnLFxuICAgICdvbk1vdmVTdGFydCcsXG4gICAgJ29uTW92ZScsXG4gICAgJ29uTW92ZUVuZCcsXG4gICAgJ25vUGFuQ2xhc3NOYW1lJyxcbiAgICAnbm9kZU9yaWdpbicsXG4gICAgJ2F1dG9QYW5PbkNvbm5lY3QnLFxuICAgICdhdXRvUGFuT25Ob2RlRHJhZycsXG4gICAgJ29uRXJyb3InLFxuICAgICdjb25uZWN0aW9uUmFkaXVzJyxcbiAgICAnaXNWYWxpZENvbm5lY3Rpb24nLFxuICAgICdzZWxlY3ROb2Rlc09uRHJhZycsXG4gICAgJ25vZGVEcmFnVGhyZXNob2xkJyxcbiAgICAnb25CZWZvcmVEZWxldGUnLFxuICAgICdkZWJ1ZycsXG4gICAgJ2F1dG9QYW5TcGVlZCcsXG4gICAgJ3BhbmVDbGlja0Rpc3RhbmNlJyxcbl07XG4vLyByZklkIGRvZXNuJ3QgZXhpc3QgaW4gUmVhY3RGbG93UHJvcHMsIGJ1dCBpdCdzIG9uZSBvZiB0aGUgZmllbGRzIHdlIHdhbnQgdG8gdXBkYXRlXG5jb25zdCBmaWVsZHNUb1RyYWNrID0gWy4uLnJlYWN0Rmxvd0ZpZWxkc1RvVHJhY2ssICdyZklkJ107XG5jb25zdCBzZWxlY3RvciRsID0gKHMpID0+ICh7XG4gICAgc2V0Tm9kZXM6IHMuc2V0Tm9kZXMsXG4gICAgc2V0RWRnZXM6IHMuc2V0RWRnZXMsXG4gICAgc2V0TWluWm9vbTogcy5zZXRNaW5ab29tLFxuICAgIHNldE1heFpvb206IHMuc2V0TWF4Wm9vbSxcbiAgICBzZXRUcmFuc2xhdGVFeHRlbnQ6IHMuc2V0VHJhbnNsYXRlRXh0ZW50LFxuICAgIHNldE5vZGVFeHRlbnQ6IHMuc2V0Tm9kZUV4dGVudCxcbiAgICByZXNldDogcy5yZXNldCxcbiAgICBzZXREZWZhdWx0Tm9kZXNBbmRFZGdlczogcy5zZXREZWZhdWx0Tm9kZXNBbmRFZGdlcyxcbiAgICBzZXRQYW5lQ2xpY2tEaXN0YW5jZTogcy5zZXRQYW5lQ2xpY2tEaXN0YW5jZSxcbn0pO1xuY29uc3QgaW5pdFByZXZWYWx1ZXMgPSB7XG4gICAgLypcbiAgICAgKiB0aGVzZSBhcmUgdmFsdWVzIHRoYXQgYXJlIGFsc28gcGFzc2VkIGRpcmVjdGx5IHRvIG90aGVyIGNvbXBvbmVudHNcbiAgICAgKiB0aGFuIHRoZSBTdG9yZVVwZGF0ZXIuIFdlIGNhbiByZWR1Y2UgdGhlIG51bWJlciBvZiBzZXRTdG9yZSBjYWxsc1xuICAgICAqIGJ5IHNldHRpbmcgdGhlIHNhbWUgdmFsdWVzIGhlcmUgYXMgcHJldiBmaWVsZHMuXG4gICAgICovXG4gICAgdHJhbnNsYXRlRXh0ZW50OiBpbmZpbml0ZUV4dGVudCxcbiAgICBub2RlT3JpZ2luOiBkZWZhdWx0Tm9kZU9yaWdpbixcbiAgICBtaW5ab29tOiAwLjUsXG4gICAgbWF4Wm9vbTogMixcbiAgICBlbGVtZW50c1NlbGVjdGFibGU6IHRydWUsXG4gICAgbm9QYW5DbGFzc05hbWU6ICdub3BhbicsXG4gICAgcmZJZDogJzEnLFxuICAgIHBhbmVDbGlja0Rpc3RhbmNlOiAwLFxufTtcbmZ1bmN0aW9uIFN0b3JlVXBkYXRlcihwcm9wcykge1xuICAgIGNvbnN0IHsgc2V0Tm9kZXMsIHNldEVkZ2VzLCBzZXRNaW5ab29tLCBzZXRNYXhab29tLCBzZXRUcmFuc2xhdGVFeHRlbnQsIHNldE5vZGVFeHRlbnQsIHJlc2V0LCBzZXREZWZhdWx0Tm9kZXNBbmRFZGdlcywgc2V0UGFuZUNsaWNrRGlzdGFuY2UsIH0gPSB1c2VTdG9yZShzZWxlY3RvciRsLCBzaGFsbG93KTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMocHJvcHMuZGVmYXVsdE5vZGVzLCBwcm9wcy5kZWZhdWx0RWRnZXMpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgLy8gd2hlbiB3ZSByZXNldCB0aGUgc3RvcmUgd2UgYWxzbyBuZWVkIHRvIHJlc2V0IHRoZSBwcmV2aW91cyBmaWVsZHNcbiAgICAgICAgICAgIHByZXZpb3VzRmllbGRzLmN1cnJlbnQgPSBpbml0UHJldlZhbHVlcztcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHByZXZpb3VzRmllbGRzID0gdXNlUmVmKGluaXRQcmV2VmFsdWVzKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBmaWVsZHNUb1RyYWNrKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gcHJvcHNbZmllbGROYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRmllbGRWYWx1ZSA9IHByZXZpb3VzRmllbGRzLmN1cnJlbnRbZmllbGROYW1lXTtcbiAgICAgICAgICAgIGlmIChmaWVsZFZhbHVlID09PSBwcmV2aW91c0ZpZWxkVmFsdWUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BzW2ZpZWxkTmFtZV0gPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gQ3VzdG9tIGhhbmRsaW5nIHdpdGggZGVkaWNhdGVkIHNldHRlcnMgZm9yIHNvbWUgZmllbGRzXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lID09PSAnbm9kZXMnKVxuICAgICAgICAgICAgICAgIHNldE5vZGVzKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnZWRnZXMnKVxuICAgICAgICAgICAgICAgIHNldEVkZ2VzKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnbWluWm9vbScpXG4gICAgICAgICAgICAgICAgc2V0TWluWm9vbShmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ21heFpvb20nKVxuICAgICAgICAgICAgICAgIHNldE1heFpvb20oZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICd0cmFuc2xhdGVFeHRlbnQnKVxuICAgICAgICAgICAgICAgIHNldFRyYW5zbGF0ZUV4dGVudChmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ25vZGVFeHRlbnQnKVxuICAgICAgICAgICAgICAgIHNldE5vZGVFeHRlbnQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdwYW5lQ2xpY2tEaXN0YW5jZScpXG4gICAgICAgICAgICAgICAgc2V0UGFuZUNsaWNrRGlzdGFuY2UoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAvLyBSZW5hbWVkIGZpZWxkc1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnZml0VmlldycpXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBmaXRWaWV3UXVldWVkOiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnZml0Vmlld09wdGlvbnMnKVxuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgZml0Vmlld09wdGlvbnM6IGZpZWxkVmFsdWUgfSk7XG4gICAgICAgICAgICAvLyBHZW5lcmFsIGNhc2VcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IFtmaWVsZE5hbWVdOiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzRmllbGRzLmN1cnJlbnQgPSBwcm9wcztcbiAgICB9LCBcbiAgICAvLyBPbmx5IHJlLXJ1biB0aGUgZWZmZWN0IGlmIG9uZSBvZiB0aGUgZmllbGRzIHdlIHRyYWNrIGNoYW5nZXNcbiAgICBmaWVsZHNUb1RyYWNrLm1hcCgoZmllbGROYW1lKSA9PiBwcm9wc1tmaWVsZE5hbWVdKSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldE1lZGlhUXVlcnkoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJyk7XG59XG4vKipcbiAqIEhvb2sgZm9yIHJlY2VpdmluZyB0aGUgY3VycmVudCBjb2xvciBtb2RlIGNsYXNzICdkYXJrJyBvciAnbGlnaHQnLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGNvbG9yTW9kZSAtIFRoZSBjb2xvciBtb2RlIHRvIHVzZSAoJ2RhcmsnLCAnbGlnaHQnIG9yICdzeXN0ZW0nKVxuICovXG5mdW5jdGlvbiB1c2VDb2xvck1vZGVDbGFzcyhjb2xvck1vZGUpIHtcbiAgICBjb25zdCBbY29sb3JNb2RlQ2xhc3MsIHNldENvbG9yTW9kZUNsYXNzXSA9IHVzZVN0YXRlKGNvbG9yTW9kZSA9PT0gJ3N5c3RlbScgPyBudWxsIDogY29sb3JNb2RlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY29sb3JNb2RlICE9PSAnc3lzdGVtJykge1xuICAgICAgICAgICAgc2V0Q29sb3JNb2RlQ2xhc3MoY29sb3JNb2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZWRpYVF1ZXJ5ID0gZ2V0TWVkaWFRdWVyeSgpO1xuICAgICAgICBjb25zdCB1cGRhdGVDb2xvck1vZGVDbGFzcyA9ICgpID0+IHNldENvbG9yTW9kZUNsYXNzKG1lZGlhUXVlcnk/Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnKTtcbiAgICAgICAgdXBkYXRlQ29sb3JNb2RlQ2xhc3MoKTtcbiAgICAgICAgbWVkaWFRdWVyeT8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29sb3JNb2RlQ2xhc3MpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbWVkaWFRdWVyeT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29sb3JNb2RlQ2xhc3MpO1xuICAgICAgICB9O1xuICAgIH0sIFtjb2xvck1vZGVdKTtcbiAgICByZXR1cm4gY29sb3JNb2RlQ2xhc3MgIT09IG51bGwgPyBjb2xvck1vZGVDbGFzcyA6IGdldE1lZGlhUXVlcnkoKT8ubWF0Y2hlcyA/ICdkYXJrJyA6ICdsaWdodCc7XG59XG5cbmNvbnN0IGRlZmF1bHREb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsO1xuLyoqXG4gKiBUaGlzIGhvb2sgbGV0cyB5b3UgbGlzdGVuIGZvciBzcGVjaWZpYyBrZXkgY29kZXMgYW5kIHRlbGxzIHlvdSB3aGV0aGVyIHRoZXkgYXJlXG4gKiBjdXJyZW50bHkgcHJlc3NlZCBvciBub3QuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyB1c2VLZXlQcmVzcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IHNwYWNlUHJlc3NlZCA9IHVzZUtleVByZXNzKCdTcGFjZScpO1xuICogIGNvbnN0IGNtZEFuZFNQcmVzc2VkID0gdXNlS2V5UHJlc3MoWydNZXRhK3MnLCAnU3RyZytzJ10pO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICB7c3BhY2VQcmVzc2VkICYmIDxwPlNwYWNlIHByZXNzZWQhPC9wPn1cbiAqICAgICB7Y21kQW5kU1ByZXNzZWQgJiYgPHA+Q21kICsgUyBwcmVzc2VkITwvcD59XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VLZXlQcmVzcyhcbi8qKlxuICogVGhlIGtleSBjb2RlIChzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncykgc3BlY2lmaWVzIHdoaWNoIGtleShzKSBzaG91bGQgdHJpZ2dlclxuICogYW4gYWN0aW9uLlxuICpcbiAqIEEgKipzdHJpbmcqKiBjYW4gcmVwcmVzZW50OlxuICogLSBBICoqc2luZ2xlIGtleSoqLCBlLmcuIGAnYSdgXG4gKiAtIEEgKiprZXkgY29tYmluYXRpb24qKiwgdXNpbmcgYCcrJ2AgdG8gc2VwYXJhdGUga2V5cywgZS5nLiBgJ2ErZCdgXG4gKlxuICogQW4gICoqYXJyYXkgb2Ygc3RyaW5ncyoqIHJlcHJlc2VudHMgKiptdWx0aXBsZSBwb3NzaWJsZSBrZXkgaW5wdXRzKiouIEZvciBleGFtcGxlLCBgWydhJywgJ2QrcyddYFxuICogbWVhbnMgdGhlIHVzZXIgY2FuIHByZXNzIGVpdGhlciB0aGUgc2luZ2xlIGtleSBgJ2EnYCBvciB0aGUgY29tYmluYXRpb24gb2YgYCdkJ2AgYW5kIGAncydgLlxuICogQGRlZmF1bHQgbnVsbFxuICovXG5rZXlDb2RlID0gbnVsbCwgb3B0aW9ucyA9IHsgdGFyZ2V0OiBkZWZhdWx0RG9jLCBhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcjogdHJ1ZSB9KSB7XG4gICAgY29uc3QgW2tleVByZXNzZWQsIHNldEtleVByZXNzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgaWYgYSBtb2RpZmllciBrZXkgaXMgcHJlc3NlZCBpbiBvcmRlciB0byB0cmFjayBpdFxuICAgIGNvbnN0IG1vZGlmaWVyUHJlc3NlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gd2UgbmVlZCB0byByZW1lbWJlciB0aGUgcHJlc3NlZCBrZXlzIGluIG9yZGVyIHRvIHN1cHBvcnQgY29tYmluYXRpb25zXG4gICAgY29uc3QgcHJlc3NlZEtleXMgPSB1c2VSZWYobmV3IFNldChbXSkpO1xuICAgIC8qXG4gICAgICoga2V5Q29kZXMgPSBhcnJheSB3aXRoIHNpbmdsZSBrZXlzIFtbJ2EnXV0gb3Iga2V5IGNvbWJpbmF0aW9ucyBbWydhJywgJ3MnXV1cbiAgICAgKiBrZXlzVG9XYXRjaCA9IGFycmF5IHdpdGggYWxsIGtleXMgZmxhdHRlbmVkIFsnYScsICdkJywgJ1NoaWZ0TGVmdCddXG4gICAgICogdXNlZCB0byBjaGVjayBpZiB3ZSBzdG9yZSBldmVudC5jb2RlIG9yIGV2ZW50LmtleS4gV2hlbiB0aGUgY29kZSBpcyBpbiB0aGUgbGlzdCBvZiBrZXlzVG9XYXRjaFxuICAgICAqIHdlIHVzZSB0aGUgY29kZSBvdGhlcndpc2UgdGhlIGtleS4gRXhwbGFpbmVyOiBXaGVuIHlvdSBwcmVzcyB0aGUgbGVmdCBcImNvbW1hbmRcIiBrZXksIHRoZSBjb2RlIGlzIFwiTWV0YUxlZnRcIlxuICAgICAqIGFuZCB0aGUga2V5IGlzIFwiTWV0YVwiLiBXZSB3YW50IHVzZXJzIHRvIGJlIGFibGUgdG8gcGFzcyBrZXlzIGFuZCBjb2RlcyBzbyB3ZSBhc3N1bWUgdGhhdCB0aGUga2V5IGlzIG1lYW50IHdoZW5cbiAgICAgKiB3ZSBjYW4ndCBmaW5kIGl0IGluIHRoZSBsaXN0IG9mIGtleXNUb1dhdGNoLlxuICAgICAqL1xuICAgIGNvbnN0IFtrZXlDb2Rlcywga2V5c1RvV2F0Y2hdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChrZXlDb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlDb2RlQXJyID0gQXJyYXkuaXNBcnJheShrZXlDb2RlKSA/IGtleUNvZGUgOiBba2V5Q29kZV07XG4gICAgICAgICAgICBjb25zdCBrZXlzID0ga2V5Q29kZUFyclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGtjKSA9PiB0eXBlb2Yga2MgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogd2UgZmlyc3QgcmVwbGFjZSBhbGwgJysnIHdpdGggJ1xcbicgIHdoaWNoIHdlIHdpbGwgdXNlIHRvIHNwbGl0IHRoZSBrZXlzIG9uXG4gICAgICAgICAgICAgICAgICogdGhlbiB3ZSByZXBsYWNlICdcXG5cXG4nIHdpdGggJ1xcbisnLCB0aGlzIHdheSB3ZSBjYW4gYWxzbyBzdXBwb3J0IHRoZSBjb21iaW5hdGlvbiAna2V5KysnXG4gICAgICAgICAgICAgICAgICogaW4gdGhlIGVuZCB3ZSBzaW1wbHkgc3BsaXQgb24gJ1xcbicgdG8gZ2V0IHRoZSBrZXkgYXJyYXlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAubWFwKChrYykgPT4ga2MucmVwbGFjZSgnKycsICdcXG4nKS5yZXBsYWNlKCdcXG5cXG4nLCAnXFxuKycpLnNwbGl0KCdcXG4nKSk7XG4gICAgICAgICAgICBjb25zdCBrZXlzRmxhdCA9IGtleXMucmVkdWNlKChyZXMsIGl0ZW0pID0+IHJlcy5jb25jYXQoLi4uaXRlbSksIFtdKTtcbiAgICAgICAgICAgIHJldHVybiBba2V5cywga2V5c0ZsYXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbW10sIFtdXTtcbiAgICB9LCBba2V5Q29kZV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnM/LnRhcmdldCA/PyBkZWZhdWx0RG9jO1xuICAgICAgICBjb25zdCBhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllciA9IG9wdGlvbnM/LmFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyID8/IHRydWU7XG4gICAgICAgIGlmIChrZXlDb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkb3duSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50ID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ZW50QWN0aW9uID0gKCFtb2RpZmllclByZXNzZWQuY3VycmVudCB8fCAobW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgJiYgIWFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNJbnB1dERPTU5vZGUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ZW50QWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5T3JDb2RlID0gdXNlS2V5T3JDb2RlKGV2ZW50LmNvZGUsIGtleXNUb1dhdGNoKTtcbiAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5jdXJyZW50LmFkZChldmVudFtrZXlPckNvZGVdKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGluZ0tleShrZXlDb2RlcywgcHJlc3NlZEtleXMuY3VycmVudCwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChldmVudC5jb21wb3NlZFBhdGg/LigpPy5bMF0gfHwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNJbnRlcmFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ/Lm5vZGVOYW1lID09PSAnQlVUVE9OJyB8fCB0YXJnZXQ/Lm5vZGVOYW1lID09PSAnQSc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnByZXZlbnREZWZhdWx0ICE9PSBmYWxzZSAmJiAobW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgfHwgIWlzSW50ZXJhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRLZXlQcmVzc2VkKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB1cEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlPckNvZGUgPSB1c2VLZXlPckNvZGUoZXZlbnQuY29kZSwga2V5c1RvV2F0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cy5jdXJyZW50LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRLZXlQcmVzc2VkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5kZWxldGUoZXZlbnRba2V5T3JDb2RlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZpeCBmb3IgTWFjOiB3aGVuIGNtZCBrZXkgaXMgcHJlc3NlZCwga2V5dXAgaXMgbm90IHRyaWdnZXJlZCBmb3IgYW55IG90aGVyIGtleSwgc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNzM4MDAxOC93aGVuLWNtZC1rZXktaXMta2VwdC1wcmVzc2VkLWtleXVwLWlzLW5vdC10cmlnZ2VyZWQtZm9yLWFueS1vdGhlci1rZXlcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnTWV0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RpZmllclByZXNzZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZChmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGFyZ2V0Py5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgdGFyZ2V0Py5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwSGFuZGxlcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHJlc2V0SGFuZGxlcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Py5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHJlc2V0SGFuZGxlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW2tleUNvZGUsIHNldEtleVByZXNzZWRdKTtcbiAgICByZXR1cm4ga2V5UHJlc3NlZDtcbn1cbi8vIHV0aWxzXG5mdW5jdGlvbiBpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cywgaXNVcCkge1xuICAgIHJldHVybiAoa2V5Q29kZXNcbiAgICAgICAgLypcbiAgICAgICAgICogd2Ugb25seSB3YW50IHRvIGNvbXBhcmUgc2FtZSBzaXplcyBvZiBrZXlDb2RlIGRlZmluaXRpb25zXG4gICAgICAgICAqIGFuZCBwcmVzc2VkIGtleXMuIFdoZW4gdGhlIHVzZXIgc3BlY2lmaWVkICdNZXRhJyBhcyBhIGtleSBzb21ld2hlcmVcbiAgICAgICAgICogdGhpcyB3b3VsZCBhbHNvIGJlIHRydXRoeSB3aXRob3V0IHRoaXMgZmlsdGVyIHdoZW4gdXNlciBwcmVzc2VzICdNZXRhJyArICdyJ1xuICAgICAgICAgKi9cbiAgICAgICAgLmZpbHRlcigoa2V5cykgPT4gaXNVcCB8fCBrZXlzLmxlbmd0aCA9PT0gcHJlc3NlZEtleXMuc2l6ZSlcbiAgICAgICAgLypcbiAgICAgICAgICogc2luY2Ugd2Ugd2FudCB0byBzdXBwb3J0IG11bHRpcGxlIHBvc3NpYmlsaXRpZXMgb25seSBvbmUgb2YgdGhlXG4gICAgICAgICAqIGNvbWJpbmF0aW9ucyBuZWVkIHRvIGJlIHBhcnQgb2YgdGhlIHByZXNzZWQga2V5c1xuICAgICAgICAgKi9cbiAgICAgICAgLnNvbWUoKGtleXMpID0+IGtleXMuZXZlcnkoKGspID0+IHByZXNzZWRLZXlzLmhhcyhrKSkpKTtcbn1cbmZ1bmN0aW9uIHVzZUtleU9yQ29kZShldmVudENvZGUsIGtleXNUb1dhdGNoKSB7XG4gICAgcmV0dXJuIGtleXNUb1dhdGNoLmluY2x1ZGVzKGV2ZW50Q29kZSkgPyAnY29kZScgOiAna2V5Jztcbn1cblxuLyoqXG4gKiBIb29rIGZvciBnZXR0aW5nIHZpZXdwb3J0IGhlbHBlciBmdW5jdGlvbnMuXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJucyB2aWV3cG9ydCBoZWxwZXIgZnVuY3Rpb25zXG4gKi9cbmNvbnN0IHVzZVZpZXdwb3J0SGVscGVyID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB6b29tSW46IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5ab29tID8gcGFuWm9vbS5zY2FsZUJ5KDEuMiwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24gfSkgOiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHpvb21PdXQ6IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5ab29tID8gcGFuWm9vbS5zY2FsZUJ5KDEgLyAxLjIsIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pIDogUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6b29tVG86ICh6b29tTGV2ZWwsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhblpvb20gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhblpvb20gPyBwYW5ab29tLnNjYWxlVG8oem9vbUxldmVsLCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KSA6IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Wm9vbTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm1bMl0sXG4gICAgICAgICAgICBzZXRWaWV3cG9ydDogYXN5bmMgKHZpZXdwb3J0LCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm06IFt0WCwgdFksIHRab29tXSwgcGFuWm9vbSwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgeDogdmlld3BvcnQueCA/PyB0WCxcbiAgICAgICAgICAgICAgICAgICAgeTogdmlld3BvcnQueSA/PyB0WSxcbiAgICAgICAgICAgICAgICAgICAgem9vbTogdmlld3BvcnQuem9vbSA/PyB0Wm9vbSxcbiAgICAgICAgICAgICAgICB9LCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFZpZXdwb3J0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3gsIHksIHpvb21dID0gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSwgem9vbSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldENlbnRlcjogYXN5bmMgKHgsIHksIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIG1heFpvb20sIHBhblpvb20gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFpvb20gPSB0eXBlb2Ygb3B0aW9ucz8uem9vbSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnpvb20gOiBtYXhab29tO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlclggPSB3aWR0aCAvIDIgLSB4ICogbmV4dFpvb207XG4gICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWSA9IGhlaWdodCAvIDIgLSB5ICogbmV4dFpvb207XG4gICAgICAgICAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgeTogY2VudGVyWSxcbiAgICAgICAgICAgICAgICAgICAgem9vbTogbmV4dFpvb20sXG4gICAgICAgICAgICAgICAgfSwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24gfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXRCb3VuZHM6IGFzeW5jIChib3VuZHMsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20sIHBhblpvb20gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3cG9ydEZvckJvdW5kcyhib3VuZHMsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20sIG9wdGlvbnM/LnBhZGRpbmcgPz8gMC4xKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhblpvb20pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHBhblpvb20uc2V0Vmlld3BvcnQodmlld3BvcnQsIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NyZWVuVG9GbG93UG9zaXRpb246IChjbGllbnRQb3NpdGlvbiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50UG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgeDogZG9tWCwgeTogZG9tWSB9ID0gZG9tTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3JyZWN0ZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogY2xpZW50UG9zaXRpb24ueCAtIGRvbVgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGNsaWVudFBvc2l0aW9uLnkgLSBkb21ZLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgX3NuYXBHcmlkID0gb3B0aW9ucy5zbmFwR3JpZCA/PyBzbmFwR3JpZDtcbiAgICAgICAgICAgICAgICBjb25zdCBfc25hcFRvR3JpZCA9IG9wdGlvbnMuc25hcFRvR3JpZCA/PyBzbmFwVG9HcmlkO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludFRvUmVuZGVyZXJQb2ludChjb3JyZWN0ZWRQb3NpdGlvbiwgdHJhbnNmb3JtLCBfc25hcFRvR3JpZCwgX3NuYXBHcmlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmbG93VG9TY3JlZW5Qb3NpdGlvbjogKGZsb3dQb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvd1Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHg6IGRvbVgsIHk6IGRvbVkgfSA9IGRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXJQb3NpdGlvbiA9IHJlbmRlcmVyUG9pbnRUb1BvaW50KGZsb3dQb3NpdGlvbiwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiByZW5kZXJlclBvc2l0aW9uLnggKyBkb21YLFxuICAgICAgICAgICAgICAgICAgICB5OiByZW5kZXJlclBvc2l0aW9uLnkgKyBkb21ZLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbn07XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIGFwcGxpZXMgY2hhbmdlcyB0byBub2RlcyBvciBlZGdlcyB0aGF0IGFyZSB0cmlnZ2VyZWQgYnkgUmVhY3QgRmxvdyBpbnRlcm5hbGx5LlxuICogV2hlbiB5b3UgZHJhZyBhIG5vZGUgZm9yIGV4YW1wbGUsIFJlYWN0IEZsb3cgd2lsbCBzZW5kIGEgcG9zaXRpb24gY2hhbmdlIHVwZGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gdGhlbiBhcHBsaWVzIHRoZSBjaGFuZ2VzIGFuZCByZXR1cm5zIHRoZSB1cGRhdGVkIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBhcHBseUNoYW5nZXMoY2hhbmdlcywgZWxlbWVudHMpIHtcbiAgICBjb25zdCB1cGRhdGVkRWxlbWVudHMgPSBbXTtcbiAgICAvKlxuICAgICAqIEJ5IHN0b3JpbmcgYSBtYXAgb2YgY2hhbmdlcyBmb3IgZWFjaCBlbGVtZW50LCB3ZSBjYW4gYSBxdWljayBsb29rdXAgYXMgd2VcbiAgICAgKiBpdGVyYXRlIG92ZXIgdGhlIGVsZW1lbnRzIGFycmF5IVxuICAgICAqL1xuICAgIGNvbnN0IGNoYW5nZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgYWRkSXRlbUNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgIGFkZEl0ZW1DaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAncmVtb3ZlJyB8fCBjaGFuZ2UudHlwZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogRm9yIGEgJ3JlbW92ZScgY2hhbmdlIHdlIGNhbiBzYWZlbHkgaWdub3JlIGFueSBvdGhlciBjaGFuZ2VzIHF1ZXVlZCBmb3JcbiAgICAgICAgICAgICAqIHRoZSBzYW1lIGVsZW1lbnQsIGl0J3MgZ29pbmcgdG8gYmUgcmVtb3ZlZCBhbnl3YXkhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNoYW5nZXNNYXAuc2V0KGNoYW5nZS5pZCwgW2NoYW5nZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudENoYW5nZXMgPSBjaGFuZ2VzTWFwLmdldChjaGFuZ2UuaWQpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBJZiB3ZSBoYXZlIHNvbWUgY2hhbmdlcyBxdWV1ZWQgYWxyZWFkeSwgd2UgY2FuIGRvIGEgbXV0YWJsZSB1cGRhdGUgb2ZcbiAgICAgICAgICAgICAgICAgKiB0aGF0IGFycmF5IGFuZCBzYXZlIG91cnNlbHZlcyBzb21lIGNvcHlpbmcuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZWxlbWVudENoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlc01hcC5zZXQoY2hhbmdlLmlkLCBbY2hhbmdlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBjaGFuZ2VzTWFwLmdldChlbGVtZW50LmlkKTtcbiAgICAgICAgLypcbiAgICAgICAgICogV2hlbiB0aGVyZSBhcmUgbm8gY2hhbmdlcyBmb3IgYW4gZWxlbWVudCB3ZSBjYW4ganVzdCBwdXNoIGl0IHVubW9kaWZpZWQsXG4gICAgICAgICAqIG5vIG5lZWQgdG8gY29weSBpdC5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghY2hhbmdlcykge1xuICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgJ3JlbW92ZScgY2hhbmdlIHF1ZXVlZCwgaXQnbGwgYmUgdGhlIG9ubHkgY2hhbmdlIGluIHRoZSBhcnJheVxuICAgICAgICBpZiAoY2hhbmdlc1swXS50eXBlID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbMF0udHlwZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICB1cGRhdGVkRWxlbWVudHMucHVzaCh7IC4uLmNoYW5nZXNbMF0uaXRlbSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3Igb3RoZXIgdHlwZXMgb2YgY2hhbmdlcywgd2Ugd2FudCB0byBzdGFydCB3aXRoIGEgc2hhbGxvdyBjb3B5IG9mIHRoZVxuICAgICAgICAgKiBvYmplY3Qgc28gUmVhY3Qga25vd3MgdGhpcyBlbGVtZW50IGhhcyBjaGFuZ2VkLiBTZXF1ZW50aWFsIGNoYW5nZXMgd2lsbFxuICAgICAgICAgKiBlYWNoIF9tdXRhdGVfIHRoaXMgb2JqZWN0LCBzbyB0aGVyZSdzIG9ubHkgZXZlciBvbmUgY29weS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRFbGVtZW50ID0geyAuLi5lbGVtZW50IH07XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGFwcGx5Q2hhbmdlKGNoYW5nZSwgdXBkYXRlZEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZWRFbGVtZW50cy5wdXNoKHVwZGF0ZWRFbGVtZW50KTtcbiAgICB9XG4gICAgLypcbiAgICAgKiB3ZSBuZWVkIHRvIHdhaXQgZm9yIGFsbCBjaGFuZ2VzIHRvIGJlIGFwcGxpZWQgYmVmb3JlIGFkZGluZyBuZXcgaXRlbXNcbiAgICAgKiB0byBiZSBhYmxlIHRvIGFkZCB0aGVtIGF0IHRoZSBjb3JyZWN0IGluZGV4XG4gICAgICovXG4gICAgaWYgKGFkZEl0ZW1DaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgICBhZGRJdGVtQ2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2UuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRFbGVtZW50cy5zcGxpY2UoY2hhbmdlLmluZGV4LCAwLCB7IC4uLmNoYW5nZS5pdGVtIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2goeyAuLi5jaGFuZ2UuaXRlbSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGVkRWxlbWVudHM7XG59XG4vLyBBcHBsaWVzIGEgc2luZ2xlIGNoYW5nZSB0byBhbiBlbGVtZW50LiBUaGlzIGlzIGEgKm11dGFibGUqIHVwZGF0ZS5cbmZ1bmN0aW9uIGFwcGx5Q2hhbmdlKGNoYW5nZSwgZWxlbWVudCkge1xuICAgIHN3aXRjaCAoY2hhbmdlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2VsZWN0Jzoge1xuICAgICAgICAgICAgZWxlbWVudC5zZWxlY3RlZCA9IGNoYW5nZS5zZWxlY3RlZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3Bvc2l0aW9uJzoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UucG9zaXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5wb3NpdGlvbiA9IGNoYW5nZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLmRyYWdnaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZHJhZ2dpbmcgPSBjaGFuZ2UuZHJhZ2dpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdkaW1lbnNpb25zJzoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UuZGltZW5zaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm1lYXN1cmVkID8/PSB7fTtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm1lYXN1cmVkLndpZHRoID0gY2hhbmdlLmRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5tZWFzdXJlZC5oZWlnaHQgPSBjaGFuZ2UuZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5zZXRBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc2V0QXR0cmlidXRlcyA9PT0gdHJ1ZSB8fCBjaGFuZ2Uuc2V0QXR0cmlidXRlcyA9PT0gJ3dpZHRoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC53aWR0aCA9IGNoYW5nZS5kaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc2V0QXR0cmlidXRlcyA9PT0gdHJ1ZSB8fCBjaGFuZ2Uuc2V0QXR0cmlidXRlcyA9PT0gJ2hlaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaGVpZ2h0ID0gY2hhbmdlLmRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UucmVzaXppbmcgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVzaXppbmcgPSBjaGFuZ2UucmVzaXppbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRHJvcCBpbiBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgbm9kZSBjaGFuZ2VzIHRvIGFuIGFycmF5IG9mIG5vZGVzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIGNoYW5nZXMgLSBBcnJheSBvZiBjaGFuZ2VzIHRvIGFwcGx5LlxuICogQHBhcmFtIG5vZGVzIC0gQXJyYXkgb2Ygbm9kZXMgdG8gYXBwbHkgdGhlIGNoYW5nZXMgdG8uXG4gKiBAcmV0dXJucyBBcnJheSBvZiB1cGRhdGVkIG5vZGVzLlxuICogQGV4YW1wbGVcbiAqYGBgdHN4XG4gKmltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBhcHBseU5vZGVDaGFuZ2VzLCB0eXBlIE5vZGUsIHR5cGUgRWRnZSwgdHlwZSBPbk5vZGVzQ2hhbmdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXNdID0gdXNlU3RhdGU8Tm9kZVtdPihbXSk7XG4gKiAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlc10gPSB1c2VTdGF0ZTxFZGdlW10+KFtdKTtcbiAqICBjb25zdCBvbk5vZGVzQ2hhbmdlOiBPbk5vZGVzQ2hhbmdlID0gdXNlQ2FsbGJhY2soXG4gKiAgICAoY2hhbmdlcykgPT4ge1xuICogICAgICBzZXROb2Rlcygob2xkTm9kZXMpID0+IGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgb2xkTm9kZXMpKTtcbiAqICAgIH0sXG4gKiAgICBbc2V0Tm9kZXNdLFxuICogICk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtub2Rlc30gZWRnZXM9e2VkZ2VzfSBvbk5vZGVzQ2hhbmdlPXtvbk5vZGVzQ2hhbmdlfSAvPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKiBAcmVtYXJrcyBWYXJpb3VzIGV2ZW50cyBvbiB0aGUgPFJlYWN0RmxvdyAvPiBjb21wb25lbnQgY2FuIHByb2R1Y2UgYW4ge0BsaW5rIE5vZGVDaGFuZ2V9XG4gKiB0aGF0IGRlc2NyaWJlcyBob3cgdG8gdXBkYXRlIHRoZSBlZGdlcyBvZiB5b3VyIGZsb3cgaW4gc29tZSB3YXkuXG4gKiBJZiB5b3UgZG9uJ3QgbmVlZCBhbnkgY3VzdG9tIGJlaGF2aW91ciwgdGhpcyB1dGlsIGNhbiBiZSB1c2VkIHRvIHRha2UgYW4gYXJyYXlcbiAqIG9mIHRoZXNlIGNoYW5nZXMgYW5kIGFwcGx5IHRoZW0gdG8geW91ciBlZGdlcy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBub2Rlcykge1xuICAgIHJldHVybiBhcHBseUNoYW5nZXMoY2hhbmdlcywgbm9kZXMpO1xufVxuLyoqXG4gKiBEcm9wIGluIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBlZGdlIGNoYW5nZXMgdG8gYW4gYXJyYXkgb2YgZWRnZXMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gY2hhbmdlcyAtIEFycmF5IG9mIGNoYW5nZXMgdG8gYXBwbHkuXG4gKiBAcGFyYW0gZWRnZXMgLSBBcnJheSBvZiBlZGdlIHRvIGFwcGx5IHRoZSBjaGFuZ2VzIHRvLlxuICogQHJldHVybnMgQXJyYXkgb2YgdXBkYXRlZCBlZGdlcy5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBSZWFjdEZsb3csIGFwcGx5RWRnZUNoYW5nZXMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgY29uc3QgW25vZGVzLCBzZXROb2Rlc10gPSB1c2VTdGF0ZShbXSk7XG4gKiAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlc10gPSB1c2VTdGF0ZShbXSk7XG4gKiAgY29uc3Qgb25FZGdlc0NoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICogICAgKGNoYW5nZXMpID0+IHtcbiAqICAgICAgc2V0RWRnZXMoKG9sZEVkZ2VzKSA9PiBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIG9sZEVkZ2VzKSk7XG4gKiAgICB9LFxuICogICAgW3NldEVkZ2VzXSxcbiAqICApO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0RmxvdyBub2Rlcz17bm9kZXN9IGVkZ2VzPXtlZGdlc30gb25FZGdlc0NoYW5nZT17b25FZGdlc0NoYW5nZX0gLz5cbiAqICApO1xuICp9XG4gKmBgYFxuICogQHJlbWFya3MgVmFyaW91cyBldmVudHMgb24gdGhlIDxSZWFjdEZsb3cgLz4gY29tcG9uZW50IGNhbiBwcm9kdWNlIGFuIHtAbGluayBFZGdlQ2hhbmdlfVxuICogdGhhdCBkZXNjcmliZXMgaG93IHRvIHVwZGF0ZSB0aGUgZWRnZXMgb2YgeW91ciBmbG93IGluIHNvbWUgd2F5LlxuICogSWYgeW91IGRvbid0IG5lZWQgYW55IGN1c3RvbSBiZWhhdmlvdXIsIHRoaXMgdXRpbCBjYW4gYmUgdXNlZCB0byB0YWtlIGFuIGFycmF5XG4gKiBvZiB0aGVzZSBjaGFuZ2VzIGFuZCBhcHBseSB0aGVtIHRvIHlvdXIgZWRnZXMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgZWRnZXMpIHtcbiAgICByZXR1cm4gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIGVkZ2VzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShpZCwgc2VsZWN0ZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZCxcbiAgICAgICAgdHlwZTogJ3NlbGVjdCcsXG4gICAgICAgIHNlbGVjdGVkLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25DaGFuZ2VzKGl0ZW1zLCBzZWxlY3RlZElkcyA9IG5ldyBTZXQoKSwgbXV0YXRlSXRlbSA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2lkLCBpdGVtXSBvZiBpdGVtcykge1xuICAgICAgICBjb25zdCB3aWxsQmVTZWxlY3RlZCA9IHNlbGVjdGVkSWRzLmhhcyhpZCk7XG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gc2V0IGFsbCBpdGVtcyB0byBzZWxlY3RlZD1mYWxzZSBvbiB0aGUgZmlyc3Qgc2VsZWN0aW9uXG4gICAgICAgIGlmICghKGl0ZW0uc2VsZWN0ZWQgPT09IHVuZGVmaW5lZCAmJiAhd2lsbEJlU2VsZWN0ZWQpICYmIGl0ZW0uc2VsZWN0ZWQgIT09IHdpbGxCZVNlbGVjdGVkKSB7XG4gICAgICAgICAgICBpZiAobXV0YXRlSXRlbSkge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogdGhpcyBoYWNrIGlzIG5lZWRlZCBmb3Igbm9kZXMuIFdoZW4gdGhlIHVzZXIgZHJhZ2dlZCBhIG5vZGUsIGl0J3Mgc2VsZWN0ZWQuXG4gICAgICAgICAgICAgICAgICogV2hlbiBhbm90aGVyIG5vZGUgZ2V0cyBkcmFnZ2VkLCB3ZSBuZWVkIHRvIGRlc2VsZWN0IHRoZSBwcmV2aW91cyBvbmUsXG4gICAgICAgICAgICAgICAgICogaW4gb3JkZXIgdG8gaGF2ZSBvbmx5IG9uZSBzZWxlY3RlZCBub2RlIGF0IGEgdGltZSAtIHRoZSBvbk5vZGVzQ2hhbmdlIGNhbGxiYWNrIGNvbWVzIHRvbyBsYXRlIGhlcmUgOi9cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gd2lsbEJlU2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGl0ZW0uaWQsIHdpbGxCZVNlbGVjdGVkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZXM7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50c0RpZmZDaGFuZ2VzKHsgaXRlbXMgPSBbXSwgbG9va3VwLCB9KSB7XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IGl0ZW1zTG9va3VwID0gbmV3IE1hcChpdGVtcy5tYXAoKGl0ZW0pID0+IFtpdGVtLmlkLCBpdGVtXSkpO1xuICAgIGZvciAoY29uc3QgW2luZGV4LCBpdGVtXSBvZiBpdGVtcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgbG9va3VwSXRlbSA9IGxvb2t1cC5nZXQoaXRlbS5pZCk7XG4gICAgICAgIGNvbnN0IHN0b3JlSXRlbSA9IGxvb2t1cEl0ZW0/LmludGVybmFscz8udXNlck5vZGUgPz8gbG9va3VwSXRlbTtcbiAgICAgICAgaWYgKHN0b3JlSXRlbSAhPT0gdW5kZWZpbmVkICYmIHN0b3JlSXRlbSAhPT0gaXRlbSkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgaWQ6IGl0ZW0uaWQsIGl0ZW06IGl0ZW0sIHR5cGU6ICdyZXBsYWNlJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcmVJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGl0ZW06IGl0ZW0sIHR5cGU6ICdhZGQnLCBpbmRleCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZF0gb2YgbG9va3VwKSB7XG4gICAgICAgIGNvbnN0IG5leHROb2RlID0gaXRlbXNMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgaWYgKG5leHROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGlkLCB0eXBlOiAncmVtb3ZlJyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlcztcbn1cbmZ1bmN0aW9uIGVsZW1lbnRUb1JlbW92ZUNoYW5nZShpdGVtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgIHR5cGU6ICdyZW1vdmUnLFxuICAgIH07XG59XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyB1c2FibGUgYXMgYW4gW2BOb2RlYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvbm9kZSkuXG4gKiBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG9cbiAqIFtgTm9kZWBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL25vZGUpIGlmIGl0IHJldHVybnMgYHRydWVgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBOb2RlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0LlxuICogQHJldHVybnMgVGVzdHMgd2hldGhlciB0aGUgcHJvdmlkZWQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYSBgTm9kZWAuIElmIHlvdSdyZSB1c2luZyBUeXBlU2NyaXB0LFxuICogdGhpcyBmdW5jdGlvbiBhY3RzIGFzIGEgdHlwZSBndWFyZCBhbmQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGBOb2RlYCBpZiBpdCByZXR1cm5zXG4gKiBgdHJ1ZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmltcG9ydCB7IGlzTm9kZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqaWYgKGlzTm9kZShub2RlKSkge1xuICogLy8gLi4uXG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IGlzTm9kZSA9IChlbGVtZW50KSA9PiBpc05vZGVCYXNlKGVsZW1lbnQpO1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVzYWJsZSBhcyBhbiBbYEVkZ2VgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9lZGdlKS5cbiAqIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0b1xuICogW2BFZGdlYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvZWRnZSkgaWYgaXQgcmV0dXJucyBgdHJ1ZWAuXG4gKlxuICogQHB1YmxpY1xuICogQHJlbWFya3MgSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvIEVkZ2UgaWYgaXQgcmV0dXJucyB0cnVlXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIHRlc3RcbiAqIEByZXR1cm5zIFRlc3RzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHZhbHVlIGNhbiBiZSB1c2VkIGFzIGFuIGBFZGdlYC4gSWYgeW91J3JlIHVzaW5nIFR5cGVTY3JpcHQsXG4gKiB0aGlzIGZ1bmN0aW9uIGFjdHMgYXMgYSB0eXBlIGd1YXJkIGFuZCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gYEVkZ2VgIGlmIGl0IHJldHVybnNcbiAqIGB0cnVlYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqaW1wb3J0IHsgaXNFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICppZiAoaXNFZGdlKGVkZ2UpKSB7XG4gKiAvLyAuLi5cbiAqfVxuICpgYGBcbiAqL1xuY29uc3QgaXNFZGdlID0gKGVsZW1lbnQpID0+IGlzRWRnZUJhc2UoZWxlbWVudCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LW9iamVjdC10eXBlXG5mdW5jdGlvbiBmaXhlZEZvcndhcmRSZWYocmVuZGVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4gZm9yd2FyZFJlZihyZW5kZXIpO1xufVxuXG4vLyB3ZSBuZWVkIHRoaXMgaG9vayB0byBwcmV2ZW50IGEgd2FybmluZyB3aGVuIHVzaW5nIHJlYWN0LWZsb3cgaW4gU1NSXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgYSBxdWV1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGJhdGNoIHVwZGF0ZXMuXG4gKlxuICogQHBhcmFtIHJ1blF1ZXVlIC0gYSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGZsdXNoZWRcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEByZXR1cm5zIGEgUXVldWUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHVzZVF1ZXVlKHJ1blF1ZXVlKSB7XG4gICAgLypcbiAgICAgKiBCZWNhdXNlIHdlJ3JlIHVzaW5nIGEgcmVmIGFib3ZlLCB3ZSBuZWVkIHNvbWUgd2F5IHRvIGxldCBSZWFjdCBrbm93IHdoZW4gdG9cbiAgICAgKiBhY3R1YWxseSBwcm9jZXNzIHRoZSBxdWV1ZS4gV2UgaW5jcmVtZW50IHRoaXMgbnVtYmVyIGFueSB0aW1lIHdlIG11dGF0ZSB0aGVcbiAgICAgKiBxdWV1ZSwgY3JlYXRpbmcgYSBuZXcgc3RhdGUgdG8gdHJpZ2dlciB0aGUgbGF5b3V0IGVmZmVjdCBiZWxvdy5cbiAgICAgKiBVc2luZyBhIGJvb2xlYW4gZGlydHkgZmxhZyBoZXJlIGluc3RlYWQgd291bGQgbGVhZCB0byBpc3N1ZXMgcmVsYXRlZCB0b1xuICAgICAqIGF1dG9tYXRpYyBiYXRjaGluZy4gKGh0dHBzOi8vZ2l0aHViLmNvbS94eWZsb3cveHlmbG93L2lzc3Vlcy80Nzc5KVxuICAgICAqL1xuICAgIGNvbnN0IFtzZXJpYWwsIHNldFNlcmlhbF0gPSB1c2VTdGF0ZShCaWdJbnQoMCkpO1xuICAgIC8qXG4gICAgICogQSByZWZlcmVuY2Ugb2YgYWxsIHRoZSBiYXRjaGVkIHVwZGF0ZXMgdG8gcHJvY2VzcyBiZWZvcmUgdGhlIG5leHQgcmVuZGVyLiBXZVxuICAgICAqIHdhbnQgYSByZWZlcmVuY2UgaGVyZSBzbyBtdWx0aXBsZSBzeW5jaHJvbm91cyBjYWxscyB0byBgc2V0Tm9kZXNgIGV0YyBjYW4gYmVcbiAgICAgKiBiYXRjaGVkIHRvZ2V0aGVyLlxuICAgICAqL1xuICAgIGNvbnN0IFtxdWV1ZV0gPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGVRdWV1ZSgoKSA9PiBzZXRTZXJpYWwobiA9PiBuICsgQmlnSW50KDEpKSkpO1xuICAgIC8qXG4gICAgICogTGF5b3V0IGVmZmVjdHMgYXJlIGd1YXJhbnRlZWQgdG8gcnVuIGJlZm9yZSB0aGUgbmV4dCByZW5kZXIgd2hpY2ggbWVhbnMgd2VcbiAgICAgKiBzaG91bGRuJ3QgcnVuIGludG8gYW55IGlzc3VlcyB3aXRoIHN0YWxlIHN0YXRlIG9yIHdlaXJkIGlzc3VlcyB0aGF0IGNvbWUgZnJvbVxuICAgICAqIHJlbmRlcmluZyB0aGluZ3Mgb25lIGZyYW1lIGxhdGVyIHRoYW4gZXhwZWN0ZWQgKHdlIHVzZWQgdG8gdXNlIGBzZXRUaW1lb3V0YCkuXG4gICAgICovXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXVlSXRlbXMgPSBxdWV1ZS5nZXQoKTtcbiAgICAgICAgaWYgKHF1ZXVlSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBydW5RdWV1ZShxdWV1ZUl0ZW1zKTtcbiAgICAgICAgICAgIHF1ZXVlLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9LCBbc2VyaWFsXSk7XG4gICAgcmV0dXJuIHF1ZXVlO1xufVxuZnVuY3Rpb24gY3JlYXRlUXVldWUoY2IpIHtcbiAgICBsZXQgcXVldWUgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6ICgpID0+IHF1ZXVlLFxuICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgcHVzaDogKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goaXRlbSk7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmNvbnN0IEJhdGNoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcbiAqIFRoaXMgaXMgYSBjb250ZXh0IHByb3ZpZGVyIHRoYXQgaG9sZHMgYW5kIHByb2Nlc3NlcyB0aGUgbm9kZSBhbmQgZWRnZSB1cGRhdGUgcXVldWVzXG4gKiB0aGF0IGFyZSBuZWVkZWQgdG8gaGFuZGxlIHNldE5vZGVzLCBhZGROb2Rlcywgc2V0RWRnZXMgYW5kIGFkZEVkZ2VzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBCYXRjaFByb3ZpZGVyKHsgY2hpbGRyZW4sIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgbm9kZVF1ZXVlSGFuZGxlciA9IHVzZUNhbGxiYWNrKChxdWV1ZUl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgPSBbXSwgc2V0Tm9kZXMsIGhhc0RlZmF1bHROb2Rlcywgb25Ob2Rlc0NoYW5nZSwgbm9kZUxvb2t1cCwgZml0Vmlld1F1ZXVlZCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhpcyBpcyBlc3NlbnRpYWxseSBhbiBgQXJyYXkucmVkdWNlYCBpbiBpbXBlcmF0aXZlIGNsb3RoaW5nLiBQcm9jZXNzaW5nXG4gICAgICAgICAqIHRoaXMgcXVldWUgaXMgYSByZWxhdGl2ZWx5IGhvdCBwYXRoIHNvIHdlJ2QgbGlrZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWQgb2ZcbiAgICAgICAgICogYXJyYXkgbWV0aG9kcyB3aGVyZSB3ZSBjYW4uXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbmV4dCA9IG5vZGVzO1xuICAgICAgICBmb3IgKGNvbnN0IHBheWxvYWQgb2YgcXVldWVJdGVtcykge1xuICAgICAgICAgICAgbmV4dCA9IHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nID8gcGF5bG9hZChuZXh0KSA6IHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldEVsZW1lbnRzRGlmZkNoYW5nZXMoe1xuICAgICAgICAgICAgaXRlbXM6IG5leHQsXG4gICAgICAgICAgICBsb29rdXA6IG5vZGVMb29rdXAsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzRGVmYXVsdE5vZGVzKSB7XG4gICAgICAgICAgICBzZXROb2RlcyhuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gZmlyZSBvbk5vZGVzQ2hhbmdlIGlmIHRoZXJlIGFyZSBjaGFuZ2VzIHRvIHRoZSBub2Rlc1xuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvbk5vZGVzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZml0Vmlld1F1ZXVlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGNoYW5nZXMgdG8gdGhlIG5vZGVzLCB3ZSBzdGlsbCBuZWVkIHRvIGNhbGwgc2V0Tm9kZXNcbiAgICAgICAgICAgIC8vIHRvIHRyaWdnZXIgYSByZS1yZW5kZXIgYW5kIGZpdFZpZXcuXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZpdFZpZXdRdWV1ZWQsIG5vZGVzLCBzZXROb2RlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZml0Vmlld1F1ZXVlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXROb2Rlcyhub2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgbm9kZVF1ZXVlID0gdXNlUXVldWUobm9kZVF1ZXVlSGFuZGxlcik7XG4gICAgY29uc3QgZWRnZVF1ZXVlSGFuZGxlciA9IHVzZUNhbGxiYWNrKChxdWV1ZUl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWRnZXMgPSBbXSwgc2V0RWRnZXMsIGhhc0RlZmF1bHRFZGdlcywgb25FZGdlc0NoYW5nZSwgZWRnZUxvb2t1cCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgbGV0IG5leHQgPSBlZGdlcztcbiAgICAgICAgZm9yIChjb25zdCBwYXlsb2FkIG9mIHF1ZXVlSXRlbXMpIHtcbiAgICAgICAgICAgIG5leHQgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJyA/IHBheWxvYWQobmV4dCkgOiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIHNldEVkZ2VzKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9uRWRnZXNDaGFuZ2UpIHtcbiAgICAgICAgICAgIG9uRWRnZXNDaGFuZ2UoZ2V0RWxlbWVudHNEaWZmQ2hhbmdlcyh7XG4gICAgICAgICAgICAgICAgaXRlbXM6IG5leHQsXG4gICAgICAgICAgICAgICAgbG9va3VwOiBlZGdlTG9va3VwLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGVkZ2VRdWV1ZSA9IHVzZVF1ZXVlKGVkZ2VRdWV1ZUhhbmRsZXIpO1xuICAgIGNvbnN0IHZhbHVlID0gdXNlTWVtbygoKSA9PiAoeyBub2RlUXVldWUsIGVkZ2VRdWV1ZSB9KSwgW10pO1xuICAgIHJldHVybiBqc3goQmF0Y2hDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2YWx1ZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xufVxuZnVuY3Rpb24gdXNlQmF0Y2hDb250ZXh0KCkge1xuICAgIGNvbnN0IGJhdGNoQ29udGV4dCA9IHVzZUNvbnRleHQoQmF0Y2hDb250ZXh0KTtcbiAgICBpZiAoIWJhdGNoQ29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUJhdGNoQ29udGV4dCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgQmF0Y2hQcm92aWRlcicpO1xuICAgIH1cbiAgICByZXR1cm4gYmF0Y2hDb250ZXh0O1xufVxuXG5jb25zdCBzZWxlY3RvciRrID0gKHMpID0+ICEhcy5wYW5ab29tO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhIFJlYWN0Rmxvd0luc3RhbmNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIG5vZGVzIGFuZCBlZGdlcywgbWFuaXB1bGF0ZSB0aGUgdmlld3BvcnQsIG9yIHF1ZXJ5IHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBmbG93LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyB1c2VSZWFjdEZsb3cgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBmdW5jdGlvbiBOb2RlQ291bnRlcigpIHtcbiAqICBjb25zdCByZWFjdEZsb3cgPSB1c2VSZWFjdEZsb3coKTtcbiAqICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDApO1xuICogIGNvbnN0IGNvdW50Tm9kZXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gKiAgICBzZXRDb3VudChyZWFjdEZsb3cuZ2V0Tm9kZXMoKS5sZW5ndGgpO1xuICogICAgLy8geW91IG5lZWQgdG8gcGFzcyBpdCBhcyBhIGRlcGVuZGVuY3kgaWYgeW91IGFyZSB1c2luZyBpdCB3aXRoIHVzZUVmZmVjdCBvciB1c2VDYWxsYmFja1xuICogICAgLy8gYmVjYXVzZSBhdCB0aGUgZmlyc3QgcmVuZGVyLCBpdCdzIG5vdCBpbml0aWFsaXplZCB5ZXQgYW5kIHNvbWUgZnVuY3Rpb25zIG1pZ2h0IG5vdCB3b3JrLlxuICogIH0sIFtyZWFjdEZsb3ddKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAgIDxidXR0b24gb25DbGljaz17Y291bnROb2Rlc30+VXBkYXRlIGNvdW50PC9idXR0b24+XG4gKiAgICAgIDxwPlRoZXJlIGFyZSB7Y291bnR9IG5vZGVzIGluIHRoZSBmbG93LjwvcD5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZVJlYWN0RmxvdygpIHtcbiAgICBjb25zdCB2aWV3cG9ydEhlbHBlciA9IHVzZVZpZXdwb3J0SGVscGVyKCk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGJhdGNoQ29udGV4dCA9IHVzZUJhdGNoQ29udGV4dCgpO1xuICAgIGNvbnN0IHZpZXdwb3J0SW5pdGlhbGl6ZWQgPSB1c2VTdG9yZShzZWxlY3RvciRrKTtcbiAgICBjb25zdCBnZW5lcmFsSGVscGVyID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGdldEludGVybmFsTm9kZSA9IChpZCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgIGNvbnN0IHNldE5vZGVzID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGJhdGNoQ29udGV4dC5ub2RlUXVldWUucHVzaChwYXlsb2FkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2V0RWRnZXMgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgYmF0Y2hDb250ZXh0LmVkZ2VRdWV1ZS5wdXNoKHBheWxvYWQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnZXROb2RlUmVjdCA9IChub2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIG5vZGVPcmlnaW4gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBub2RlVG9Vc2UgPSBpc05vZGUobm9kZSkgPyBub2RlIDogbm9kZUxvb2t1cC5nZXQobm9kZS5pZCk7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IG5vZGVUb1VzZS5wYXJlbnRJZFxuICAgICAgICAgICAgICAgID8gZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uKG5vZGVUb1VzZS5wb3NpdGlvbiwgbm9kZVRvVXNlLm1lYXN1cmVkLCBub2RlVG9Vc2UucGFyZW50SWQsIG5vZGVMb29rdXAsIG5vZGVPcmlnaW4pXG4gICAgICAgICAgICAgICAgOiBub2RlVG9Vc2UucG9zaXRpb247XG4gICAgICAgICAgICBjb25zdCBub2RlV2l0aFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIC4uLm5vZGVUb1VzZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICB3aWR0aDogbm9kZVRvVXNlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlVG9Vc2Uud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlVG9Vc2UubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlVG9Vc2UuaGVpZ2h0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBub2RlVG9SZWN0KG5vZGVXaXRoUG9zaXRpb24pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cGRhdGVOb2RlID0gKGlkLCBub2RlVXBkYXRlLCBvcHRpb25zID0geyByZXBsYWNlOiBmYWxzZSB9KSA9PiB7XG4gICAgICAgICAgICBzZXROb2RlcygocHJldk5vZGVzKSA9PiBwcmV2Tm9kZXMubWFwKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gdHlwZW9mIG5vZGVVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBub2RlVXBkYXRlKG5vZGUpIDogbm9kZVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSAmJiBpc05vZGUobmV4dE5vZGUpID8gbmV4dE5vZGUgOiB7IC4uLm5vZGUsIC4uLm5leHROb2RlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cGRhdGVFZGdlID0gKGlkLCBlZGdlVXBkYXRlLCBvcHRpb25zID0geyByZXBsYWNlOiBmYWxzZSB9KSA9PiB7XG4gICAgICAgICAgICBzZXRFZGdlcygocHJldkVkZ2VzKSA9PiBwcmV2RWRnZXMubWFwKChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2UuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRFZGdlID0gdHlwZW9mIGVkZ2VVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBlZGdlVXBkYXRlKGVkZ2UpIDogZWRnZVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSAmJiBpc0VkZ2UobmV4dEVkZ2UpID8gbmV4dEVkZ2UgOiB7IC4uLmVkZ2UsIC4uLm5leHRFZGdlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlZGdlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0Tm9kZXM6ICgpID0+IHN0b3JlLmdldFN0YXRlKCkubm9kZXMubWFwKChuKSA9PiAoeyAuLi5uIH0pKSxcbiAgICAgICAgICAgIGdldE5vZGU6IChpZCkgPT4gZ2V0SW50ZXJuYWxOb2RlKGlkKT8uaW50ZXJuYWxzLnVzZXJOb2RlLFxuICAgICAgICAgICAgZ2V0SW50ZXJuYWxOb2RlLFxuICAgICAgICAgICAgZ2V0RWRnZXM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVkZ2VzID0gW10gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkZ2VzLm1hcCgoZSkgPT4gKHsgLi4uZSB9KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RWRnZTogKGlkKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLmVkZ2VMb29rdXAuZ2V0KGlkKSxcbiAgICAgICAgICAgIHNldE5vZGVzLFxuICAgICAgICAgICAgc2V0RWRnZXMsXG4gICAgICAgICAgICBhZGROb2RlczogKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdOb2RlcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkIDogW3BheWxvYWRdO1xuICAgICAgICAgICAgICAgIGJhdGNoQ29udGV4dC5ub2RlUXVldWUucHVzaCgobm9kZXMpID0+IFsuLi5ub2RlcywgLi4ubmV3Tm9kZXNdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRFZGdlczogKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFZGdlcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkIDogW3BheWxvYWRdO1xuICAgICAgICAgICAgICAgIGJhdGNoQ29udGV4dC5lZGdlUXVldWUucHVzaCgoZWRnZXMpID0+IFsuLi5lZGdlcywgLi4ubmV3RWRnZXNdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b09iamVjdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXMgPSBbXSwgZWRnZXMgPSBbXSwgdHJhbnNmb3JtIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4LCB5LCB6b29tXSA9IHRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBub2Rlczogbm9kZXMubWFwKChuKSA9PiAoeyAuLi5uIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZXM6IGVkZ2VzLm1hcCgoZSkgPT4gKHsgLi4uZSB9KSksXG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb20sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVFbGVtZW50czogYXN5bmMgKHsgbm9kZXM6IG5vZGVzVG9SZW1vdmUgPSBbXSwgZWRnZXM6IGVkZ2VzVG9SZW1vdmUgPSBbXSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlcywgZWRnZXMsIG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGUsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzLCBvbkRlbGV0ZSwgb25CZWZvcmVEZWxldGUsIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXM6IG1hdGNoaW5nTm9kZXMsIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzIH0gPSBhd2FpdCBnZXRFbGVtZW50c1RvUmVtb3ZlKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1JlbW92ZSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZXNUb1JlbW92ZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZURlbGV0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNNYXRjaGluZ0VkZ2VzID0gbWF0Y2hpbmdFZGdlcy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc01hdGNoaW5nTm9kZXMgPSBtYXRjaGluZ05vZGVzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhhc01hdGNoaW5nRWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWRnZUNoYW5nZXMgPSBtYXRjaGluZ0VkZ2VzLm1hcChlbGVtZW50VG9SZW1vdmVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBvbkVkZ2VzRGVsZXRlPy4obWF0Y2hpbmdFZGdlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhlZGdlQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNNYXRjaGluZ05vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVDaGFuZ2VzID0gbWF0Y2hpbmdOb2Rlcy5tYXAoZWxlbWVudFRvUmVtb3ZlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgb25Ob2Rlc0RlbGV0ZT8uKG1hdGNoaW5nTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWF0Y2hpbmdOb2RlcyB8fCBoYXNNYXRjaGluZ0VkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGVsZXRlPy4oeyBub2RlczogbWF0Y2hpbmdOb2RlcywgZWRnZXM6IG1hdGNoaW5nRWRnZXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRlbGV0ZWROb2RlczogbWF0Y2hpbmdOb2RlcywgZGVsZXRlZEVkZ2VzOiBtYXRjaGluZ0VkZ2VzIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SW50ZXJzZWN0aW5nTm9kZXM6IChub2RlT3JSZWN0LCBwYXJ0aWFsbHkgPSB0cnVlLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVjdCA9IGlzUmVjdE9iamVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlUmVjdCA9IGlzUmVjdCA/IG5vZGVPclJlY3QgOiBnZXROb2RlUmVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNOb2Rlc09wdGlvbiA9IG5vZGVzICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAobm9kZXMgfHwgc3RvcmUuZ2V0U3RhdGUoKS5ub2RlcykuZmlsdGVyKChuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsTm9kZSA9IHN0b3JlLmdldFN0YXRlKCkubm9kZUxvb2t1cC5nZXQobi5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbE5vZGUgJiYgIWlzUmVjdCAmJiAobi5pZCA9PT0gbm9kZU9yUmVjdC5pZCB8fCAhaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJOb2RlUmVjdCA9IG5vZGVUb1JlY3QoaGFzTm9kZXNPcHRpb24gPyBuIDogaW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdBcmVhID0gZ2V0T3ZlcmxhcHBpbmdBcmVhKGN1cnJOb2RlUmVjdCwgbm9kZVJlY3QpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsbHlWaXNpYmxlIHx8IG92ZXJsYXBwaW5nQXJlYSA+PSBub2RlUmVjdC53aWR0aCAqIG5vZGVSZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc05vZGVJbnRlcnNlY3Rpbmc6IChub2RlT3JSZWN0LCBhcmVhLCBwYXJ0aWFsbHkgPSB0cnVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZWN0ID0gaXNSZWN0T2JqZWN0KG5vZGVPclJlY3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVSZWN0ID0gaXNSZWN0ID8gbm9kZU9yUmVjdCA6IGdldE5vZGVSZWN0KG5vZGVPclJlY3QpO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZVJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBnZXRPdmVybGFwcGluZ0FyZWEobm9kZVJlY3QsIGFyZWEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxseVZpc2libGUgPSBwYXJ0aWFsbHkgJiYgb3ZlcmxhcHBpbmdBcmVhID4gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydGlhbGx5VmlzaWJsZSB8fCBvdmVybGFwcGluZ0FyZWEgPj0gbm9kZVJlY3Qud2lkdGggKiBub2RlUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlTm9kZSxcbiAgICAgICAgICAgIHVwZGF0ZU5vZGVEYXRhOiAoaWQsIGRhdGFVcGRhdGUsIG9wdGlvbnMgPSB7IHJlcGxhY2U6IGZhbHNlIH0pID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVOb2RlKGlkLCAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGF0YSA9IHR5cGVvZiBkYXRhVXBkYXRlID09PSAnZnVuY3Rpb24nID8gZGF0YVVwZGF0ZShub2RlKSA6IGRhdGFVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgPyB7IC4uLm5vZGUsIGRhdGE6IG5leHREYXRhIH0gOiB7IC4uLm5vZGUsIGRhdGE6IHsgLi4ubm9kZS5kYXRhLCAuLi5uZXh0RGF0YSB9IH07XG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlRWRnZSxcbiAgICAgICAgICAgIHVwZGF0ZUVkZ2VEYXRhOiAoaWQsIGRhdGFVcGRhdGUsIG9wdGlvbnMgPSB7IHJlcGxhY2U6IGZhbHNlIH0pID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVFZGdlKGlkLCAoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGF0YSA9IHR5cGVvZiBkYXRhVXBkYXRlID09PSAnZnVuY3Rpb24nID8gZGF0YVVwZGF0ZShlZGdlKSA6IGRhdGFVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgPyB7IC4uLmVkZ2UsIGRhdGE6IG5leHREYXRhIH0gOiB7IC4uLmVkZ2UsIGRhdGE6IHsgLi4uZWRnZS5kYXRhLCAuLi5uZXh0RGF0YSB9IH07XG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Tm9kZXNCb3VuZHM6IChub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Tm9kZXNCb3VuZHMobm9kZXMsIHsgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRIYW5kbGVDb25uZWN0aW9uczogKHsgdHlwZSwgaWQsIG5vZGVJZCB9KSA9PiBBcnJheS5mcm9tKHN0b3JlXG4gICAgICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgICAgICAuY29ubmVjdGlvbkxvb2t1cC5nZXQoYCR7bm9kZUlkfS0ke3R5cGV9JHtpZCA/IGAtJHtpZH1gIDogJyd9YClcbiAgICAgICAgICAgICAgICA/LnZhbHVlcygpID8/IFtdKSxcbiAgICAgICAgICAgIGdldE5vZGVDb25uZWN0aW9uczogKHsgdHlwZSwgaGFuZGxlSWQsIG5vZGVJZCB9KSA9PiBBcnJheS5mcm9tKHN0b3JlXG4gICAgICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgICAgICAuY29ubmVjdGlvbkxvb2t1cC5nZXQoYCR7bm9kZUlkfSR7dHlwZSA/IChoYW5kbGVJZCA/IGAtJHt0eXBlfS0ke2hhbmRsZUlkfWAgOiBgLSR7dHlwZX1gKSA6ICcnfWApXG4gICAgICAgICAgICAgICAgPy52YWx1ZXMoKSA/PyBbXSksXG4gICAgICAgICAgICBmaXRWaWV3OiBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdlIGVpdGhlciBjcmVhdGUgYSBuZXcgUHJvbWlzZSBvciByZXVzZSB0aGUgZXhpc3Rpbmcgb25lXG4gICAgICAgICAgICAgICAgLy8gRXZlbiBpZiBmaXRWaWV3IGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbiBhIHJvdywgd2Ugb25seSBlbmQgdXAgd2l0aCBhIHNpbmdsZSBQcm9taXNlXG4gICAgICAgICAgICAgICAgY29uc3QgZml0Vmlld1Jlc29sdmVyID0gc3RvcmUuZ2V0U3RhdGUoKS5maXRWaWV3UmVzb2x2ZXIgPz8gd2l0aFJlc29sdmVycygpO1xuICAgICAgICAgICAgICAgIC8vIFdlIHNjaGVkdWxlIGEgZml0VmlldyBieSBzZXR0aW5nIGZpdFZpZXdRdWV1ZWQgYW5kIHRyaWdnZXJpbmcgYSBzZXROb2Rlc1xuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgZml0Vmlld1F1ZXVlZDogdHJ1ZSwgZml0Vmlld09wdGlvbnM6IG9wdGlvbnMsIGZpdFZpZXdSZXNvbHZlciB9KTtcbiAgICAgICAgICAgICAgICBiYXRjaENvbnRleHQubm9kZVF1ZXVlLnB1c2goKG5vZGVzKSA9PiBbLi4ubm9kZXNdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml0Vmlld1Jlc29sdmVyLnByb21pc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5nZW5lcmFsSGVscGVyLFxuICAgICAgICAgICAgLi4udmlld3BvcnRIZWxwZXIsXG4gICAgICAgICAgICB2aWV3cG9ydEluaXRpYWxpemVkLFxuICAgICAgICB9O1xuICAgIH0sIFt2aWV3cG9ydEluaXRpYWxpemVkXSk7XG59XG5cbmNvbnN0IHNlbGVjdGVkID0gKGl0ZW0pID0+IGl0ZW0uc2VsZWN0ZWQ7XG5jb25zdCB3aW4kMSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xuLyoqXG4gKiBIb29rIGZvciBoYW5kbGluZyBnbG9iYWwga2V5IGV2ZW50cy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlR2xvYmFsS2V5SGFuZGxlcih7IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IGRlbGV0ZUVsZW1lbnRzIH0gPSB1c2VSZWFjdEZsb3coKTtcbiAgICBjb25zdCBkZWxldGVLZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MoZGVsZXRlS2V5Q29kZSwgeyBhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcjogZmFsc2UgfSk7XG4gICAgY29uc3QgbXVsdGlTZWxlY3Rpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MobXVsdGlTZWxlY3Rpb25LZXlDb2RlLCB7IHRhcmdldDogd2luJDEgfSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGRlbGV0ZUtleVByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRnZXMsIG5vZGVzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgZGVsZXRlRWxlbWVudHMoeyBub2Rlczogbm9kZXMuZmlsdGVyKHNlbGVjdGVkKSwgZWRnZXM6IGVkZ2VzLmZpbHRlcihzZWxlY3RlZCkgfSk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtkZWxldGVLZXlQcmVzc2VkXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBtdWx0aVNlbGVjdGlvbkFjdGl2ZTogbXVsdGlTZWxlY3Rpb25LZXlQcmVzc2VkIH0pO1xuICAgIH0sIFttdWx0aVNlbGVjdGlvbktleVByZXNzZWRdKTtcbn1cblxuLyoqXG4gKiBIb29rIGZvciBoYW5kbGluZyByZXNpemUgZXZlbnRzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VSZXNpemVIYW5kbGVyKGRvbU5vZGUpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlRGltZW5zaW9ucyA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghZG9tTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGdldERpbWVuc2lvbnMoZG9tTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIGlmIChzaXplLmhlaWdodCA9PT0gMCB8fCBzaXplLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAwNCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA0J10oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHdpZHRoOiBzaXplLndpZHRoIHx8IDUwMCwgaGVpZ2h0OiBzaXplLmhlaWdodCB8fCA1MDAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkb21Ob2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHVwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHVwZGF0ZURpbWVuc2lvbnMoKSk7XG4gICAgICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGRvbU5vZGUuY3VycmVudCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzaXplT2JzZXJ2ZXIgJiYgZG9tTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG59XG5cbmNvbnN0IGNvbnRhaW5lclN0eWxlID0ge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG59O1xuXG5jb25zdCBzZWxlY3RvciRqID0gKHMpID0+ICh7XG4gICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgIGxpYjogcy5saWIsXG59KTtcbmZ1bmN0aW9uIFpvb21QYW5lKHsgb25QYW5lQ29udGV4dE1lbnUsIHpvb21PblNjcm9sbCA9IHRydWUsIHpvb21PblBpbmNoID0gdHJ1ZSwgcGFuT25TY3JvbGwgPSBmYWxzZSwgcGFuT25TY3JvbGxTcGVlZCA9IDAuNSwgcGFuT25TY3JvbGxNb2RlID0gUGFuT25TY3JvbGxNb2RlLkZyZWUsIHpvb21PbkRvdWJsZUNsaWNrID0gdHJ1ZSwgcGFuT25EcmFnID0gdHJ1ZSwgZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb20sIG1heFpvb20sIHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgcHJldmVudFNjcm9sbGluZyA9IHRydWUsIGNoaWxkcmVuLCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnQsIHBhbmVDbGlja0Rpc3RhbmNlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHpvb21QYW5lID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvbkFjdGl2ZSwgbGliIH0gPSB1c2VTdG9yZShzZWxlY3RvciRqLCBzaGFsbG93KTtcbiAgICBjb25zdCB6b29tQWN0aXZhdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyh6b29tQWN0aXZhdGlvbktleUNvZGUpO1xuICAgIGNvbnN0IHBhblpvb20gPSB1c2VSZWYoKTtcbiAgICB1c2VSZXNpemVIYW5kbGVyKHpvb21QYW5lKTtcbiAgICBjb25zdCBvblRyYW5zZm9ybUNoYW5nZSA9IHVzZUNhbGxiYWNrKCh0cmFuc2Zvcm0pID0+IHtcbiAgICAgICAgb25WaWV3cG9ydENoYW5nZT8uKHsgeDogdHJhbnNmb3JtWzBdLCB5OiB0cmFuc2Zvcm1bMV0sIHpvb206IHRyYW5zZm9ybVsyXSB9KTtcbiAgICAgICAgaWYgKCFpc0NvbnRyb2xsZWRWaWV3cG9ydCkge1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyB0cmFuc2Zvcm0gfSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoem9vbVBhbmUuY3VycmVudCkge1xuICAgICAgICAgICAgcGFuWm9vbS5jdXJyZW50ID0gWFlQYW5ab29tKHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiB6b29tUGFuZS5jdXJyZW50LFxuICAgICAgICAgICAgICAgIG1pblpvb20sXG4gICAgICAgICAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgdmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCxcbiAgICAgICAgICAgICAgICBwYW5lQ2xpY2tEaXN0YW5jZSxcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlOiAocGFuZURyYWdnaW5nKSA9PiBzdG9yZS5zZXRTdGF0ZSh7IHBhbmVEcmFnZ2luZyB9KSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21TdGFydDogKGV2ZW50LCB2cCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9uVmlld3BvcnRDaGFuZ2VTdGFydCwgb25Nb3ZlU3RhcnQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uTW92ZVN0YXJ0Py4oZXZlbnQsIHZwKTtcbiAgICAgICAgICAgICAgICAgICAgb25WaWV3cG9ydENoYW5nZVN0YXJ0Py4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25QYW5ab29tOiAoZXZlbnQsIHZwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZSwgb25Nb3ZlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBvbk1vdmU/LihldmVudCwgdnApO1xuICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlPy4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kOiAoZXZlbnQsIHZwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZUVuZCwgb25Nb3ZlRW5kIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBvbk1vdmVFbmQ/LihldmVudCwgdnApO1xuICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlRW5kPy4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gcGFuWm9vbS5jdXJyZW50LmdldFZpZXdwb3J0KCk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgcGFuWm9vbTogcGFuWm9vbS5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogW3gsIHksIHpvb21dLFxuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHpvb21QYW5lLmN1cnJlbnQuY2xvc2VzdCgnLnJlYWN0LWZsb3cnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBwYW5ab29tLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcGFuWm9vbS5jdXJyZW50Py51cGRhdGUoe1xuICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnUsXG4gICAgICAgICAgICB6b29tT25TY3JvbGwsXG4gICAgICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICAgICAgcGFuT25TY3JvbGxTcGVlZCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsTW9kZSxcbiAgICAgICAgICAgIHpvb21PbkRvdWJsZUNsaWNrLFxuICAgICAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICAgICAgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLFxuICAgICAgICAgICAgcHJldmVudFNjcm9sbGluZyxcbiAgICAgICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICAgICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBvblRyYW5zZm9ybUNoYW5nZSxcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBvblBhbmVDb250ZXh0TWVudSxcbiAgICAgICAgem9vbU9uU2Nyb2xsLFxuICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgcGFuT25TY3JvbGwsXG4gICAgICAgIHBhbk9uU2Nyb2xsU3BlZWQsXG4gICAgICAgIHBhbk9uU2Nyb2xsTW9kZSxcbiAgICAgICAgem9vbU9uRG91YmxlQ2xpY2ssXG4gICAgICAgIHBhbk9uRHJhZyxcbiAgICAgICAgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsaW5nLFxuICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgbGliLFxuICAgICAgICBvblRyYW5zZm9ybUNoYW5nZSxcbiAgICBdKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19yZW5kZXJlclwiLCByZWY6IHpvb21QYW5lLCBzdHlsZTogY29udGFpbmVyU3R5bGUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJGkgPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgdXNlclNlbGVjdGlvblJlY3Q6IHMudXNlclNlbGVjdGlvblJlY3QsXG59KTtcbmZ1bmN0aW9uIFVzZXJTZWxlY3Rpb24oKSB7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCB1c2VyU2VsZWN0aW9uUmVjdCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkaSwgc2hhbGxvdyk7XG4gICAgY29uc3QgaXNBY3RpdmUgPSB1c2VyU2VsZWN0aW9uQWN0aXZlICYmIHVzZXJTZWxlY3Rpb25SZWN0O1xuICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3NlbGVjdGlvbiByZWFjdC1mbG93X19jb250YWluZXJcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiB1c2VyU2VsZWN0aW9uUmVjdC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdXNlclNlbGVjdGlvblJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7dXNlclNlbGVjdGlvblJlY3QueH1weCwgJHt1c2VyU2VsZWN0aW9uUmVjdC55fXB4KWAsXG4gICAgICAgIH0gfSkpO1xufVxuXG5jb25zdCB3cmFwSGFuZGxlciA9IChoYW5kbGVyLCBjb250YWluZXJSZWYpID0+IHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlcj8uKGV2ZW50KTtcbiAgICB9O1xufTtcbmNvbnN0IHNlbGVjdG9yJGggPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBjb25uZWN0aW9uSW5Qcm9ncmVzczogcy5jb25uZWN0aW9uLmluUHJvZ3Jlc3MsXG4gICAgZHJhZ2dpbmc6IHMucGFuZURyYWdnaW5nLFxufSk7XG5mdW5jdGlvbiBQYW5lKHsgaXNTZWxlY3RpbmcsIHNlbGVjdGlvbktleVByZXNzZWQsIHNlbGVjdGlvbk1vZGUgPSBTZWxlY3Rpb25Nb2RlLkZ1bGwsIHBhbk9uRHJhZywgc2VsZWN0aW9uT25EcmFnLCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgb25QYW5lQ2xpY2ssIG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGwsIG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZSwgY2hpbGRyZW4sIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCBlbGVtZW50c1NlbGVjdGFibGUsIGRyYWdnaW5nLCBjb25uZWN0aW9uSW5Qcm9ncmVzcyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkaCwgc2hhbGxvdyk7XG4gICAgY29uc3QgaGFzQWN0aXZlU2VsZWN0aW9uID0gZWxlbWVudHNTZWxlY3RhYmxlICYmIChpc1NlbGVjdGluZyB8fCB1c2VyU2VsZWN0aW9uQWN0aXZlKTtcbiAgICBjb25zdCBjb250YWluZXIgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY29udGFpbmVyQm91bmRzID0gdXNlUmVmKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlSWRzID0gdXNlUmVmKG5ldyBTZXQoKSk7XG4gICAgY29uc3Qgc2VsZWN0ZWRFZGdlSWRzID0gdXNlUmVmKG5ldyBTZXQoKSk7XG4gICAgLy8gVXNlZCB0byBwcmV2ZW50IGNsaWNrIGV2ZW50cyB3aGVuIHRoZSB1c2VyIGxldHMgZ28gb2YgdGhlIHNlbGVjdGlvbktleSBkdXJpbmcgYSBzZWxlY3Rpb25cbiAgICBjb25zdCBzZWxlY3Rpb25JblByb2dyZXNzID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBzZWxlY3Rpb25TdGFydGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBvbkNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIFdlIHByZXZlbnQgY2xpY2sgZXZlbnRzIHdoZW4gdGhlIHVzZXIgbGV0IGdvIG9mIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIGEgc2VsZWN0aW9uXG4gICAgICAgIC8vIFdlIGFsc28gcHJldmVudCBjbGljayBldmVudHMgd2hlbiBhIGNvbm5lY3Rpb24gaXMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgaWYgKHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCB8fCBjb25uZWN0aW9uSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25QYW5lQ2xpY2s/LihldmVudCk7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkucmVzZXRTZWxlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25Db250ZXh0TWVudSA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZz8uaW5jbHVkZXMoMikpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25QYW5lQ29udGV4dE1lbnU/LihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBvbldoZWVsID0gb25QYW5lU2Nyb2xsID8gKGV2ZW50KSA9PiBvblBhbmVTY3JvbGwoZXZlbnQpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uUG9pbnRlckRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXNldFNlbGVjdGVkRWxlbWVudHMsIGRvbU5vZGUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnRhaW5lckJvdW5kcy5jdXJyZW50ID0gZG9tTm9kZT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmICghZWxlbWVudHNTZWxlY3RhYmxlIHx8XG4gICAgICAgICAgICAhaXNTZWxlY3RpbmcgfHxcbiAgICAgICAgICAgIGV2ZW50LmJ1dHRvbiAhPT0gMCB8fFxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ICE9PSBjb250YWluZXIuY3VycmVudCB8fFxuICAgICAgICAgICAgIWNvbnRhaW5lckJvdW5kcy5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQudGFyZ2V0Py5zZXRQb2ludGVyQ2FwdHVyZT8uKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIHNlbGVjdGlvblN0YXJ0ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQubmF0aXZlRXZlbnQsIGNvbnRhaW5lckJvdW5kcy5jdXJyZW50KTtcbiAgICAgICAgcmVzZXRTZWxlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25SZWN0OiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0WDogeCxcbiAgICAgICAgICAgICAgICBzdGFydFk6IHksXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uU2VsZWN0aW9uU3RhcnQ/LihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvblJlY3QsIHRyYW5zZm9ybSwgbm9kZUxvb2t1cCwgZWRnZUxvb2t1cCwgY29ubmVjdGlvbkxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMsIGRlZmF1bHRFZGdlT3B0aW9ucywgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghY29udGFpbmVyQm91bmRzLmN1cnJlbnQgfHwgIXVzZXJTZWxlY3Rpb25SZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyB4OiBtb3VzZVgsIHk6IG1vdXNlWSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5uYXRpdmVFdmVudCwgY29udGFpbmVyQm91bmRzLmN1cnJlbnQpO1xuICAgICAgICBjb25zdCB7IHN0YXJ0WCwgc3RhcnRZIH0gPSB1c2VyU2VsZWN0aW9uUmVjdDtcbiAgICAgICAgY29uc3QgbmV4dFVzZXJTZWxlY3RSZWN0ID0ge1xuICAgICAgICAgICAgc3RhcnRYLFxuICAgICAgICAgICAgc3RhcnRZLFxuICAgICAgICAgICAgeDogbW91c2VYIDwgc3RhcnRYID8gbW91c2VYIDogc3RhcnRYLFxuICAgICAgICAgICAgeTogbW91c2VZIDwgc3RhcnRZID8gbW91c2VZIDogc3RhcnRZLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGguYWJzKG1vdXNlWCAtIHN0YXJ0WCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGguYWJzKG1vdXNlWSAtIHN0YXJ0WSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3RlZE5vZGVJZHMgPSBzZWxlY3RlZE5vZGVJZHMuY3VycmVudDtcbiAgICAgICAgY29uc3QgcHJldlNlbGVjdGVkRWRnZUlkcyA9IHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50O1xuICAgICAgICBzZWxlY3RlZE5vZGVJZHMuY3VycmVudCA9IG5ldyBTZXQoZ2V0Tm9kZXNJbnNpZGUobm9kZUxvb2t1cCwgbmV4dFVzZXJTZWxlY3RSZWN0LCB0cmFuc2Zvcm0sIHNlbGVjdGlvbk1vZGUgPT09IFNlbGVjdGlvbk1vZGUuUGFydGlhbCwgdHJ1ZSkubWFwKChub2RlKSA9PiBub2RlLmlkKSk7XG4gICAgICAgIHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50ID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBlZGdlc1NlbGVjdGFibGUgPSBkZWZhdWx0RWRnZU9wdGlvbnM/LnNlbGVjdGFibGUgPz8gdHJ1ZTtcbiAgICAgICAgLy8gV2UgbG9vayBmb3IgYWxsIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgc2VsZWN0ZWQgbm9kZXNcbiAgICAgICAgZm9yIChjb25zdCBub2RlSWQgb2Ygc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gY29ubmVjdGlvbkxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGlvbnMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgZWRnZUlkIH0gb2YgY29ubmVjdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGdlID0gZWRnZUxvb2t1cC5nZXQoZWRnZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZSAmJiAoZWRnZS5zZWxlY3RhYmxlID8/IGVkZ2VzU2VsZWN0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQuYWRkKGVkZ2VJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYXJlU2V0c0VxdWFsKHByZXZTZWxlY3RlZE5vZGVJZHMsIHNlbGVjdGVkTm9kZUlkcy5jdXJyZW50KSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMobm9kZUxvb2t1cCwgc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQsIHRydWUpO1xuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXJlU2V0c0VxdWFsKHByZXZTZWxlY3RlZEVkZ2VJZHMsIHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50KSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMoZWRnZUxvb2t1cCwgc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25SZWN0OiBuZXh0VXNlclNlbGVjdFJlY3QsXG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUG9pbnRlclVwID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgIXNlbGVjdGlvblN0YXJ0ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnRhcmdldD8ucmVsZWFzZVBvaW50ZXJDYXB0dXJlPy4oZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uUmVjdCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgLypcbiAgICAgICAgICogV2Ugb25seSB3YW50IHRvIHRyaWdnZXIgY2xpY2sgZnVuY3Rpb25zIHdoZW4gaW4gc2VsZWN0aW9uIG1vZGUgaWZcbiAgICAgICAgICogdGhlIHVzZXIgZGlkIG5vdCBtb3ZlIHRoZSBtb3VzZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghdXNlclNlbGVjdGlvbkFjdGl2ZSAmJiB1c2VyU2VsZWN0aW9uUmVjdCAmJiBldmVudC50YXJnZXQgPT09IGNvbnRhaW5lci5jdXJyZW50KSB7XG4gICAgICAgICAgICBvbkNsaWNrPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IG51bGwsXG4gICAgICAgICAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQuc2l6ZSA+IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBvblNlbGVjdGlvbkVuZD8uKGV2ZW50KTtcbiAgICAgICAgLypcbiAgICAgICAgICogSWYgdGhlIHVzZXIga2VwdCBob2xkaW5nIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIHRoZSBzZWxlY3Rpb24sXG4gICAgICAgICAqIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHNlbGVjdGlvbkluUHJvZ3Jlc3MsIHNvIHRoZSBuZXh0IGNsaWNrIGV2ZW50IGlzIG5vdCBwcmV2ZW50ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlmIChzZWxlY3Rpb25LZXlQcmVzc2VkIHx8IHNlbGVjdGlvbk9uRHJhZykge1xuICAgICAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uU3RhcnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBkcmFnZ2FibGUgPSBwYW5PbkRyYWcgPT09IHRydWUgfHwgKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoMCkpO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19wYW5lJywgeyBkcmFnZ2FibGUsIGRyYWdnaW5nLCBzZWxlY3Rpb246IGlzU2VsZWN0aW5nIH1dKSwgb25DbGljazogaGFzQWN0aXZlU2VsZWN0aW9uID8gdW5kZWZpbmVkIDogd3JhcEhhbmRsZXIob25DbGljaywgY29udGFpbmVyKSwgb25Db250ZXh0TWVudTogd3JhcEhhbmRsZXIob25Db250ZXh0TWVudSwgY29udGFpbmVyKSwgb25XaGVlbDogd3JhcEhhbmRsZXIob25XaGVlbCwgY29udGFpbmVyKSwgb25Qb2ludGVyRW50ZXI6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IHVuZGVmaW5lZCA6IG9uUGFuZU1vdXNlRW50ZXIsIG9uUG9pbnRlckRvd246IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uUG9pbnRlckRvd24gOiBvblBhbmVNb3VzZU1vdmUsIG9uUG9pbnRlck1vdmU6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uUG9pbnRlck1vdmUgOiBvblBhbmVNb3VzZU1vdmUsIG9uUG9pbnRlclVwOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyBvblBvaW50ZXJVcCA6IHVuZGVmaW5lZCwgb25Qb2ludGVyTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIHJlZjogY29udGFpbmVyLCBzdHlsZTogY29udGFpbmVyU3R5bGUsIGNoaWxkcmVuOiBbY2hpbGRyZW4sIGpzeChVc2VyU2VsZWN0aW9uLCB7fSldIH0pKTtcbn1cblxuLypcbiAqIHRoaXMgaGFuZGxlciBpcyBjYWxsZWQgYnlcbiAqIDEuIHRoZSBjbGljayBoYW5kbGVyIHdoZW4gbm9kZSBpcyBub3QgZHJhZ2dhYmxlIG9yIHNlbGVjdE5vZGVzT25EcmFnID0gZmFsc2VcbiAqIG9yXG4gKiAyLiB0aGUgb24gZHJhZyBzdGFydCBoYW5kbGVyIHdoZW4gbm9kZSBpcyBkcmFnZ2FibGUgYW5kIHNlbGVjdE5vZGVzT25EcmFnID0gdHJ1ZVxuICovXG5mdW5jdGlvbiBoYW5kbGVOb2RlQ2xpY2soeyBpZCwgc3RvcmUsIHVuc2VsZWN0ID0gZmFsc2UsIG5vZGVSZWYsIH0pIHtcbiAgICBjb25zdCB7IGFkZFNlbGVjdGVkTm9kZXMsIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIG5vZGVMb29rdXAsIG9uRXJyb3IgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMTInLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMiddKGlkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RvcmUuc2V0U3RhdGUoeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UgfSk7XG4gICAgaWYgKCFub2RlLnNlbGVjdGVkKSB7XG4gICAgICAgIGFkZFNlbGVjdGVkTm9kZXMoW2lkXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVuc2VsZWN0IHx8IChub2RlLnNlbGVjdGVkICYmIG11bHRpU2VsZWN0aW9uQWN0aXZlKSkge1xuICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBub2RlczogW25vZGVdLCBlZGdlczogW10gfSk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBub2RlUmVmPy5jdXJyZW50Py5ibHVyKCkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBIb29rIGZvciBjYWxsaW5nIFhZRHJhZyBoZWxwZXIgZnJvbSBAeHlmbG93L3N5c3RlbS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlRHJhZyh7IG5vZGVSZWYsIGRpc2FibGVkID0gZmFsc2UsIG5vRHJhZ0NsYXNzTmFtZSwgaGFuZGxlU2VsZWN0b3IsIG5vZGVJZCwgaXNTZWxlY3RhYmxlLCBub2RlQ2xpY2tEaXN0YW5jZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBbZHJhZ2dpbmcsIHNldERyYWdnaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCB4eURyYWcgPSB1c2VSZWYoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB4eURyYWcuY3VycmVudCA9IFhZRHJhZyh7XG4gICAgICAgICAgICBnZXRTdG9yZUl0ZW1zOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgb25Ob2RlTW91c2VEb3duOiAoaWQpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVSZWYsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25EcmFnU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXREcmFnZ2luZyh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRyYWdTdG9wOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0RHJhZ2dpbmcoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgICAgeHlEcmFnLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHh5RHJhZy5jdXJyZW50Py51cGRhdGUoe1xuICAgICAgICAgICAgICAgIG5vRHJhZ0NsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBoYW5kbGVTZWxlY3RvcixcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiBub2RlUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgaXNTZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICBub2RlQ2xpY2tEaXN0YW5jZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB4eURyYWcuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtub0RyYWdDbGFzc05hbWUsIGhhbmRsZVNlbGVjdG9yLCBkaXNhYmxlZCwgaXNTZWxlY3RhYmxlLCBub2RlUmVmLCBub2RlSWRdKTtcbiAgICByZXR1cm4gZHJhZ2dpbmc7XG59XG5cbmNvbnN0IHNlbGVjdGVkQW5kRHJhZ2dhYmxlID0gKG5vZGVzRHJhZ2dhYmxlKSA9PiAobikgPT4gbi5zZWxlY3RlZCAmJiAobi5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBuLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbi8qKlxuICogSG9vayBmb3IgdXBkYXRpbmcgbm9kZSBwb3NpdGlvbnMgYnkgcGFzc2luZyBhIGRpcmVjdGlvbiBhbmQgZmFjdG9yXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJucyBmdW5jdGlvbiBmb3IgdXBkYXRpbmcgbm9kZSBwb3NpdGlvbnNcbiAqL1xuZnVuY3Rpb24gdXNlTW92ZVNlbGVjdGVkTm9kZXMoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IG1vdmVTZWxlY3RlZE5vZGVzID0gdXNlQ2FsbGJhY2soKHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCB7IG5vZGVFeHRlbnQsIHNuYXBUb0dyaWQsIHNuYXBHcmlkLCBub2Rlc0RyYWdnYWJsZSwgb25FcnJvciwgdXBkYXRlTm9kZVBvc2l0aW9ucywgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3Qgbm9kZVVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBzZWxlY3RlZEFuZERyYWdnYWJsZShub2Rlc0RyYWdnYWJsZSk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIGJ5IGRlZmF1bHQgYSBub2RlIG1vdmVzIDVweCBvbiBlYWNoIGtleSBwcmVzc1xuICAgICAgICAgKiBpZiBzbmFwIGdyaWQgaXMgZW5hYmxlZCwgd2UgdXNlIHRoYXQgZm9yIHRoZSB2ZWxvY2l0eVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeFZlbG8gPSBzbmFwVG9HcmlkID8gc25hcEdyaWRbMF0gOiA1O1xuICAgICAgICBjb25zdCB5VmVsbyA9IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFsxXSA6IDU7XG4gICAgICAgIGNvbnN0IHhEaWZmID0gcGFyYW1zLmRpcmVjdGlvbi54ICogeFZlbG8gKiBwYXJhbXMuZmFjdG9yO1xuICAgICAgICBjb25zdCB5RGlmZiA9IHBhcmFtcy5kaXJlY3Rpb24ueSAqIHlWZWxvICogcGFyYW1zLmZhY3RvcjtcbiAgICAgICAgZm9yIChjb25zdCBbLCBub2RlXSBvZiBub2RlTG9va3VwKSB7XG4gICAgICAgICAgICBpZiAoIWlzU2VsZWN0ZWQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54ICsgeERpZmYsXG4gICAgICAgICAgICAgICAgeTogbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55ICsgeURpZmYsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHNuYXBUb0dyaWQpIHtcbiAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24gPSBzbmFwUG9zaXRpb24obmV4dFBvc2l0aW9uLCBzbmFwR3JpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uLCBwb3NpdGlvbkFic29sdXRlIH0gPSBjYWxjdWxhdGVOb2RlUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgIG5vZGVJZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICBub2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbm9kZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSA9IHBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgICAgICBub2RlVXBkYXRlcy5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhub2RlVXBkYXRlcyk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBtb3ZlU2VsZWN0ZWROb2Rlcztcbn1cblxuY29uc3QgTm9kZUlkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBQcm92aWRlciA9IE5vZGVJZENvbnRleHQuUHJvdmlkZXI7XG5Ob2RlSWRDb250ZXh0LkNvbnN1bWVyO1xuLyoqXG4gKiBZb3UgY2FuIHVzZSB0aGlzIGhvb2sgdG8gZ2V0IHRoZSBpZCBvZiB0aGUgbm9kZSBpdCBpcyB1c2VkIGluc2lkZS4gSXQgaXMgdXNlZnVsXG4gKiBpZiB5b3UgbmVlZCB0aGUgbm9kZSdzIGlkIGRlZXBlciBpbiB0aGUgcmVuZGVyIHRyZWUgYnV0IGRvbid0IHdhbnQgdG8gbWFudWFsbHlcbiAqIGRyaWxsIGRvd24gdGhlIGlkIGFzIGEgcHJvcC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBUaGUgaWQgZm9yIGEgbm9kZSBpbiB0aGUgZmxvdy5cbiAqXG4gKiBAZXhhbXBsZVxuICpgYGBqc3hcbiAqaW1wb3J0IHsgdXNlTm9kZUlkIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDdXN0b21Ob2RlKCkge1xuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICA8c3Bhbj5UaGlzIG5vZGUgaGFzIGFuIGlkIG9mIDwvc3Bhbj5cbiAqICAgICAgPE5vZGVJZERpc3BsYXkgLz5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqXG4gKmZ1bmN0aW9uIE5vZGVJZERpc3BsYXkoKSB7XG4gKiAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gKlxuICogIHJldHVybiA8c3Bhbj57bm9kZUlkfTwvc3Bhbj47XG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IHVzZU5vZGVJZCA9ICgpID0+IHtcbiAgICBjb25zdCBub2RlSWQgPSB1c2VDb250ZXh0KE5vZGVJZENvbnRleHQpO1xuICAgIHJldHVybiBub2RlSWQ7XG59O1xuXG5jb25zdCBzZWxlY3RvciRnID0gKHMpID0+ICh7XG4gICAgY29ubmVjdE9uQ2xpY2s6IHMuY29ubmVjdE9uQ2xpY2ssXG4gICAgbm9QYW5DbGFzc05hbWU6IHMubm9QYW5DbGFzc05hbWUsXG4gICAgcmZJZDogcy5yZklkLFxufSk7XG5jb25zdCBjb25uZWN0aW5nU2VsZWN0b3IgPSAobm9kZUlkLCBoYW5kbGVJZCwgdHlwZSkgPT4gKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogY2xpY2tIYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICBjb25zdCB7IGZyb21IYW5kbGUsIHRvSGFuZGxlLCBpc1ZhbGlkIH0gPSBjb25uZWN0aW9uO1xuICAgIGNvbnN0IGNvbm5lY3RpbmdUbyA9IHRvSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiB0b0hhbmRsZT8uaWQgPT09IGhhbmRsZUlkICYmIHRvSGFuZGxlPy50eXBlID09PSB0eXBlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbm5lY3RpbmdGcm9tOiBmcm9tSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiBmcm9tSGFuZGxlPy5pZCA9PT0gaGFuZGxlSWQgJiYgZnJvbUhhbmRsZT8udHlwZSA9PT0gdHlwZSxcbiAgICAgICAgY29ubmVjdGluZ1RvLFxuICAgICAgICBjbGlja0Nvbm5lY3Rpbmc6IGNsaWNrSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiBjbGlja0hhbmRsZT8uaWQgPT09IGhhbmRsZUlkICYmIGNsaWNrSGFuZGxlPy50eXBlID09PSB0eXBlLFxuICAgICAgICBpc1Bvc3NpYmxlRW5kSGFuZGxlOiBjb25uZWN0aW9uTW9kZSA9PT0gQ29ubmVjdGlvbk1vZGUuU3RyaWN0XG4gICAgICAgICAgICA/IGZyb21IYW5kbGU/LnR5cGUgIT09IHR5cGVcbiAgICAgICAgICAgIDogbm9kZUlkICE9PSBmcm9tSGFuZGxlPy5ub2RlSWQgfHwgaGFuZGxlSWQgIT09IGZyb21IYW5kbGU/LmlkLFxuICAgICAgICBjb25uZWN0aW9uSW5Qcm9jZXNzOiAhIWZyb21IYW5kbGUsXG4gICAgICAgIGNsaWNrQ29ubmVjdGlvbkluUHJvY2VzczogISFjbGlja0hhbmRsZSxcbiAgICAgICAgdmFsaWQ6IGNvbm5lY3RpbmdUbyAmJiBpc1ZhbGlkLFxuICAgIH07XG59O1xuZnVuY3Rpb24gSGFuZGxlQ29tcG9uZW50KHsgdHlwZSA9ICdzb3VyY2UnLCBwb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgaXNWYWxpZENvbm5lY3Rpb24sIGlzQ29ubmVjdGFibGUgPSB0cnVlLCBpc0Nvbm5lY3RhYmxlU3RhcnQgPSB0cnVlLCBpc0Nvbm5lY3RhYmxlRW5kID0gdHJ1ZSwgaWQsIG9uQ29ubmVjdCwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgb25Nb3VzZURvd24sIG9uVG91Y2hTdGFydCwgLi4ucmVzdCB9LCByZWYpIHtcbiAgICBjb25zdCBoYW5kbGVJZCA9IGlkIHx8IG51bGw7XG4gICAgY29uc3QgaXNUYXJnZXQgPSB0eXBlID09PSAndGFyZ2V0JztcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgeyBjb25uZWN0T25DbGljaywgbm9QYW5DbGFzc05hbWUsIHJmSWQgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGcsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHsgY29ubmVjdGluZ0Zyb20sIGNvbm5lY3RpbmdUbywgY2xpY2tDb25uZWN0aW5nLCBpc1Bvc3NpYmxlRW5kSGFuZGxlLCBjb25uZWN0aW9uSW5Qcm9jZXNzLCBjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3MsIHZhbGlkLCB9ID0gdXNlU3RvcmUoY29ubmVjdGluZ1NlbGVjdG9yKG5vZGVJZCwgaGFuZGxlSWQsIHR5cGUpLCBzaGFsbG93KTtcbiAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDEwJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTAnXSgpKTtcbiAgICB9XG4gICAgY29uc3Qgb25Db25uZWN0RXh0ZW5kZWQgPSAocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGVmYXVsdEVkZ2VPcHRpb25zLCBvbkNvbm5lY3Q6IG9uQ29ubmVjdEFjdGlvbiwgaGFzRGVmYXVsdEVkZ2VzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBlZGdlUGFyYW1zID0ge1xuICAgICAgICAgICAgLi4uZGVmYXVsdEVkZ2VPcHRpb25zLFxuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVkZ2VzLCBzZXRFZGdlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHNldEVkZ2VzKGFkZEVkZ2UoZWRnZVBhcmFtcywgZWRnZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBvbkNvbm5lY3RBY3Rpb24/LihlZGdlUGFyYW1zKTtcbiAgICAgICAgb25Db25uZWN0Py4oZWRnZVBhcmFtcyk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNNb3VzZVRyaWdnZXJlZCA9IGlzTW91c2VFdmVudChldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICAgIGlmIChpc0Nvbm5lY3RhYmxlU3RhcnQgJiZcbiAgICAgICAgICAgICgoaXNNb3VzZVRyaWdnZXJlZCAmJiBldmVudC5idXR0b24gPT09IDApIHx8ICFpc01vdXNlVHJpZ2dlcmVkKSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0b3JlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIFhZSGFuZGxlLm9uUG9pbnRlckRvd24oZXZlbnQubmF0aXZlRXZlbnQsIHtcbiAgICAgICAgICAgICAgICBhdXRvUGFuT25Db25uZWN0OiBjdXJyZW50U3RvcmUuYXV0b1Bhbk9uQ29ubmVjdCxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uTW9kZTogY3VycmVudFN0b3JlLmNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25SYWRpdXM6IGN1cnJlbnRTdG9yZS5jb25uZWN0aW9uUmFkaXVzLFxuICAgICAgICAgICAgICAgIGRvbU5vZGU6IGN1cnJlbnRTdG9yZS5kb21Ob2RlLFxuICAgICAgICAgICAgICAgIG5vZGVMb29rdXA6IGN1cnJlbnRTdG9yZS5ub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgIGxpYjogY3VycmVudFN0b3JlLmxpYixcbiAgICAgICAgICAgICAgICBpc1RhcmdldCxcbiAgICAgICAgICAgICAgICBoYW5kbGVJZCxcbiAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgZmxvd0lkOiBjdXJyZW50U3RvcmUucmZJZCxcbiAgICAgICAgICAgICAgICBwYW5CeTogY3VycmVudFN0b3JlLnBhbkJ5LFxuICAgICAgICAgICAgICAgIGNhbmNlbENvbm5lY3Rpb246IGN1cnJlbnRTdG9yZS5jYW5jZWxDb25uZWN0aW9uLFxuICAgICAgICAgICAgICAgIG9uQ29ubmVjdFN0YXJ0OiBjdXJyZW50U3RvcmUub25Db25uZWN0U3RhcnQsXG4gICAgICAgICAgICAgICAgb25Db25uZWN0RW5kOiBjdXJyZW50U3RvcmUub25Db25uZWN0RW5kLFxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb246IGN1cnJlbnRTdG9yZS51cGRhdGVDb25uZWN0aW9uLFxuICAgICAgICAgICAgICAgIG9uQ29ubmVjdDogb25Db25uZWN0RXh0ZW5kZWQsXG4gICAgICAgICAgICAgICAgaXNWYWxpZENvbm5lY3Rpb246IGlzVmFsaWRDb25uZWN0aW9uIHx8IGN1cnJlbnRTdG9yZS5pc1ZhbGlkQ29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBnZXRUcmFuc2Zvcm06ICgpID0+IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIGdldEZyb21IYW5kbGU6ICgpID0+IHN0b3JlLmdldFN0YXRlKCkuY29ubmVjdGlvbi5mcm9tSGFuZGxlLFxuICAgICAgICAgICAgICAgIGF1dG9QYW5TcGVlZDogY3VycmVudFN0b3JlLmF1dG9QYW5TcGVlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc01vdXNlVHJpZ2dlcmVkKSB7XG4gICAgICAgICAgICBvbk1vdXNlRG93bj8uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydD8uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25DbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kLCBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSwgY29ubmVjdGlvbk1vZGUsIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvblN0b3JlLCBsaWIsIHJmSWQ6IGZsb3dJZCwgbm9kZUxvb2t1cCwgY29ubmVjdGlvbjogY29ubmVjdGlvblN0YXRlLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKCFub2RlSWQgfHwgKCFjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSAmJiAhaXNDb25uZWN0YWJsZVN0YXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUpIHtcbiAgICAgICAgICAgIG9uQ2xpY2tDb25uZWN0U3RhcnQ/LihldmVudC5uYXRpdmVFdmVudCwgeyBub2RlSWQsIGhhbmRsZUlkLCBoYW5kbGVUeXBlOiB0eXBlIH0pO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogeyBub2RlSWQsIHR5cGUsIGlkOiBoYW5kbGVJZCB9IH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvYyA9IGdldEhvc3RGb3JFbGVtZW50KGV2ZW50LnRhcmdldCk7XG4gICAgICAgIGNvbnN0IGlzVmFsaWRDb25uZWN0aW9uSGFuZGxlciA9IGlzVmFsaWRDb25uZWN0aW9uIHx8IGlzVmFsaWRDb25uZWN0aW9uU3RvcmU7XG4gICAgICAgIGNvbnN0IHsgY29ubmVjdGlvbiwgaXNWYWxpZCB9ID0gWFlIYW5kbGUuaXNWYWxpZChldmVudC5uYXRpdmVFdmVudCwge1xuICAgICAgICAgICAgaGFuZGxlOiB7XG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIGlkOiBoYW5kbGVJZCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgZnJvbU5vZGVJZDogY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUubm9kZUlkLFxuICAgICAgICAgICAgZnJvbUhhbmRsZUlkOiBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZS5pZCB8fCBudWxsLFxuICAgICAgICAgICAgZnJvbVR5cGU6IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLnR5cGUsXG4gICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb25IYW5kbGVyLFxuICAgICAgICAgICAgZmxvd0lkLFxuICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAgbGliLFxuICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1ZhbGlkICYmIGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIG9uQ29ubmVjdEV4dGVuZGVkKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25DbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICBkZWxldGUgY29ubmVjdGlvbkNsb25lLmluUHJvZ3Jlc3M7XG4gICAgICAgIGNvbm5lY3Rpb25DbG9uZS50b1Bvc2l0aW9uID0gY29ubmVjdGlvbkNsb25lLnRvSGFuZGxlID8gY29ubmVjdGlvbkNsb25lLnRvSGFuZGxlLnBvc2l0aW9uIDogbnVsbDtcbiAgICAgICAgb25DbGlja0Nvbm5lY3RFbmQ/LihldmVudCwgY29ubmVjdGlvbkNsb25lKTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogbnVsbCB9KTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgXCJkYXRhLWhhbmRsZWlkXCI6IGhhbmRsZUlkLCBcImRhdGEtbm9kZWlkXCI6IG5vZGVJZCwgXCJkYXRhLWhhbmRsZXBvc1wiOiBwb3NpdGlvbiwgXCJkYXRhLWlkXCI6IGAke3JmSWR9LSR7bm9kZUlkfS0ke2hhbmRsZUlkfS0ke3R5cGV9YCwgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAncmVhY3QtZmxvd19faGFuZGxlJyxcbiAgICAgICAgICAgIGByZWFjdC1mbG93X19oYW5kbGUtJHtwb3NpdGlvbn1gLFxuICAgICAgICAgICAgJ25vZHJhZycsXG4gICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICFpc1RhcmdldCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGlzVGFyZ2V0LFxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlc3RhcnQ6IGlzQ29ubmVjdGFibGVTdGFydCxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZWVuZDogaXNDb25uZWN0YWJsZUVuZCxcbiAgICAgICAgICAgICAgICBjbGlja2Nvbm5lY3Rpbmc6IGNsaWNrQ29ubmVjdGluZyxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW5nZnJvbTogY29ubmVjdGluZ0Zyb20sXG4gICAgICAgICAgICAgICAgY29ubmVjdGluZ3RvOiBjb25uZWN0aW5nVG8sXG4gICAgICAgICAgICAgICAgdmFsaWQsXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBzaG93cyB3aGVyZSB5b3UgY2FuIHN0YXJ0IGEgY29ubmVjdGlvbiBmcm9tXG4gICAgICAgICAgICAgICAgICogYW5kIHdoZXJlIHlvdSBjYW4gZW5kIGl0IHdoaWxlIGNvbm5lY3RpbmdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uaW5kaWNhdG9yOiBpc0Nvbm5lY3RhYmxlICYmXG4gICAgICAgICAgICAgICAgICAgICghY29ubmVjdGlvbkluUHJvY2VzcyB8fCBpc1Bvc3NpYmxlRW5kSGFuZGxlKSAmJlxuICAgICAgICAgICAgICAgICAgICAoY29ubmVjdGlvbkluUHJvY2VzcyB8fCBjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3MgPyBpc0Nvbm5lY3RhYmxlRW5kIDogaXNDb25uZWN0YWJsZVN0YXJ0KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pLCBvbk1vdXNlRG93bjogb25Qb2ludGVyRG93biwgb25Ub3VjaFN0YXJ0OiBvblBvaW50ZXJEb3duLCBvbkNsaWNrOiBjb25uZWN0T25DbGljayA/IG9uQ2xpY2sgOiB1bmRlZmluZWQsIHJlZjogcmVmLCAuLi5yZXN0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuLyoqXG4gKiBUaGUgYDxIYW5kbGUgLz5gIGNvbXBvbmVudCBpcyB1c2VkIGluIHlvdXIgW2N1c3RvbSBub2Rlc10oL2xlYXJuL2N1c3RvbWl6YXRpb24vY3VzdG9tLW5vZGVzKVxuICogdG8gZGVmaW5lIGNvbm5lY3Rpb24gcG9pbnRzLlxuICpcbiAqQHB1YmxpY1xuICpcbiAqQGV4YW1wbGVcbiAqXG4gKmBgYGpzeFxuICppbXBvcnQgeyBIYW5kbGUsIFBvc2l0aW9uIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZnVuY3Rpb24gQ3VzdG9tTm9kZSh7IGRhdGEgfSkge1xuICogIHJldHVybiAoXG4gKiAgICA8PlxuICogICAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6ICcxMHB4IDIwcHgnIH19PlxuICogICAgICAgIHtkYXRhLmxhYmVsfVxuICogICAgICA8L2Rpdj5cbiAqXG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInRhcmdldFwiIHBvc2l0aW9uPXtQb3NpdGlvbi5MZWZ0fSAvPlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJzb3VyY2VcIiBwb3NpdGlvbj17UG9zaXRpb24uUmlnaHR9IC8+XG4gKiAgICA8Lz5cbiAqICApO1xuICp9O1xuICpgYGBcbiAqL1xuY29uc3QgSGFuZGxlID0gbWVtbyhmaXhlZEZvcndhcmRSZWYoSGFuZGxlQ29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIElucHV0Tm9kZSh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtkYXRhPy5sYWJlbCwganN4KEhhbmRsZSwgeyB0eXBlOiBcInNvdXJjZVwiLCBwb3NpdGlvbjogc291cmNlUG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSldIH0pKTtcbn1cblxuZnVuY3Rpb24gRGVmYXVsdE5vZGUoeyBkYXRhLCBpc0Nvbm5lY3RhYmxlLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goSGFuZGxlLCB7IHR5cGU6IFwidGFyZ2V0XCIsIHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KSwgZGF0YT8ubGFiZWwsIGpzeChIYW5kbGUsIHsgdHlwZTogXCJzb3VyY2VcIiwgcG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pXSB9KSk7XG59XG5cbmZ1bmN0aW9uIEdyb3VwTm9kZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gT3V0cHV0Tm9kZSh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goSGFuZGxlLCB7IHR5cGU6IFwidGFyZ2V0XCIsIHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KSwgZGF0YT8ubGFiZWxdIH0pKTtcbn1cblxuY29uc3QgYXJyb3dLZXlEaWZmcyA9IHtcbiAgICBBcnJvd1VwOiB7IHg6IDAsIHk6IC0xIH0sXG4gICAgQXJyb3dEb3duOiB7IHg6IDAsIHk6IDEgfSxcbiAgICBBcnJvd0xlZnQ6IHsgeDogLTEsIHk6IDAgfSxcbiAgICBBcnJvd1JpZ2h0OiB7IHg6IDEsIHk6IDAgfSxcbn07XG5jb25zdCBidWlsdGluTm9kZVR5cGVzID0ge1xuICAgIGlucHV0OiBJbnB1dE5vZGUsXG4gICAgZGVmYXVsdDogRGVmYXVsdE5vZGUsXG4gICAgb3V0cHV0OiBPdXRwdXROb2RlLFxuICAgIGdyb3VwOiBHcm91cE5vZGUsXG59O1xuZnVuY3Rpb24gZ2V0Tm9kZUlubGluZVN0eWxlRGltZW5zaW9ucyhub2RlKSB7XG4gICAgaWYgKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyBub2RlLnN0eWxlPy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IG5vZGUuc3R5bGU/LmhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IG5vZGUud2lkdGggPz8gbm9kZS5zdHlsZT8ud2lkdGgsXG4gICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgPz8gbm9kZS5zdHlsZT8uaGVpZ2h0LFxuICAgIH07XG59XG5cbmNvbnN0IHNlbGVjdG9yJGYgPSAocykgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgeCwgeSB9ID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhzLm5vZGVMb29rdXAsIHtcbiAgICAgICAgZmlsdGVyOiAobm9kZSkgPT4gISFub2RlLnNlbGVjdGVkLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBpc051bWVyaWMod2lkdGgpID8gd2lkdGggOiBudWxsLFxuICAgICAgICBoZWlnaHQ6IGlzTnVtZXJpYyhoZWlnaHQpID8gaGVpZ2h0IDogbnVsbCxcbiAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICB0cmFuc2Zvcm1TdHJpbmc6IGB0cmFuc2xhdGUoJHtzLnRyYW5zZm9ybVswXX1weCwke3MudHJhbnNmb3JtWzFdfXB4KSBzY2FsZSgke3MudHJhbnNmb3JtWzJdfSkgdHJhbnNsYXRlKCR7eH1weCwke3l9cHgpYCxcbiAgICB9O1xufTtcbmZ1bmN0aW9uIE5vZGVzU2VsZWN0aW9uKHsgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB0cmFuc2Zvcm1TdHJpbmcsIHVzZXJTZWxlY3Rpb25BY3RpdmUgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGYsIHNoYWxsb3cpO1xuICAgIGNvbnN0IG1vdmVTZWxlY3RlZE5vZGVzID0gdXNlTW92ZVNlbGVjdGVkTm9kZXMoKTtcbiAgICBjb25zdCBub2RlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghZGlzYWJsZUtleWJvYXJkQTExeSkge1xuICAgICAgICAgICAgbm9kZVJlZi5jdXJyZW50Py5mb2N1cyh7XG4gICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2Rpc2FibGVLZXlib2FyZEExMXldKTtcbiAgICB1c2VEcmFnKHtcbiAgICAgICAgbm9kZVJlZixcbiAgICB9KTtcbiAgICBpZiAodXNlclNlbGVjdGlvbkFjdGl2ZSB8fCAhd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb25Db250ZXh0TWVudSA9IG9uU2VsZWN0aW9uQ29udGV4dE1lbnVcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVzLmZpbHRlcigobikgPT4gbi5zZWxlY3RlZCk7XG4gICAgICAgICAgICBvblNlbGVjdGlvbkNvbnRleHRNZW51KGV2ZW50LCBzZWxlY3RlZE5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbktleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcnJvd0tleURpZmZzLCBldmVudC5rZXkpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgbW92ZVNlbGVjdGVkTm9kZXMoe1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogYXJyb3dLZXlEaWZmc1tldmVudC5rZXldLFxuICAgICAgICAgICAgICAgIGZhY3RvcjogZXZlbnQuc2hpZnRLZXkgPyA0IDogMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19ub2Rlc3NlbGVjdGlvbicsICdyZWFjdC1mbG93X19jb250YWluZXInLCBub1BhbkNsYXNzTmFtZV0pLCBzdHlsZToge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1TdHJpbmcsXG4gICAgICAgIH0sIGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyByZWY6IG5vZGVSZWYsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19ub2Rlc3NlbGVjdGlvbi1yZWN0XCIsIG9uQ29udGV4dE1lbnU6IG9uQ29udGV4dE1lbnUsIHRhYkluZGV4OiBkaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogLTEsIG9uS2V5RG93bjogZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6IG9uS2V5RG93biwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB9IH0pIH0pKTtcbn1cblxuY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG5jb25zdCBzZWxlY3RvciRlID0gKHMpID0+IHtcbiAgICByZXR1cm4geyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogcy5ub2Rlc1NlbGVjdGlvbkFjdGl2ZSwgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlIH07XG59O1xuZnVuY3Rpb24gRmxvd1JlbmRlcmVyQ29tcG9uZW50KHsgY2hpbGRyZW4sIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGwsIHBhbmVDbGlja0Rpc3RhbmNlLCBkZWxldGVLZXlDb2RlLCBzZWxlY3Rpb25LZXlDb2RlLCBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGUsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBtdWx0aVNlbGVjdGlvbktleUNvZGUsIHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaCwgcGFuT25TY3JvbGw6IF9wYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljaywgcGFuT25EcmFnOiBfcGFuT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZywgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIG9uVmlld3BvcnRDaGFuZ2UsIGlzQ29udHJvbGxlZFZpZXdwb3J0LCB9KSB7XG4gICAgY29uc3QgeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZSwgdXNlclNlbGVjdGlvbkFjdGl2ZSB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkZSk7XG4gICAgY29uc3Qgc2VsZWN0aW9uS2V5UHJlc3NlZCA9IHVzZUtleVByZXNzKHNlbGVjdGlvbktleUNvZGUsIHsgdGFyZ2V0OiB3aW4gfSk7XG4gICAgY29uc3QgcGFuQWN0aXZhdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhwYW5BY3RpdmF0aW9uS2V5Q29kZSwgeyB0YXJnZXQ6IHdpbiB9KTtcbiAgICBjb25zdCBwYW5PbkRyYWcgPSBwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCB8fCBfcGFuT25EcmFnO1xuICAgIGNvbnN0IHBhbk9uU2Nyb2xsID0gcGFuQWN0aXZhdGlvbktleVByZXNzZWQgfHwgX3Bhbk9uU2Nyb2xsO1xuICAgIGNvbnN0IF9zZWxlY3Rpb25PbkRyYWcgPSBzZWxlY3Rpb25PbkRyYWcgJiYgcGFuT25EcmFnICE9PSB0cnVlO1xuICAgIGNvbnN0IGlzU2VsZWN0aW5nID0gc2VsZWN0aW9uS2V5UHJlc3NlZCB8fCB1c2VyU2VsZWN0aW9uQWN0aXZlIHx8IF9zZWxlY3Rpb25PbkRyYWc7XG4gICAgdXNlR2xvYmFsS2V5SGFuZGxlcih7IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSB9KTtcbiAgICByZXR1cm4gKGpzeChab29tUGFuZSwgeyBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCB6b29tT25TY3JvbGw6IHpvb21PblNjcm9sbCwgem9vbU9uUGluY2g6IHpvb21PblBpbmNoLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljazogem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uRHJhZzogIXNlbGVjdGlvbktleVByZXNzZWQgJiYgcGFuT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBwcmV2ZW50U2Nyb2xsaW5nOiBwcmV2ZW50U2Nyb2xsaW5nLCBub1doZWVsQ2xhc3NOYW1lOiBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UsIGlzQ29udHJvbGxlZFZpZXdwb3J0OiBpc0NvbnRyb2xsZWRWaWV3cG9ydCwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBjaGlsZHJlbjoganN4cyhQYW5lLCB7IG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lQ29udGV4dE1lbnU6IG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGw6IG9uUGFuZVNjcm9sbCwgcGFuT25EcmFnOiBwYW5PbkRyYWcsIGlzU2VsZWN0aW5nOiAhIWlzU2VsZWN0aW5nLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLCBzZWxlY3Rpb25LZXlQcmVzc2VkOiBzZWxlY3Rpb25LZXlQcmVzc2VkLCBzZWxlY3Rpb25PbkRyYWc6IF9zZWxlY3Rpb25PbkRyYWcsIGNoaWxkcmVuOiBbY2hpbGRyZW4sIG5vZGVzU2VsZWN0aW9uQWN0aXZlICYmIChqc3goTm9kZXNTZWxlY3Rpb24sIHsgb25TZWxlY3Rpb25Db250ZXh0TWVudTogb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pKV0gfSkgfSkpO1xufVxuRmxvd1JlbmRlcmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0Zsb3dSZW5kZXJlcic7XG5jb25zdCBGbG93UmVuZGVyZXIgPSBtZW1vKEZsb3dSZW5kZXJlckNvbXBvbmVudCk7XG5cbmNvbnN0IHNlbGVjdG9yJGQgPSAob25seVJlbmRlclZpc2libGUpID0+IChzKSA9PiB7XG4gICAgcmV0dXJuIG9ubHlSZW5kZXJWaXNpYmxlXG4gICAgICAgID8gZ2V0Tm9kZXNJbnNpZGUocy5ub2RlTG9va3VwLCB7IHg6IDAsIHk6IDAsIHdpZHRoOiBzLndpZHRoLCBoZWlnaHQ6IHMuaGVpZ2h0IH0sIHMudHJhbnNmb3JtLCB0cnVlKS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpXG4gICAgICAgIDogQXJyYXkuZnJvbShzLm5vZGVMb29rdXAua2V5cygpKTtcbn07XG4vKipcbiAqIEhvb2sgZm9yIGdldHRpbmcgdGhlIHZpc2libGUgbm9kZSBpZHMgZnJvbSB0aGUgc3RvcmUuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gb25seVJlbmRlclZpc2libGVcbiAqIEByZXR1cm5zIGFycmF5IHdpdGggdmlzaWJsZSBub2RlIGlkc1xuICovXG5mdW5jdGlvbiB1c2VWaXNpYmxlTm9kZUlkcyhvbmx5UmVuZGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IG5vZGVJZHMgPSB1c2VTdG9yZSh1c2VDYWxsYmFjayhzZWxlY3RvciRkKG9ubHlSZW5kZXJWaXNpYmxlKSwgW29ubHlSZW5kZXJWaXNpYmxlXSksIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2RlSWRzO1xufVxuXG5jb25zdCBzZWxlY3RvciRjID0gKHMpID0+IHMudXBkYXRlTm9kZUludGVybmFscztcbmZ1bmN0aW9uIHVzZVJlc2l6ZU9ic2VydmVyKCkge1xuICAgIGNvbnN0IHVwZGF0ZU5vZGVJbnRlcm5hbHMgPSB1c2VTdG9yZShzZWxlY3RvciRjKTtcbiAgICBjb25zdCBbcmVzaXplT2JzZXJ2ZXJdID0gdXNlU3RhdGUoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGVudHJ5LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVzLnNldChpZCwge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUVsZW1lbnQ6IGVudHJ5LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2U6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtyZXNpemVPYnNlcnZlcl0pO1xuICAgIHJldHVybiByZXNpemVPYnNlcnZlcjtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGhhbmRsZSB0aGUgcmVzaXplIG9ic2VydmF0aW9uICsgaW50ZXJuYWwgdXBkYXRlcyBmb3IgdGhlIHBhc3NlZCBub2RlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgbm9kZVJlZiAtIHJlZmVyZW5jZSB0byB0aGUgbm9kZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVPYnNlcnZlcih7IG5vZGUsIG5vZGVUeXBlLCBoYXNEaW1lbnNpb25zLCByZXNpemVPYnNlcnZlciwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBub2RlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IG9ic2VydmVkTm9kZSA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBwcmV2U291cmNlUG9zaXRpb24gPSB1c2VSZWYobm9kZS5zb3VyY2VQb3NpdGlvbik7XG4gICAgY29uc3QgcHJldlRhcmdldFBvc2l0aW9uID0gdXNlUmVmKG5vZGUudGFyZ2V0UG9zaXRpb24pO1xuICAgIGNvbnN0IHByZXZUeXBlID0gdXNlUmVmKG5vZGVUeXBlKTtcbiAgICBjb25zdCBpc0luaXRpYWxpemVkID0gaGFzRGltZW5zaW9ucyAmJiAhIW5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcztcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobm9kZVJlZi5jdXJyZW50ICYmICFub2RlLmhpZGRlbiAmJiAoIWlzSW5pdGlhbGl6ZWQgfHwgb2JzZXJ2ZWROb2RlLmN1cnJlbnQgIT09IG5vZGVSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlZE5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy51bm9ic2VydmUob2JzZXJ2ZWROb2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXI/Lm9ic2VydmUobm9kZVJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIG9ic2VydmVkTm9kZS5jdXJyZW50ID0gbm9kZVJlZi5jdXJyZW50O1xuICAgICAgICB9XG4gICAgfSwgW2lzSW5pdGlhbGl6ZWQsIG5vZGUuaGlkZGVuXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlZE5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy51bm9ic2VydmUob2JzZXJ2ZWROb2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIG9ic2VydmVkTm9kZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG5vZGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHdoZW4gdGhlIHVzZXIgcHJvZ3JhbW1hdGljYWxseSBjaGFuZ2VzIHRoZSBzb3VyY2Ugb3IgaGFuZGxlIHBvc2l0aW9uLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaW50ZXJuYWxzXG4gICAgICAgICAgICAgKiB0byBtYWtlIHN1cmUgdGhlIGVkZ2VzIGFyZSB1cGRhdGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCB0eXBlQ2hhbmdlZCA9IHByZXZUeXBlLmN1cnJlbnQgIT09IG5vZGVUeXBlO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlUG9zQ2hhbmdlZCA9IHByZXZTb3VyY2VQb3NpdGlvbi5jdXJyZW50ICE9PSBub2RlLnNvdXJjZVBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UG9zQ2hhbmdlZCA9IHByZXZUYXJnZXRQb3NpdGlvbi5jdXJyZW50ICE9PSBub2RlLnRhcmdldFBvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKHR5cGVDaGFuZ2VkIHx8IHNvdXJjZVBvc0NoYW5nZWQgfHwgdGFyZ2V0UG9zQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHByZXZUeXBlLmN1cnJlbnQgPSBub2RlVHlwZTtcbiAgICAgICAgICAgICAgICBwcmV2U291cmNlUG9zaXRpb24uY3VycmVudCA9IG5vZGUuc291cmNlUG9zaXRpb247XG4gICAgICAgICAgICAgICAgcHJldlRhcmdldFBvc2l0aW9uLmN1cnJlbnQgPSBub2RlLnRhcmdldFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHN0b3JlXG4gICAgICAgICAgICAgICAgICAgIC5nZXRTdGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgIC51cGRhdGVOb2RlSW50ZXJuYWxzKG5ldyBNYXAoW1tub2RlLmlkLCB7IGlkOiBub2RlLmlkLCBub2RlRWxlbWVudDogbm9kZVJlZi5jdXJyZW50LCBmb3JjZTogdHJ1ZSB9XV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtub2RlLmlkLCBub2RlVHlwZSwgbm9kZS5zb3VyY2VQb3NpdGlvbiwgbm9kZS50YXJnZXRQb3NpdGlvbl0pO1xuICAgIHJldHVybiBub2RlUmVmO1xufVxuXG5mdW5jdGlvbiBOb2RlV3JhcHBlcih7IGlkLCBvbkNsaWNrLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmUsIG9uQ29udGV4dE1lbnUsIG9uRG91YmxlQ2xpY2ssIG5vZGVzRHJhZ2dhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCByZXNpemVPYnNlcnZlciwgbm9EcmFnQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeSwgcmZJZCwgbm9kZVR5cGVzLCBub2RlQ2xpY2tEaXN0YW5jZSwgb25FcnJvciwgfSkge1xuICAgIGNvbnN0IHsgbm9kZSwgaW50ZXJuYWxzLCBpc1BhcmVudCB9ID0gdXNlU3RvcmUoKHMpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHMubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICBjb25zdCBpc1BhcmVudCA9IHMucGFyZW50TG9va3VwLmhhcyhpZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgaW50ZXJuYWxzOiBub2RlLmludGVybmFscyxcbiAgICAgICAgICAgIGlzUGFyZW50LFxuICAgICAgICB9O1xuICAgIH0sIHNoYWxsb3cpO1xuICAgIGxldCBub2RlVHlwZSA9IG5vZGUudHlwZSB8fCAnZGVmYXVsdCc7XG4gICAgbGV0IE5vZGVDb21wb25lbnQgPSBub2RlVHlwZXM/Lltub2RlVHlwZV0gfHwgYnVpbHRpbk5vZGVUeXBlc1tub2RlVHlwZV07XG4gICAgaWYgKE5vZGVDb21wb25lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbkVycm9yPy4oJzAwMycsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAzJ10obm9kZVR5cGUpKTtcbiAgICAgICAgbm9kZVR5cGUgPSAnZGVmYXVsdCc7XG4gICAgICAgIE5vZGVDb21wb25lbnQgPSBidWlsdGluTm9kZVR5cGVzLmRlZmF1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gISEobm9kZS5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBub2RlLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc1NlbGVjdGFibGUgPSAhIShub2RlLnNlbGVjdGFibGUgfHwgKGVsZW1lbnRzU2VsZWN0YWJsZSAmJiB0eXBlb2Ygbm9kZS5zZWxlY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGlzQ29ubmVjdGFibGUgPSAhIShub2RlLmNvbm5lY3RhYmxlIHx8IChub2Rlc0Nvbm5lY3RhYmxlICYmIHR5cGVvZiBub2RlLmNvbm5lY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGlzRm9jdXNhYmxlID0gISEobm9kZS5mb2N1c2FibGUgfHwgKG5vZGVzRm9jdXNhYmxlICYmIHR5cGVvZiBub2RlLmZvY3VzYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgaGFzRGltZW5zaW9ucyA9IG5vZGVIYXNEaW1lbnNpb25zKG5vZGUpO1xuICAgIGNvbnN0IG5vZGVSZWYgPSB1c2VOb2RlT2JzZXJ2ZXIoeyBub2RlLCBub2RlVHlwZSwgaGFzRGltZW5zaW9ucywgcmVzaXplT2JzZXJ2ZXIgfSk7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB1c2VEcmFnKHtcbiAgICAgICAgbm9kZVJlZixcbiAgICAgICAgZGlzYWJsZWQ6IG5vZGUuaGlkZGVuIHx8ICFpc0RyYWdnYWJsZSxcbiAgICAgICAgbm9EcmFnQ2xhc3NOYW1lLFxuICAgICAgICBoYW5kbGVTZWxlY3Rvcjogbm9kZS5kcmFnSGFuZGxlLFxuICAgICAgICBub2RlSWQ6IGlkLFxuICAgICAgICBpc1NlbGVjdGFibGUsXG4gICAgICAgIG5vZGVDbGlja0Rpc3RhbmNlLFxuICAgIH0pO1xuICAgIGNvbnN0IG1vdmVTZWxlY3RlZE5vZGVzID0gdXNlTW92ZVNlbGVjdGVkTm9kZXMoKTtcbiAgICBpZiAobm9kZS5oaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVEaW1lbnNpb25zID0gZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSk7XG4gICAgY29uc3QgaW5saW5lRGltZW5zaW9ucyA9IGdldE5vZGVJbmxpbmVTdHlsZURpbWVuc2lvbnMobm9kZSk7XG4gICAgY29uc3QgaGFzUG9pbnRlckV2ZW50cyA9IGlzU2VsZWN0YWJsZSB8fCBpc0RyYWdnYWJsZSB8fCBvbkNsaWNrIHx8IG9uTW91c2VFbnRlciB8fCBvbk1vdXNlTW92ZSB8fCBvbk1vdXNlTGVhdmU7XG4gICAgY29uc3Qgb25Nb3VzZUVudGVySGFuZGxlciA9IG9uTW91c2VFbnRlclxuICAgICAgICA/IChldmVudCkgPT4gb25Nb3VzZUVudGVyKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbk1vdXNlTW92ZUhhbmRsZXIgPSBvbk1vdXNlTW92ZVxuICAgICAgICA/IChldmVudCkgPT4gb25Nb3VzZU1vdmUoZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uTW91c2VMZWF2ZUhhbmRsZXIgPSBvbk1vdXNlTGVhdmVcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uTW91c2VMZWF2ZShldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25Db250ZXh0TWVudUhhbmRsZXIgPSBvbkNvbnRleHRNZW51XG4gICAgICAgID8gKGV2ZW50KSA9PiBvbkNvbnRleHRNZW51KGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkRvdWJsZUNsaWNrSGFuZGxlciA9IG9uRG91YmxlQ2xpY2tcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uRG91YmxlQ2xpY2soZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uU2VsZWN0Tm9kZUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3ROb2Rlc09uRHJhZywgbm9kZURyYWdUaHJlc2hvbGQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChpc1NlbGVjdGFibGUgJiYgKCFzZWxlY3ROb2Rlc09uRHJhZyB8fCAhaXNEcmFnZ2FibGUgfHwgbm9kZURyYWdUaHJlc2hvbGQgPiAwKSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHRoaXMgaGFuZGxlciBnZXRzIGNhbGxlZCBieSBYWURyYWcgb24gZHJhZyBzdGFydCB3aGVuIHNlbGVjdE5vZGVzT25EcmFnPXRydWVcbiAgICAgICAgICAgICAqIGhlcmUgd2Ugb25seSBuZWVkIHRvIGNhbGwgaXQgd2hlbiBzZWxlY3ROb2Rlc09uRHJhZz1mYWxzZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgICAgIG5vZGVSZWYsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgb25DbGljayhldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoaXNJbnB1dERPTU5vZGUoZXZlbnQubmF0aXZlRXZlbnQpIHx8IGRpc2FibGVLZXlib2FyZEExMXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudFNlbGVjdGlvbktleXMuaW5jbHVkZXMoZXZlbnQua2V5KSAmJiBpc1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuc2VsZWN0ID0gZXZlbnQua2V5ID09PSAnRXNjYXBlJztcbiAgICAgICAgICAgIGhhbmRsZU5vZGVDbGljayh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgdW5zZWxlY3QsXG4gICAgICAgICAgICAgICAgbm9kZVJlZixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRHJhZ2dhYmxlICYmIG5vZGUuc2VsZWN0ZWQgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFycm93S2V5RGlmZnMsIGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgIC8vIHByZXZlbnQgZGVmYXVsdCBzY3JvbGxpbmcgYmVoYXZpb3Igb24gYXJyb3cga2V5IHByZXNzIHdoZW4gbm9kZSBpcyBtb3ZlZFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBhcmlhTGl2ZU1lc3NhZ2U6IGBNb3ZlZCBzZWxlY3RlZCBub2RlICR7ZXZlbnQua2V5XG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdBcnJvdycsICcnKVxuICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKX0uIE5ldyBwb3NpdGlvbiwgeDogJHt+fmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnh9LCB5OiAke35+aW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueX1gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtb3ZlU2VsZWN0ZWROb2Rlcyh7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBhcnJvd0tleURpZmZzW2V2ZW50LmtleV0sXG4gICAgICAgICAgICAgICAgZmFjdG9yOiBldmVudC5zaGlmdEtleSA/IDQgOiAxLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAncmVhY3QtZmxvd19fbm9kZScsXG4gICAgICAgICAgICBgcmVhY3QtZmxvd19fbm9kZS0ke25vZGVUeXBlfWAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBvdmVyd3JpdGFibGUgYnkgcGFzc2luZyBgbm9wYW5gIGFzIGEgY2xhc3MgbmFtZVxuICAgICAgICAgICAgICAgIFtub1BhbkNsYXNzTmFtZV06IGlzRHJhZ2dhYmxlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vZGUuY2xhc3NOYW1lLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBub2RlLnNlbGVjdGVkLFxuICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IGlzU2VsZWN0YWJsZSxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGlzUGFyZW50LFxuICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogaXNEcmFnZ2FibGUsXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKSwgcmVmOiBub2RlUmVmLCBzdHlsZToge1xuICAgICAgICAgICAgekluZGV4OiBpbnRlcm5hbHMueixcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke2ludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnh9cHgsJHtpbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55fXB4KWAsXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBoYXNQb2ludGVyRXZlbnRzID8gJ2FsbCcgOiAnbm9uZScsXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiBoYXNEaW1lbnNpb25zID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsXG4gICAgICAgICAgICAuLi5ub2RlLnN0eWxlLFxuICAgICAgICAgICAgLi4uaW5saW5lRGltZW5zaW9ucyxcbiAgICAgICAgfSwgXCJkYXRhLWlkXCI6IGlkLCBcImRhdGEtdGVzdGlkXCI6IGByZl9fbm9kZS0ke2lkfWAsIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVySGFuZGxlciwgb25Nb3VzZU1vdmU6IG9uTW91c2VNb3ZlSGFuZGxlciwgb25Nb3VzZUxlYXZlOiBvbk1vdXNlTGVhdmVIYW5kbGVyLCBvbkNvbnRleHRNZW51OiBvbkNvbnRleHRNZW51SGFuZGxlciwgb25DbGljazogb25TZWxlY3ROb2RlSGFuZGxlciwgb25Eb3VibGVDbGljazogb25Eb3VibGVDbGlja0hhbmRsZXIsIG9uS2V5RG93bjogaXNGb2N1c2FibGUgPyBvbktleURvd24gOiB1bmRlZmluZWQsIHRhYkluZGV4OiBpc0ZvY3VzYWJsZSA/IDAgOiB1bmRlZmluZWQsIHJvbGU6IGlzRm9jdXNhYmxlID8gJ2J1dHRvbicgOiB1bmRlZmluZWQsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBkaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogYCR7QVJJQV9OT0RFX0RFU0NfS0VZfS0ke3JmSWR9YCwgXCJhcmlhLWxhYmVsXCI6IG5vZGUuYXJpYUxhYmVsLCBjaGlsZHJlbjoganN4KFByb3ZpZGVyLCB7IHZhbHVlOiBpZCwgY2hpbGRyZW46IGpzeChOb2RlQ29tcG9uZW50LCB7IGlkOiBpZCwgZGF0YTogbm9kZS5kYXRhLCB0eXBlOiBub2RlVHlwZSwgcG9zaXRpb25BYnNvbHV0ZVg6IGludGVybmFscy5wb3NpdGlvbkFic29sdXRlLngsIHBvc2l0aW9uQWJzb2x1dGVZOiBpbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55LCBzZWxlY3RlZDogbm9kZS5zZWxlY3RlZCA/PyBmYWxzZSwgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLCBkcmFnZ2FibGU6IGlzRHJhZ2dhYmxlLCBkZWxldGFibGU6IG5vZGUuZGVsZXRhYmxlID8/IHRydWUsIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUsIHNvdXJjZVBvc2l0aW9uOiBub2RlLnNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbjogbm9kZS50YXJnZXRQb3NpdGlvbiwgZHJhZ2dpbmc6IGRyYWdnaW5nLCBkcmFnSGFuZGxlOiBub2RlLmRyYWdIYW5kbGUsIHpJbmRleDogaW50ZXJuYWxzLnosIHBhcmVudElkOiBub2RlLnBhcmVudElkLCAuLi5ub2RlRGltZW5zaW9ucyB9KSB9KSB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJGIgPSAocykgPT4gKHtcbiAgICBub2Rlc0RyYWdnYWJsZTogcy5ub2Rlc0RyYWdnYWJsZSxcbiAgICBub2Rlc0Nvbm5lY3RhYmxlOiBzLm5vZGVzQ29ubmVjdGFibGUsXG4gICAgbm9kZXNGb2N1c2FibGU6IHMubm9kZXNGb2N1c2FibGUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBvbkVycm9yOiBzLm9uRXJyb3IsXG59KTtcbmZ1bmN0aW9uIE5vZGVSZW5kZXJlckNvbXBvbmVudChwcm9wcykge1xuICAgIGNvbnN0IHsgbm9kZXNEcmFnZ2FibGUsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG9uRXJyb3IgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGIsIHNoYWxsb3cpO1xuICAgIGNvbnN0IG5vZGVJZHMgPSB1c2VWaXNpYmxlTm9kZUlkcyhwcm9wcy5vbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzKTtcbiAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IHVzZVJlc2l6ZU9ic2VydmVyKCk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbm9kZXNcIiwgc3R5bGU6IGNvbnRhaW5lclN0eWxlLCBjaGlsZHJlbjogbm9kZUlkcy5tYXAoKG5vZGVJZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBUaGUgc3BsaXQgb2YgcmVzcG9uc2liaWxpdGllcyBiZXR3ZWVuIE5vZGVSZW5kZXJlciBhbmRcbiAgICAgICAgICAgICAqIE5vZGVDb21wb25lbnRXcmFwcGVyIG1heSBhcHBlYXIgd2VpcmQuIEhvd2V2ZXIsIGl04oCZcyBkZXNpZ25lZCB0b1xuICAgICAgICAgICAgICogbWluaW1pemUgdGhlIGNvc3Qgb2YgdXBkYXRlcyB3aGVuIGluZGl2aWR1YWwgbm9kZXMgY2hhbmdlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEZvciBleGFtcGxlLCB3aGVuIHlvdeKAmXJlIGRyYWdnaW5nIGEgc2luZ2xlIG5vZGUsIHRoYXQgbm9kZSBnZXRzXG4gICAgICAgICAgICAgKiB1cGRhdGVkIG11bHRpcGxlIHRpbWVzIHBlciBzZWNvbmQuIElmIGBOb2RlUmVuZGVyZXJgIHdlcmUgdG8gdXBkYXRlXG4gICAgICAgICAgICAgKiBldmVyeSB0aW1lLCBpdCB3b3VsZCBoYXZlIHRvIHJlLXJ1biB0aGUgYG5vZGVzLm1hcCgpYCBsb29wIGV2ZXJ5XG4gICAgICAgICAgICAgKiB0aW1lLiBUaGlzIGdldHMgcHJpY2V5IHdpdGggaHVuZHJlZHMgb2Ygbm9kZXMsIGVzcGVjaWFsbHkgaWYgZXZlcnlcbiAgICAgICAgICAgICAqIGxvb3AgY3ljbGUgZG9lcyBtb3JlIHRoYW4ganVzdCByZW5kZXJpbmcgYSBKU1ggZWxlbWVudCFcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBBcyBhIHJlc3VsdCBvZiB0aGlzIGNob2ljZSwgd2UgdG9vayB0aGUgZm9sbG93aW5nIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAgKiBkZWNpc2lvbnM6XG4gICAgICAgICAgICAgKiAtIE5vZGVSZW5kZXJlciBzdWJzY3JpYmVzICpvbmx5KiB0byBub2RlIElEcyDigJMgYW5kIHRoZXJlZm9yZVxuICAgICAgICAgICAgICogICByZXJlbmRlciAqb25seSogd2hlbiB2aXNpYmxlIG5vZGVzIGFyZSBhZGRlZCBvciByZW1vdmVkLlxuICAgICAgICAgICAgICogLSBOb2RlUmVuZGVyZXIgcGVyZm9ybXMgYWxsIG9wZXJhdGlvbnMgdGhlIHJlc3VsdCBvZiB3aGljaCBjYW4gYmVcbiAgICAgICAgICAgICAqICAgc2hhcmVkIGJldHdlZW4gbm9kZXMgKHN1Y2ggYXMgY3JlYXRpbmcgdGhlIGBSZXNpemVPYnNlcnZlcmBcbiAgICAgICAgICAgICAqICAgaW5zdGFuY2UsIG9yIHN1YnNjcmliaW5nIHRvIGBzZWxlY3RvcmApLiBUaGlzIG1lYW5zIGV4dHJhIHByb3BcbiAgICAgICAgICAgICAqICAgZHJpbGxpbmcgaW50byBgTm9kZUNvbXBvbmVudFdyYXBwZXJgLCBidXQgaXQgbWVhbnMgd2UgbmVlZCB0byBydW5cbiAgICAgICAgICAgICAqICAgdGhlc2Ugb3BlcmF0aW9ucyBvbmx5IG9uY2Ug4oCTIGluc3RlYWQgb2Ygb25jZSBwZXIgbm9kZS5cbiAgICAgICAgICAgICAqIC0gQW55IG9wZXJhdGlvbnMgdGhhdCB5b3XigJlkIG5vcm1hbGx5IHdyaXRlIGluc2lkZSBgbm9kZXMubWFwYCBhcmVcbiAgICAgICAgICAgICAqICAgbW92ZWQgaW50byBgTm9kZUNvbXBvbmVudFdyYXBwZXJgLiBUaGlzIGVuc3VyZXMgdGhleSBhcmVcbiAgICAgICAgICAgICAqICAgbWVtb3JpemVkIOKAkyBzbyBpZiBgTm9kZVJlbmRlcmVyYCAqaGFzKiB0byByZXJlbmRlciwgaXQgb25seVxuICAgICAgICAgICAgICogICBuZWVkcyB0byByZWdlbmVyYXRlIHRoZSBsaXN0IG9mIG5vZGVzLCBub3RoaW5nIGVsc2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGpzeChOb2RlV3JhcHBlciwgeyBpZDogbm9kZUlkLCBub2RlVHlwZXM6IHByb3BzLm5vZGVUeXBlcywgbm9kZUV4dGVudDogcHJvcHMubm9kZUV4dGVudCwgb25DbGljazogcHJvcHMub25Ob2RlQ2xpY2ssIG9uTW91c2VFbnRlcjogcHJvcHMub25Ob2RlTW91c2VFbnRlciwgb25Nb3VzZU1vdmU6IHByb3BzLm9uTm9kZU1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlOiBwcm9wcy5vbk5vZGVNb3VzZUxlYXZlLCBvbkNvbnRleHRNZW51OiBwcm9wcy5vbk5vZGVDb250ZXh0TWVudSwgb25Eb3VibGVDbGljazogcHJvcHMub25Ob2RlRG91YmxlQ2xpY2ssIG5vRHJhZ0NsYXNzTmFtZTogcHJvcHMubm9EcmFnQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZTogcHJvcHMubm9QYW5DbGFzc05hbWUsIHJmSWQ6IHByb3BzLnJmSWQsIGRpc2FibGVLZXlib2FyZEExMXk6IHByb3BzLmRpc2FibGVLZXlib2FyZEExMXksIHJlc2l6ZU9ic2VydmVyOiByZXNpemVPYnNlcnZlciwgbm9kZXNEcmFnZ2FibGU6IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlOiBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZTogbm9kZXNGb2N1c2FibGUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCBub2RlQ2xpY2tEaXN0YW5jZTogcHJvcHMubm9kZUNsaWNrRGlzdGFuY2UsIG9uRXJyb3I6IG9uRXJyb3IgfSwgbm9kZUlkKSk7XG4gICAgICAgIH0pIH0pKTtcbn1cbk5vZGVSZW5kZXJlckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdOb2RlUmVuZGVyZXInO1xuY29uc3QgTm9kZVJlbmRlcmVyID0gbWVtbyhOb2RlUmVuZGVyZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEhvb2sgZm9yIGdldHRpbmcgdGhlIHZpc2libGUgZWRnZSBpZHMgZnJvbSB0aGUgc3RvcmUuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gb25seVJlbmRlclZpc2libGVcbiAqIEByZXR1cm5zIGFycmF5IHdpdGggdmlzaWJsZSBlZGdlIGlkc1xuICovXG5mdW5jdGlvbiB1c2VWaXNpYmxlRWRnZUlkcyhvbmx5UmVuZGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IGVkZ2VJZHMgPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygocykgPT4ge1xuICAgICAgICBpZiAoIW9ubHlSZW5kZXJWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5lZGdlcy5tYXAoKGVkZ2UpID0+IGVkZ2UuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpc2libGVFZGdlSWRzID0gW107XG4gICAgICAgIGlmIChzLndpZHRoICYmIHMuaGVpZ2h0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2Ygcy5lZGdlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBzLm5vZGVMb29rdXAuZ2V0KGVkZ2Uuc291cmNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gcy5ub2RlTG9va3VwLmdldChlZGdlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZU5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0VkZ2VWaXNpYmxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZU5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUVkZ2VJZHMucHVzaChlZGdlLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpc2libGVFZGdlSWRzO1xuICAgIH0sIFtvbmx5UmVuZGVyVmlzaWJsZV0pLCBzaGFsbG93KTtcbiAgICByZXR1cm4gZWRnZUlkcztcbn1cblxuY29uc3QgQXJyb3dTeW1ib2wgPSAoeyBjb2xvciA9ICdub25lJywgc3Ryb2tlV2lkdGggPSAxIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeChcInBvbHlsaW5lXCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogY29sb3IsXG4gICAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgfSwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLCBmaWxsOiBcIm5vbmVcIiwgcG9pbnRzOiBcIi01LC00IDAsMCAtNSw0XCIgfSkpO1xufTtcbmNvbnN0IEFycm93Q2xvc2VkU3ltYm9sID0gKHsgY29sb3IgPSAnbm9uZScsIHN0cm9rZVdpZHRoID0gMSB9KSA9PiB7XG4gICAgcmV0dXJuIChqc3goXCJwb2x5bGluZVwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgICAgICAgZmlsbDogY29sb3IsXG4gICAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgfSwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLCBwb2ludHM6IFwiLTUsLTQgMCwwIC01LDQgLTUsLTRcIiB9KSk7XG59O1xuY29uc3QgTWFya2VyU3ltYm9scyA9IHtcbiAgICBbTWFya2VyVHlwZS5BcnJvd106IEFycm93U3ltYm9sLFxuICAgIFtNYXJrZXJUeXBlLkFycm93Q2xvc2VkXTogQXJyb3dDbG9zZWRTeW1ib2wsXG59O1xuZnVuY3Rpb24gdXNlTWFya2VyU3ltYm9sKHR5cGUpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgc3ltYm9sID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bWJvbEV4aXN0cyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChNYXJrZXJTeW1ib2xzLCB0eXBlKTtcbiAgICAgICAgaWYgKCFzeW1ib2xFeGlzdHMpIHtcbiAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMDknLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwOSddKHR5cGUpKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXJrZXJTeW1ib2xzW3R5cGVdO1xuICAgIH0sIFt0eXBlXSk7XG4gICAgcmV0dXJuIHN5bWJvbDtcbn1cblxuY29uc3QgTWFya2VyID0gKHsgaWQsIHR5cGUsIGNvbG9yLCB3aWR0aCA9IDEyLjUsIGhlaWdodCA9IDEyLjUsIG1hcmtlclVuaXRzID0gJ3N0cm9rZVdpZHRoJywgc3Ryb2tlV2lkdGgsIG9yaWVudCA9ICdhdXRvLXN0YXJ0LXJldmVyc2UnLCB9KSA9PiB7XG4gICAgY29uc3QgU3ltYm9sID0gdXNlTWFya2VyU3ltYm9sKHR5cGUpO1xuICAgIGlmICghU3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChcIm1hcmtlclwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19hcnJvd2hlYWRcIiwgaWQ6IGlkLCBtYXJrZXJXaWR0aDogYCR7d2lkdGh9YCwgbWFya2VySGVpZ2h0OiBgJHtoZWlnaHR9YCwgdmlld0JveDogXCItMTAgLTEwIDIwIDIwXCIsIG1hcmtlclVuaXRzOiBtYXJrZXJVbml0cywgb3JpZW50OiBvcmllbnQsIHJlZlg6IFwiMFwiLCByZWZZOiBcIjBcIiwgY2hpbGRyZW46IGpzeChTeW1ib2wsIHsgY29sb3I6IGNvbG9yLCBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGggfSkgfSkpO1xufTtcbi8qXG4gKiB3aGVuIHlvdSBoYXZlIG11bHRpcGxlIGZsb3dzIG9uIGEgcGFnZSBhbmQgeW91IGhpZGUgdGhlIGZpcnN0IG9uZSwgdGhlIG90aGVyIG9uZXMgaGF2ZSBubyBtYXJrZXJzIGFueW1vcmVcbiAqIHdoZW4gdGhleSBkbyBoYXZlIG1hcmtlcnMgd2l0aCB0aGUgc2FtZSBpZHMuIFRvIHByZXZlbnQgdGhpcyB0aGUgdXNlciBjYW4gcGFzcyBhIHVuaXF1ZSBpZCB0byB0aGUgcmVhY3QgZmxvdyB3cmFwcGVyXG4gKiB0aGF0IHdlIGNhbiB0aGVuIHVzZSBmb3IgY3JlYXRpbmcgb3VyIHVuaXF1ZSBtYXJrZXIgaWRzXG4gKi9cbmNvbnN0IE1hcmtlckRlZmluaXRpb25zID0gKHsgZGVmYXVsdENvbG9yLCByZklkIH0pID0+IHtcbiAgICBjb25zdCBlZGdlcyA9IHVzZVN0b3JlKChzKSA9PiBzLmVkZ2VzKTtcbiAgICBjb25zdCBkZWZhdWx0RWRnZU9wdGlvbnMgPSB1c2VTdG9yZSgocykgPT4gcy5kZWZhdWx0RWRnZU9wdGlvbnMpO1xuICAgIGNvbnN0IG1hcmtlcnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWFya2VycyA9IGNyZWF0ZU1hcmtlcklkcyhlZGdlcywge1xuICAgICAgICAgICAgaWQ6IHJmSWQsXG4gICAgICAgICAgICBkZWZhdWx0Q29sb3IsXG4gICAgICAgICAgICBkZWZhdWx0TWFya2VyU3RhcnQ6IGRlZmF1bHRFZGdlT3B0aW9ucz8ubWFya2VyU3RhcnQsXG4gICAgICAgICAgICBkZWZhdWx0TWFya2VyRW5kOiBkZWZhdWx0RWRnZU9wdGlvbnM/Lm1hcmtlckVuZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH0sIFtlZGdlcywgZGVmYXVsdEVkZ2VPcHRpb25zLCByZklkLCBkZWZhdWx0Q29sb3JdKTtcbiAgICBpZiAoIW1hcmtlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19tYXJrZXJcIiwgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiwgY2hpbGRyZW46IGpzeChcImRlZnNcIiwgeyBjaGlsZHJlbjogbWFya2Vycy5tYXAoKG1hcmtlcikgPT4gKGpzeChNYXJrZXIsIHsgaWQ6IG1hcmtlci5pZCwgdHlwZTogbWFya2VyLnR5cGUsIGNvbG9yOiBtYXJrZXIuY29sb3IsIHdpZHRoOiBtYXJrZXIud2lkdGgsIGhlaWdodDogbWFya2VyLmhlaWdodCwgbWFya2VyVW5pdHM6IG1hcmtlci5tYXJrZXJVbml0cywgc3Ryb2tlV2lkdGg6IG1hcmtlci5zdHJva2VXaWR0aCwgb3JpZW50OiBtYXJrZXIub3JpZW50IH0sIG1hcmtlci5pZCkpKSB9KSB9KSk7XG59O1xuTWFya2VyRGVmaW5pdGlvbnMuZGlzcGxheU5hbWUgPSAnTWFya2VyRGVmaW5pdGlvbnMnO1xudmFyIE1hcmtlckRlZmluaXRpb25zJDEgPSBtZW1vKE1hcmtlckRlZmluaXRpb25zKTtcblxuZnVuY3Rpb24gRWRnZVRleHRDb21wb25lbnQoeyB4LCB5LCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcgPSB0cnVlLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nID0gWzIsIDRdLCBsYWJlbEJnQm9yZGVyUmFkaXVzID0gMiwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgLi4ucmVzdCB9KSB7XG4gICAgY29uc3QgW2VkZ2VUZXh0QmJveCwgc2V0RWRnZVRleHRCYm94XSA9IHVzZVN0YXRlKHsgeDogMSwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcbiAgICBjb25zdCBlZGdlVGV4dENsYXNzZXMgPSBjYyhbJ3JlYWN0LWZsb3dfX2VkZ2UtdGV4dHdyYXBwZXInLCBjbGFzc05hbWVdKTtcbiAgICBjb25zdCBlZGdlVGV4dFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZWRnZVRleHRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dEJib3ggPSBlZGdlVGV4dFJlZi5jdXJyZW50LmdldEJCb3goKTtcbiAgICAgICAgICAgIHNldEVkZ2VUZXh0QmJveCh7XG4gICAgICAgICAgICAgICAgeDogdGV4dEJib3gueCxcbiAgICAgICAgICAgICAgICB5OiB0ZXh0QmJveC55LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0ZXh0QmJveC53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRleHRCYm94LmhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2xhYmVsXSk7XG4gICAgaWYgKCFsYWJlbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hzKFwiZ1wiLCB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke3ggLSBlZGdlVGV4dEJib3gud2lkdGggLyAyfSAke3kgLSBlZGdlVGV4dEJib3guaGVpZ2h0IC8gMn0pYCwgY2xhc3NOYW1lOiBlZGdlVGV4dENsYXNzZXMsIHZpc2liaWxpdHk6IGVkZ2VUZXh0QmJveC53aWR0aCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nLCAuLi5yZXN0LCBjaGlsZHJlbjogW2xhYmVsU2hvd0JnICYmIChqc3goXCJyZWN0XCIsIHsgd2lkdGg6IGVkZ2VUZXh0QmJveC53aWR0aCArIDIgKiBsYWJlbEJnUGFkZGluZ1swXSwgeDogLWxhYmVsQmdQYWRkaW5nWzBdLCB5OiAtbGFiZWxCZ1BhZGRpbmdbMV0sIGhlaWdodDogZWRnZVRleHRCYm94LmhlaWdodCArIDIgKiBsYWJlbEJnUGFkZGluZ1sxXSwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtdGV4dGJnXCIsIHN0eWxlOiBsYWJlbEJnU3R5bGUsIHJ4OiBsYWJlbEJnQm9yZGVyUmFkaXVzLCByeTogbGFiZWxCZ0JvcmRlclJhZGl1cyB9KSksIGpzeChcInRleHRcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZS10ZXh0XCIsIHk6IGVkZ2VUZXh0QmJveC5oZWlnaHQgLyAyLCBkeTogXCIwLjNlbVwiLCByZWY6IGVkZ2VUZXh0UmVmLCBzdHlsZTogbGFiZWxTdHlsZSwgY2hpbGRyZW46IGxhYmVsIH0pLCBjaGlsZHJlbl0gfSkpO1xufVxuRWRnZVRleHRDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnRWRnZVRleHQnO1xuLyoqXG4gKiBZb3UgY2FuIHVzZSB0aGUgYDxFZGdlVGV4dCAvPmAgY29tcG9uZW50IGFzIGEgaGVscGVyIGNvbXBvbmVudCB0byBkaXNwbGF5IHRleHRcbiAqIHdpdGhpbiB5b3VyIGN1c3RvbSBlZGdlcy5cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgRWRnZVRleHQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBleHBvcnQgZnVuY3Rpb24gQ3VzdG9tRWRnZUxhYmVsKHsgbGFiZWwgfSkge1xuICogICByZXR1cm4gKFxuICogICAgIDxFZGdlVGV4dFxuICogICAgICAgeD17MTAwfVxuICogICAgICAgeT17MTAwfVxuICogICAgICAgbGFiZWw9e2xhYmVsfVxuICogICAgICAgbGFiZWxTdHlsZT17eyBmaWxsOiAnd2hpdGUnIH19XG4gKiAgICAgICBsYWJlbFNob3dCZ1xuICogICAgICAgbGFiZWxCZ1N0eWxlPXt7IGZpbGw6ICdyZWQnIH19XG4gKiAgICAgICBsYWJlbEJnUGFkZGluZz17WzIsIDRdfVxuICogICAgICAgbGFiZWxCZ0JvcmRlclJhZGl1cz17Mn1cbiAqICAgICAvPlxuICogICApO1xuICogfVxuICpgYGBcbiAqL1xuY29uc3QgRWRnZVRleHQgPSBtZW1vKEVkZ2VUZXh0Q29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgYDxCYXNlRWRnZSAvPmAgY29tcG9uZW50IGdldHMgdXNlZCBpbnRlcm5hbGx5IGZvciBhbGwgdGhlIGVkZ2VzLiBJdCBjYW4gYmVcbiAqIHVzZWQgaW5zaWRlIGEgY3VzdG9tIGVkZ2UgYW5kIGhhbmRsZXMgdGhlIGludmlzaWJsZSBoZWxwZXIgZWRnZSBhbmQgdGhlIGVkZ2UgbGFiZWxcbiAqIGZvciB5b3UuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyBCYXNlRWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCAuLi5wcm9wcyB9KSB7XG4gKiAgY29uc3QgW2VkZ2VQYXRoXSA9IGdldFN0cmFpZ2h0UGF0aCh7XG4gKiAgICBzb3VyY2VYLFxuICogICAgc291cmNlWSxcbiAqICAgIHRhcmdldFgsXG4gKiAgICB0YXJnZXRZLFxuICogIH0pO1xuICpcbiAqICByZXR1cm4gPEJhc2VFZGdlIHBhdGg9e2VkZ2VQYXRofSB7Li4ucHJvcHN9IC8+O1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIElmIHlvdSB3YW50IHRvIHVzZSBhbiBlZGdlIG1hcmtlciB3aXRoIHRoZSBbYDxCYXNlRWRnZSAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvYmFzZS1lZGdlKSBjb21wb25lbnQsXG4gKiB5b3UgY2FuIHBhc3MgdGhlIGBtYXJrZXJTdGFydGAgb3IgYG1hcmtlckVuZGAgcHJvcHMgcGFzc2VkIHRvIHlvdXIgY3VzdG9tIGVkZ2VcbiAqIHRocm91Z2ggdG8gdGhlIFtgPEJhc2VFZGdlIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9iYXNlLWVkZ2UpIGNvbXBvbmVudC5cbiAqIFlvdSBjYW4gc2VlIGFsbCB0aGUgcHJvcHMgcGFzc2VkIHRvIGEgY3VzdG9tIGVkZ2UgYnkgbG9va2luZyBhdCB0aGUgW2BFZGdlUHJvcHNgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9lZGdlLXByb3BzKSB0eXBlLlxuICovXG5mdW5jdGlvbiBCYXNlRWRnZSh7IHBhdGgsIGxhYmVsWCwgbGFiZWxZLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIGludGVyYWN0aW9uV2lkdGggPSAyMCwgLi4ucHJvcHMgfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwgeyAuLi5wcm9wcywgZDogcGF0aCwgZmlsbDogXCJub25lXCIsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19lZGdlLXBhdGgnLCBwcm9wcy5jbGFzc05hbWVdKSB9KSwgaW50ZXJhY3Rpb25XaWR0aCAmJiAoanN4KFwicGF0aFwiLCB7IGQ6IHBhdGgsIGZpbGw6IFwibm9uZVwiLCBzdHJva2VPcGFjaXR5OiAwLCBzdHJva2VXaWR0aDogaW50ZXJhY3Rpb25XaWR0aCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtaW50ZXJhY3Rpb25cIiB9KSksIGxhYmVsICYmIGlzTnVtZXJpYyhsYWJlbFgpICYmIGlzTnVtZXJpYyhsYWJlbFkpID8gKGpzeChFZGdlVGV4dCwgeyB4OiBsYWJlbFgsIHk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMgfSkpIDogbnVsbF0gfSkpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250cm9sKHsgcG9zLCB4MSwgeTEsIHgyLCB5MiB9KSB7XG4gICAgaWYgKHBvcyA9PT0gUG9zaXRpb24uTGVmdCB8fCBwb3MgPT09IFBvc2l0aW9uLlJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBbMC41ICogKHgxICsgeDIpLCB5MV07XG4gICAgfVxuICAgIHJldHVybiBbeDEsIDAuNSAqICh5MSArIHkyKV07XG59XG4vKipcbiAqIFRoZSBgZ2V0U2ltcGxlQmV6aWVyUGF0aGAgdXRpbCByZXR1cm5zIGV2ZXJ5dGhpbmcgeW91IG5lZWQgdG8gcmVuZGVyIGEgc2ltcGxlXG4gKiBiZXppZXIgZWRnZSBiZXR3ZWVuIHR3byBub2Rlcy5cbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zXG4gKiAtIGBwYXRoYDogdGhlIHBhdGggdG8gdXNlIGluIGFuIFNWRyBgPHBhdGg+YCBlbGVtZW50LlxuICogLSBgbGFiZWxYYDogdGhlIGB4YCBwb3NpdGlvbiB5b3UgY2FuIHVzZSB0byByZW5kZXIgYSBsYWJlbCBmb3IgdGhpcyBlZGdlLlxuICogLSBgbGFiZWxZYDogdGhlIGB5YCBwb3NpdGlvbiB5b3UgY2FuIHVzZSB0byByZW5kZXIgYSBsYWJlbCBmb3IgdGhpcyBlZGdlLlxuICogLSBgb2Zmc2V0WGA6IHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNvdXJjZSBgeGAgcG9zaXRpb24gYW5kIHRoZSBgeGAgcG9zaXRpb24gb2YgdGhlXG4gKiBtaWRkbGUgb2YgdGhpcyBwYXRoLlxuICogLSBgb2Zmc2V0WWA6IHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNvdXJjZSBgeWAgcG9zaXRpb24gYW5kIHRoZSBgeWAgcG9zaXRpb24gb2YgdGhlXG4gKiBtaWRkbGUgb2YgdGhpcyBwYXRoLlxuICovXG5mdW5jdGlvbiBnZXRTaW1wbGVCZXppZXJQYXRoKHsgc291cmNlWCwgc291cmNlWSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFgsIHRhcmdldFksIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCB9KSB7XG4gICAgY29uc3QgW3NvdXJjZUNvbnRyb2xYLCBzb3VyY2VDb250cm9sWV0gPSBnZXRDb250cm9sKHtcbiAgICAgICAgcG9zOiBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgeDE6IHNvdXJjZVgsXG4gICAgICAgIHkxOiBzb3VyY2VZLFxuICAgICAgICB4MjogdGFyZ2V0WCxcbiAgICAgICAgeTI6IHRhcmdldFksXG4gICAgfSk7XG4gICAgY29uc3QgW3RhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWV0gPSBnZXRDb250cm9sKHtcbiAgICAgICAgcG9zOiB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgeDE6IHRhcmdldFgsXG4gICAgICAgIHkxOiB0YXJnZXRZLFxuICAgICAgICB4Mjogc291cmNlWCxcbiAgICAgICAgeTI6IHNvdXJjZVksXG4gICAgfSk7XG4gICAgY29uc3QgW2xhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldEJlemllckVkZ2VDZW50ZXIoe1xuICAgICAgICBzb3VyY2VYLFxuICAgICAgICBzb3VyY2VZLFxuICAgICAgICB0YXJnZXRYLFxuICAgICAgICB0YXJnZXRZLFxuICAgICAgICBzb3VyY2VDb250cm9sWCxcbiAgICAgICAgc291cmNlQ29udHJvbFksXG4gICAgICAgIHRhcmdldENvbnRyb2xYLFxuICAgICAgICB0YXJnZXRDb250cm9sWSxcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBgTSR7c291cmNlWH0sJHtzb3VyY2VZfSBDJHtzb3VyY2VDb250cm9sWH0sJHtzb3VyY2VDb250cm9sWX0gJHt0YXJnZXRDb250cm9sWH0sJHt0YXJnZXRDb250cm9sWX0gJHt0YXJnZXRYfSwke3RhcmdldFl9YCxcbiAgICAgICAgbGFiZWxYLFxuICAgICAgICBsYWJlbFksXG4gICAgICAgIG9mZnNldFgsXG4gICAgICAgIG9mZnNldFksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNpbXBsZUJlemllckVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24sIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFNpbXBsZUJlemllclBhdGgoe1xuICAgICAgICAgICAgc291cmNlWCxcbiAgICAgICAgICAgIHNvdXJjZVksXG4gICAgICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgICAgIHRhcmdldFgsXG4gICAgICAgICAgICB0YXJnZXRZLFxuICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuY29uc3QgU2ltcGxlQmV6aWVyRWRnZSA9IGNyZWF0ZVNpbXBsZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbmNvbnN0IFNpbXBsZUJlemllckVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVNpbXBsZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuU2ltcGxlQmV6aWVyRWRnZS5kaXNwbGF5TmFtZSA9ICdTaW1wbGVCZXppZXJFZGdlJztcblNpbXBsZUJlemllckVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdTaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVTbW9vdGhTdGVwRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgcGF0aE9wdGlvbnMsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFNtb290aFN0ZXBQYXRoKHtcbiAgICAgICAgICAgIHNvdXJjZVgsXG4gICAgICAgICAgICBzb3VyY2VZLFxuICAgICAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgICAgICB0YXJnZXRYLFxuICAgICAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBwYXRoT3B0aW9ucz8uYm9yZGVyUmFkaXVzLFxuICAgICAgICAgICAgb2Zmc2V0OiBwYXRoT3B0aW9ucz8ub2Zmc2V0LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goQmFzZUVkZ2UsIHsgaWQ6IF9pZCwgcGF0aDogcGF0aCwgbGFiZWxYOiBsYWJlbFgsIGxhYmVsWTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGU6IHN0eWxlLCBtYXJrZXJFbmQ6IG1hcmtlckVuZCwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoOiBpbnRlcmFjdGlvbldpZHRoIH0pKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlIGEgY3VzdG9tIGVkZ2UgdG8gcmVuZGVyIGEgc21vb3RoIHN0ZXAgZWRnZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzeFxuICogaW1wb3J0IHsgU21vb3RoU3RlcEVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBmdW5jdGlvbiBDdXN0b21FZGdlKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uIH0pIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8U21vb3RoU3RlcEVkZ2VcbiAqICAgICAgIHNvdXJjZVg9e3NvdXJjZVh9XG4gKiAgICAgICBzb3VyY2VZPXtzb3VyY2VZfVxuICogICAgICAgdGFyZ2V0WD17dGFyZ2V0WH1cbiAqICAgICAgIHRhcmdldFk9e3RhcmdldFl9XG4gKiAgICAgICBzb3VyY2VQb3NpdGlvbj17c291cmNlUG9zaXRpb259XG4gKiAgICAgICB0YXJnZXRQb3NpdGlvbj17dGFyZ2V0UG9zaXRpb259XG4gKiAgICAgLz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCBTbW9vdGhTdGVwRWRnZSA9IGNyZWF0ZVNtb290aFN0ZXBFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTbW9vdGhTdGVwRWRnZUludGVybmFsID0gY3JlYXRlU21vb3RoU3RlcEVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuU21vb3RoU3RlcEVkZ2UuZGlzcGxheU5hbWUgPSAnU21vb3RoU3RlcEVkZ2UnO1xuU21vb3RoU3RlcEVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdTbW9vdGhTdGVwRWRnZUludGVybmFsJztcblxuZnVuY3Rpb24gY3JlYXRlU3RlcEVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KFNtb290aFN0ZXBFZGdlLCB7IC4uLnByb3BzLCBpZDogX2lkLCBwYXRoT3B0aW9uczogdXNlTWVtbygoKSA9PiAoeyBib3JkZXJSYWRpdXM6IDAsIG9mZnNldDogcHJvcHMucGF0aE9wdGlvbnM/Lm9mZnNldCB9KSwgW3Byb3BzLnBhdGhPcHRpb25zPy5vZmZzZXRdKSB9KSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIGluc2lkZSBhIGN1c3RvbSBlZGdlIHRvIHJlbmRlciBhIHN0ZXAgZWRnZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzeFxuICogaW1wb3J0IHsgU3RlcEVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBmdW5jdGlvbiBDdXN0b21FZGdlKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uIH0pIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8U3RlcEVkZ2VcbiAqICAgICAgIHNvdXJjZVg9e3NvdXJjZVh9XG4gKiAgICAgICBzb3VyY2VZPXtzb3VyY2VZfVxuICogICAgICAgdGFyZ2V0WD17dGFyZ2V0WH1cbiAqICAgICAgIHRhcmdldFk9e3RhcmdldFl9XG4gKiAgICAgICBzb3VyY2VQb3NpdGlvbj17c291cmNlUG9zaXRpb259XG4gKiAgICAgICB0YXJnZXRQb3NpdGlvbj17dGFyZ2V0UG9zaXRpb259XG4gKiAgICAgLz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCBTdGVwRWRnZSA9IGNyZWF0ZVN0ZXBFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTdGVwRWRnZUludGVybmFsID0gY3JlYXRlU3RlcEVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuU3RlcEVkZ2UuZGlzcGxheU5hbWUgPSAnU3RlcEVkZ2UnO1xuU3RlcEVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdTdGVwRWRnZUludGVybmFsJztcblxuZnVuY3Rpb24gY3JlYXRlU3RyYWlnaHRFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgICAgICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFldID0gZ2V0U3RyYWlnaHRQYXRoKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSB9KTtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goQmFzZUVkZ2UsIHsgaWQ6IF9pZCwgcGF0aDogcGF0aCwgbGFiZWxYOiBsYWJlbFgsIGxhYmVsWTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGU6IHN0eWxlLCBtYXJrZXJFbmQ6IG1hcmtlckVuZCwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoOiBpbnRlcmFjdGlvbldpZHRoIH0pKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlIGEgY3VzdG9tIGVkZ2UgdG8gcmVuZGVyIGEgc3RyYWlnaHQgbGluZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzeFxuICogaW1wb3J0IHsgU3RyYWlnaHRFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFkgfSkge1xuICogICByZXR1cm4gKFxuICogICAgIDxTdHJhaWdodEVkZ2VcbiAqICAgICAgIHNvdXJjZVg9e3NvdXJjZVh9XG4gKiAgICAgICBzb3VyY2VZPXtzb3VyY2VZfVxuICogICAgICAgdGFyZ2V0WD17dGFyZ2V0WH1cbiAqICAgICAgIHRhcmdldFk9e3RhcmdldFl9XG4gKiAgICAgLz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCBTdHJhaWdodEVkZ2UgPSBjcmVhdGVTdHJhaWdodEVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFN0cmFpZ2h0RWRnZUludGVybmFsID0gY3JlYXRlU3RyYWlnaHRFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcblN0cmFpZ2h0RWRnZS5kaXNwbGF5TmFtZSA9ICdTdHJhaWdodEVkZ2UnO1xuU3RyYWlnaHRFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnU3RyYWlnaHRFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVCZXppZXJFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBwYXRoT3B0aW9ucywgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgICAgICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFldID0gZ2V0QmV6aWVyUGF0aCh7XG4gICAgICAgICAgICBzb3VyY2VYLFxuICAgICAgICAgICAgc291cmNlWSxcbiAgICAgICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgICAgIHRhcmdldFksXG4gICAgICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgICAgIGN1cnZhdHVyZTogcGF0aE9wdGlvbnM/LmN1cnZhdHVyZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KEJhc2VFZGdlLCB7IGlkOiBfaWQsIHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIGluc2lkZSBhIGN1c3RvbSBlZGdlIHRvIHJlbmRlciBhIGJlemllciBjdXJ2ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzeFxuICogaW1wb3J0IHsgQmV6aWVyRWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24gfSkge1xuICogICByZXR1cm4gKFxuICogICAgIDxCZXppZXJFZGdlXG4gKiAgICAgICBzb3VyY2VYPXtzb3VyY2VYfVxuICogICAgICAgc291cmNlWT17c291cmNlWX1cbiAqICAgICAgIHRhcmdldFg9e3RhcmdldFh9XG4gKiAgICAgICB0YXJnZXRZPXt0YXJnZXRZfVxuICogICAgICAgc291cmNlUG9zaXRpb249e3NvdXJjZVBvc2l0aW9ufVxuICogICAgICAgdGFyZ2V0UG9zaXRpb249e3RhcmdldFBvc2l0aW9ufVxuICogICAgIC8+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgQmV6aWVyRWRnZSA9IGNyZWF0ZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEJlemllckVkZ2VJbnRlcm5hbCA9IGNyZWF0ZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuQmV6aWVyRWRnZS5kaXNwbGF5TmFtZSA9ICdCZXppZXJFZGdlJztcbkJlemllckVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdCZXppZXJFZGdlSW50ZXJuYWwnO1xuXG5jb25zdCBidWlsdGluRWRnZVR5cGVzID0ge1xuICAgIGRlZmF1bHQ6IEJlemllckVkZ2VJbnRlcm5hbCxcbiAgICBzdHJhaWdodDogU3RyYWlnaHRFZGdlSW50ZXJuYWwsXG4gICAgc3RlcDogU3RlcEVkZ2VJbnRlcm5hbCxcbiAgICBzbW9vdGhzdGVwOiBTbW9vdGhTdGVwRWRnZUludGVybmFsLFxuICAgIHNpbXBsZWJlemllcjogU2ltcGxlQmV6aWVyRWRnZUludGVybmFsLFxufTtcbmNvbnN0IG51bGxQb3NpdGlvbiA9IHtcbiAgICBzb3VyY2VYOiBudWxsLFxuICAgIHNvdXJjZVk6IG51bGwsXG4gICAgdGFyZ2V0WDogbnVsbCxcbiAgICB0YXJnZXRZOiBudWxsLFxuICAgIHNvdXJjZVBvc2l0aW9uOiBudWxsLFxuICAgIHRhcmdldFBvc2l0aW9uOiBudWxsLFxufTtcblxuY29uc3Qgc2hpZnRYID0gKHgsIHNoaWZ0LCBwb3NpdGlvbikgPT4ge1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uTGVmdClcbiAgICAgICAgcmV0dXJuIHggLSBzaGlmdDtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLlJpZ2h0KVxuICAgICAgICByZXR1cm4geCArIHNoaWZ0O1xuICAgIHJldHVybiB4O1xufTtcbmNvbnN0IHNoaWZ0WSA9ICh5LCBzaGlmdCwgcG9zaXRpb24pID0+IHtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLlRvcClcbiAgICAgICAgcmV0dXJuIHkgLSBzaGlmdDtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLkJvdHRvbSlcbiAgICAgICAgcmV0dXJuIHkgKyBzaGlmdDtcbiAgICByZXR1cm4geTtcbn07XG5jb25zdCBFZGdlVXBkYXRlckNsYXNzTmFtZSA9ICdyZWFjdC1mbG93X19lZGdldXBkYXRlcic7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBFZGdlQW5jaG9yKHsgcG9zaXRpb24sIGNlbnRlclgsIGNlbnRlclksIHJhZGl1cyA9IDEwLCBvbk1vdXNlRG93biwgb25Nb3VzZUVudGVyLCBvbk1vdXNlT3V0LCB0eXBlLCB9KSB7XG4gICAgcmV0dXJuIChqc3goXCJjaXJjbGVcIiwgeyBvbk1vdXNlRG93bjogb25Nb3VzZURvd24sIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyLCBvbk1vdXNlT3V0OiBvbk1vdXNlT3V0LCBjbGFzc05hbWU6IGNjKFtFZGdlVXBkYXRlckNsYXNzTmFtZSwgYCR7RWRnZVVwZGF0ZXJDbGFzc05hbWV9LSR7dHlwZX1gXSksIGN4OiBzaGlmdFgoY2VudGVyWCwgcmFkaXVzLCBwb3NpdGlvbiksIGN5OiBzaGlmdFkoY2VudGVyWSwgcmFkaXVzLCBwb3NpdGlvbiksIHI6IHJhZGl1cywgc3Ryb2tlOiBcInRyYW5zcGFyZW50XCIsIGZpbGw6IFwidHJhbnNwYXJlbnRcIiB9KSk7XG59XG5cbmZ1bmN0aW9uIEVkZ2VVcGRhdGVBbmNob3JzKHsgaXNSZWNvbm5lY3RhYmxlLCByZWNvbm5lY3RSYWRpdXMsIGVkZ2UsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiwgb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBzZXRSZWNvbm5lY3RpbmcsIHNldFVwZGF0ZUhvdmVyLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGhhbmRsZUVkZ2VVcGRhdGVyID0gKGV2ZW50LCBvcHBvc2l0ZUhhbmRsZSkgPT4ge1xuICAgICAgICAvLyBhdm9pZCB0cmlnZ2VyaW5nIGVkZ2UgdXBkYXRlciBpZiBtb3VzZSBidG4gaXMgbm90IGxlZnRcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYXV0b1Bhbk9uQ29ubmVjdCwgZG9tTm9kZSwgaXNWYWxpZENvbm5lY3Rpb24sIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uUmFkaXVzLCBsaWIsIG9uQ29ubmVjdFN0YXJ0LCBvbkNvbm5lY3RFbmQsIGNhbmNlbENvbm5lY3Rpb24sIG5vZGVMb29rdXAsIHJmSWQ6IGZsb3dJZCwgcGFuQnksIHVwZGF0ZUNvbm5lY3Rpb24sIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBpc1RhcmdldCA9IG9wcG9zaXRlSGFuZGxlLnR5cGUgPT09ICd0YXJnZXQnO1xuICAgICAgICBzZXRSZWNvbm5lY3RpbmcodHJ1ZSk7XG4gICAgICAgIG9uUmVjb25uZWN0U3RhcnQ/LihldmVudCwgZWRnZSwgb3Bwb3NpdGVIYW5kbGUudHlwZSk7XG4gICAgICAgIGNvbnN0IF9vblJlY29ubmVjdEVuZCA9IChldnQsIGNvbm5lY3Rpb25TdGF0ZSkgPT4ge1xuICAgICAgICAgICAgc2V0UmVjb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIG9uUmVjb25uZWN0RW5kPy4oZXZ0LCBlZGdlLCBvcHBvc2l0ZUhhbmRsZS50eXBlLCBjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkNvbm5lY3RFZGdlID0gKGNvbm5lY3Rpb24pID0+IG9uUmVjb25uZWN0Py4oZWRnZSwgY29ubmVjdGlvbik7XG4gICAgICAgIFhZSGFuZGxlLm9uUG9pbnRlckRvd24oZXZlbnQubmF0aXZlRXZlbnQsIHtcbiAgICAgICAgICAgIGF1dG9QYW5PbkNvbm5lY3QsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25SYWRpdXMsXG4gICAgICAgICAgICBkb21Ob2RlLFxuICAgICAgICAgICAgaGFuZGxlSWQ6IG9wcG9zaXRlSGFuZGxlLmlkLFxuICAgICAgICAgICAgbm9kZUlkOiBvcHBvc2l0ZUhhbmRsZS5ub2RlSWQsXG4gICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgaXNUYXJnZXQsXG4gICAgICAgICAgICBlZGdlVXBkYXRlclR5cGU6IG9wcG9zaXRlSGFuZGxlLnR5cGUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBmbG93SWQsXG4gICAgICAgICAgICBjYW5jZWxDb25uZWN0aW9uLFxuICAgICAgICAgICAgcGFuQnksXG4gICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbixcbiAgICAgICAgICAgIG9uQ29ubmVjdDogb25Db25uZWN0RWRnZSxcbiAgICAgICAgICAgIG9uQ29ubmVjdFN0YXJ0LFxuICAgICAgICAgICAgb25Db25uZWN0RW5kLFxuICAgICAgICAgICAgb25SZWNvbm5lY3RFbmQ6IF9vblJlY29ubmVjdEVuZCxcbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb24sXG4gICAgICAgICAgICBnZXRUcmFuc2Zvcm06ICgpID0+IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtLFxuICAgICAgICAgICAgZ2V0RnJvbUhhbmRsZTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5jb25uZWN0aW9uLmZyb21IYW5kbGUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25SZWNvbm5lY3RTb3VyY2VNb3VzZURvd24gPSAoZXZlbnQpID0+IGhhbmRsZUVkZ2VVcGRhdGVyKGV2ZW50LCB7IG5vZGVJZDogZWRnZS50YXJnZXQsIGlkOiBlZGdlLnRhcmdldEhhbmRsZSA/PyBudWxsLCB0eXBlOiAndGFyZ2V0JyB9KTtcbiAgICBjb25zdCBvblJlY29ubmVjdFRhcmdldE1vdXNlRG93biA9IChldmVudCkgPT4gaGFuZGxlRWRnZVVwZGF0ZXIoZXZlbnQsIHsgbm9kZUlkOiBlZGdlLnNvdXJjZSwgaWQ6IGVkZ2Uuc291cmNlSGFuZGxlID8/IG51bGwsIHR5cGU6ICdzb3VyY2UnIH0pO1xuICAgIGNvbnN0IG9uUmVjb25uZWN0TW91c2VFbnRlciA9ICgpID0+IHNldFVwZGF0ZUhvdmVyKHRydWUpO1xuICAgIGNvbnN0IG9uUmVjb25uZWN0TW91c2VPdXQgPSAoKSA9PiBzZXRVcGRhdGVIb3ZlcihmYWxzZSk7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbKGlzUmVjb25uZWN0YWJsZSA9PT0gdHJ1ZSB8fCBpc1JlY29ubmVjdGFibGUgPT09ICdzb3VyY2UnKSAmJiAoanN4KEVkZ2VBbmNob3IsIHsgcG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCBjZW50ZXJYOiBzb3VyY2VYLCBjZW50ZXJZOiBzb3VyY2VZLCByYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgb25Nb3VzZURvd246IG9uUmVjb25uZWN0U291cmNlTW91c2VEb3duLCBvbk1vdXNlRW50ZXI6IG9uUmVjb25uZWN0TW91c2VFbnRlciwgb25Nb3VzZU91dDogb25SZWNvbm5lY3RNb3VzZU91dCwgdHlwZTogXCJzb3VyY2VcIiB9KSksIChpc1JlY29ubmVjdGFibGUgPT09IHRydWUgfHwgaXNSZWNvbm5lY3RhYmxlID09PSAndGFyZ2V0JykgJiYgKGpzeChFZGdlQW5jaG9yLCB7IHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgY2VudGVyWDogdGFyZ2V0WCwgY2VudGVyWTogdGFyZ2V0WSwgcmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIG9uTW91c2VEb3duOiBvblJlY29ubmVjdFRhcmdldE1vdXNlRG93biwgb25Nb3VzZUVudGVyOiBvblJlY29ubmVjdE1vdXNlRW50ZXIsIG9uTW91c2VPdXQ6IG9uUmVjb25uZWN0TW91c2VPdXQsIHR5cGU6IFwidGFyZ2V0XCIgfSkpXSB9KSk7XG59XG5cbmZ1bmN0aW9uIEVkZ2VXcmFwcGVyKHsgaWQsIGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgb25DbGljaywgb25Eb3VibGVDbGljaywgb25Db250ZXh0TWVudSwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlLCByZWNvbm5lY3RSYWRpdXMsIG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgcmZJZCwgZWRnZVR5cGVzLCBub1BhbkNsYXNzTmFtZSwgb25FcnJvciwgZGlzYWJsZUtleWJvYXJkQTExeSwgfSkge1xuICAgIGxldCBlZGdlID0gdXNlU3RvcmUoKHMpID0+IHMuZWRnZUxvb2t1cC5nZXQoaWQpKTtcbiAgICBjb25zdCBkZWZhdWx0RWRnZU9wdGlvbnMgPSB1c2VTdG9yZSgocykgPT4gcy5kZWZhdWx0RWRnZU9wdGlvbnMpO1xuICAgIGVkZ2UgPSBkZWZhdWx0RWRnZU9wdGlvbnMgPyB7IC4uLmRlZmF1bHRFZGdlT3B0aW9ucywgLi4uZWRnZSB9IDogZWRnZTtcbiAgICBsZXQgZWRnZVR5cGUgPSBlZGdlLnR5cGUgfHwgJ2RlZmF1bHQnO1xuICAgIGxldCBFZGdlQ29tcG9uZW50ID0gZWRnZVR5cGVzPy5bZWRnZVR5cGVdIHx8IGJ1aWx0aW5FZGdlVHlwZXNbZWRnZVR5cGVdO1xuICAgIGlmIChFZGdlQ29tcG9uZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMTEnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMSddKGVkZ2VUeXBlKSk7XG4gICAgICAgIGVkZ2VUeXBlID0gJ2RlZmF1bHQnO1xuICAgICAgICBFZGdlQ29tcG9uZW50ID0gYnVpbHRpbkVkZ2VUeXBlcy5kZWZhdWx0O1xuICAgIH1cbiAgICBjb25zdCBpc0ZvY3VzYWJsZSA9ICEhKGVkZ2UuZm9jdXNhYmxlIHx8IChlZGdlc0ZvY3VzYWJsZSAmJiB0eXBlb2YgZWRnZS5mb2N1c2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNSZWNvbm5lY3RhYmxlID0gdHlwZW9mIG9uUmVjb25uZWN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAoZWRnZS5yZWNvbm5lY3RhYmxlIHx8IChlZGdlc1JlY29ubmVjdGFibGUgJiYgdHlwZW9mIGVkZ2UucmVjb25uZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc1NlbGVjdGFibGUgPSAhIShlZGdlLnNlbGVjdGFibGUgfHwgKGVsZW1lbnRzU2VsZWN0YWJsZSAmJiB0eXBlb2YgZWRnZS5zZWxlY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGVkZ2VSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgW3VwZGF0ZUhvdmVyLCBzZXRVcGRhdGVIb3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3JlY29ubmVjdGluZywgc2V0UmVjb25uZWN0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB6SW5kZXgsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiB9ID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHN0b3JlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBzdG9yZS5ub2RlTG9va3VwLmdldChlZGdlLnNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBzdG9yZS5ub2RlTG9va3VwLmdldChlZGdlLnRhcmdldCk7XG4gICAgICAgIGlmICghc291cmNlTm9kZSB8fCAhdGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB6SW5kZXg6IGVkZ2UuekluZGV4LFxuICAgICAgICAgICAgICAgIC4uLm51bGxQb3NpdGlvbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWRnZVBvc2l0aW9uID0gZ2V0RWRnZVBvc2l0aW9uKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgc291cmNlTm9kZSxcbiAgICAgICAgICAgIHRhcmdldE5vZGUsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IGVkZ2Uuc291cmNlSGFuZGxlIHx8IG51bGwsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IGVkZ2UudGFyZ2V0SGFuZGxlIHx8IG51bGwsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZTogc3RvcmUuY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgekluZGV4ID0gZ2V0RWxldmF0ZWRFZGdlWkluZGV4KHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLFxuICAgICAgICAgICAgekluZGV4OiBlZGdlLnpJbmRleCxcbiAgICAgICAgICAgIHNvdXJjZU5vZGUsXG4gICAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgICAgZWxldmF0ZU9uU2VsZWN0OiBzdG9yZS5lbGV2YXRlRWRnZXNPblNlbGVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB6SW5kZXgsXG4gICAgICAgICAgICAuLi4oZWRnZVBvc2l0aW9uIHx8IG51bGxQb3NpdGlvbiksXG4gICAgICAgIH07XG4gICAgfSwgW2VkZ2Uuc291cmNlLCBlZGdlLnRhcmdldCwgZWRnZS5zb3VyY2VIYW5kbGUsIGVkZ2UudGFyZ2V0SGFuZGxlLCBlZGdlLnNlbGVjdGVkLCBlZGdlLnpJbmRleF0pLCBzaGFsbG93KTtcbiAgICBjb25zdCBtYXJrZXJTdGFydFVybCA9IHVzZU1lbW8oKCkgPT4gKGVkZ2UubWFya2VyU3RhcnQgPyBgdXJsKCcjJHtnZXRNYXJrZXJJZChlZGdlLm1hcmtlclN0YXJ0LCByZklkKX0nKWAgOiB1bmRlZmluZWQpLCBbZWRnZS5tYXJrZXJTdGFydCwgcmZJZF0pO1xuICAgIGNvbnN0IG1hcmtlckVuZFVybCA9IHVzZU1lbW8oKCkgPT4gKGVkZ2UubWFya2VyRW5kID8gYHVybCgnIyR7Z2V0TWFya2VySWQoZWRnZS5tYXJrZXJFbmQsIHJmSWQpfScpYCA6IHVuZGVmaW5lZCksIFtlZGdlLm1hcmtlckVuZCwgcmZJZF0pO1xuICAgIGlmIChlZGdlLmhpZGRlbiB8fCBzb3VyY2VYID09PSBudWxsIHx8IHNvdXJjZVkgPT09IG51bGwgfHwgdGFyZ2V0WCA9PT0gbnVsbCB8fCB0YXJnZXRZID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvbkVkZ2VDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IGFkZFNlbGVjdGVkRWRnZXMsIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgbXVsdGlTZWxlY3Rpb25BY3RpdmUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChpc1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGVkZ2Uuc2VsZWN0ZWQgJiYgbXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBub2RlczogW10sIGVkZ2VzOiBbZWRnZV0gfSk7XG4gICAgICAgICAgICAgICAgZWRnZVJlZi5jdXJyZW50Py5ibHVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRTZWxlY3RlZEVkZ2VzKFtpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBvbkNsaWNrKGV2ZW50LCBlZGdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25FZGdlRG91YmxlQ2xpY2sgPSBvbkRvdWJsZUNsaWNrXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbkRvdWJsZUNsaWNrKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlQ29udGV4dE1lbnUgPSBvbkNvbnRleHRNZW51XG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbkNvbnRleHRNZW51KGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VFbnRlciA9IG9uTW91c2VFbnRlclxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VzZUVudGVyKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VNb3ZlID0gb25Nb3VzZU1vdmVcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VMZWF2ZSA9IG9uTW91c2VMZWF2ZVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VzZUxlYXZlKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghZGlzYWJsZUtleWJvYXJkQTExeSAmJiBlbGVtZW50U2VsZWN0aW9uS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpICYmIGlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgY29uc3QgeyB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIGFkZFNlbGVjdGVkRWRnZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCB1bnNlbGVjdCA9IGV2ZW50LmtleSA9PT0gJ0VzY2FwZSc7XG4gICAgICAgICAgICBpZiAodW5zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBlZGdlUmVmLmN1cnJlbnQ/LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBlZGdlczogW2VkZ2VdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkU2VsZWN0ZWRFZGdlcyhbaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyBzdHlsZTogeyB6SW5kZXggfSwgY2hpbGRyZW46IGpzeHMoXCJnXCIsIHsgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX2VkZ2UnLFxuICAgICAgICAgICAgICAgIGByZWFjdC1mbG93X19lZGdlLSR7ZWRnZVR5cGV9YCxcbiAgICAgICAgICAgICAgICBlZGdlLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlZDogZWRnZS5hbmltYXRlZCxcbiAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmU6ICFpc1NlbGVjdGFibGUgJiYgIW9uQ2xpY2ssXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0aW5nOiB1cGRhdGVIb3ZlcixcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKSwgb25DbGljazogb25FZGdlQ2xpY2ssIG9uRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25Nb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIG9uS2V5RG93bjogaXNGb2N1c2FibGUgPyBvbktleURvd24gOiB1bmRlZmluZWQsIHRhYkluZGV4OiBpc0ZvY3VzYWJsZSA/IDAgOiB1bmRlZmluZWQsIHJvbGU6IGlzRm9jdXNhYmxlID8gJ2J1dHRvbicgOiAnaW1nJywgXCJkYXRhLWlkXCI6IGlkLCBcImRhdGEtdGVzdGlkXCI6IGByZl9fZWRnZS0ke2lkfWAsIFwiYXJpYS1sYWJlbFwiOiBlZGdlLmFyaWFMYWJlbCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGVkZ2UuYXJpYUxhYmVsIHx8IGBFZGdlIGZyb20gJHtlZGdlLnNvdXJjZX0gdG8gJHtlZGdlLnRhcmdldH1gLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogaXNGb2N1c2FibGUgPyBgJHtBUklBX0VER0VfREVTQ19LRVl9LSR7cmZJZH1gIDogdW5kZWZpbmVkLCByZWY6IGVkZ2VSZWYsIGNoaWxkcmVuOiBbIXJlY29ubmVjdGluZyAmJiAoanN4KEVkZ2VDb21wb25lbnQsIHsgaWQ6IGlkLCBzb3VyY2U6IGVkZ2Uuc291cmNlLCB0YXJnZXQ6IGVkZ2UudGFyZ2V0LCB0eXBlOiBlZGdlLnR5cGUsIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLCBhbmltYXRlZDogZWRnZS5hbmltYXRlZCwgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLCBkZWxldGFibGU6IGVkZ2UuZGVsZXRhYmxlID8/IHRydWUsIGxhYmVsOiBlZGdlLmxhYmVsLCBsYWJlbFN0eWxlOiBlZGdlLmxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBlZGdlLmxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGVkZ2UubGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogZWRnZS5sYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogZWRnZS5sYWJlbEJnQm9yZGVyUmFkaXVzLCBzb3VyY2VYOiBzb3VyY2VYLCBzb3VyY2VZOiBzb3VyY2VZLCB0YXJnZXRYOiB0YXJnZXRYLCB0YXJnZXRZOiB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbjogc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgZGF0YTogZWRnZS5kYXRhLCBzdHlsZTogZWRnZS5zdHlsZSwgc291cmNlSGFuZGxlSWQ6IGVkZ2Uuc291cmNlSGFuZGxlLCB0YXJnZXRIYW5kbGVJZDogZWRnZS50YXJnZXRIYW5kbGUsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydFVybCwgbWFya2VyRW5kOiBtYXJrZXJFbmRVcmwsIHBhdGhPcHRpb25zOiAncGF0aE9wdGlvbnMnIGluIGVkZ2UgPyBlZGdlLnBhdGhPcHRpb25zIDogdW5kZWZpbmVkLCBpbnRlcmFjdGlvbldpZHRoOiBlZGdlLmludGVyYWN0aW9uV2lkdGggfSkpLCBpc1JlY29ubmVjdGFibGUgJiYgKGpzeChFZGdlVXBkYXRlQW5jaG9ycywgeyBlZGdlOiBlZGdlLCBpc1JlY29ubmVjdGFibGU6IGlzUmVjb25uZWN0YWJsZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIG9uUmVjb25uZWN0OiBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydDogb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQ6IG9uUmVjb25uZWN0RW5kLCBzb3VyY2VYOiBzb3VyY2VYLCBzb3VyY2VZOiBzb3VyY2VZLCB0YXJnZXRYOiB0YXJnZXRYLCB0YXJnZXRZOiB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbjogc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgc2V0VXBkYXRlSG92ZXI6IHNldFVwZGF0ZUhvdmVyLCBzZXRSZWNvbm5lY3Rpbmc6IHNldFJlY29ubmVjdGluZyB9KSldIH0pIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkYSA9IChzKSA9PiAoe1xuICAgIGVkZ2VzRm9jdXNhYmxlOiBzLmVkZ2VzRm9jdXNhYmxlLFxuICAgIGVkZ2VzUmVjb25uZWN0YWJsZTogcy5lZGdlc1JlY29ubmVjdGFibGUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBjb25uZWN0aW9uTW9kZTogcy5jb25uZWN0aW9uTW9kZSxcbiAgICBvbkVycm9yOiBzLm9uRXJyb3IsXG59KTtcbmZ1bmN0aW9uIEVkZ2VSZW5kZXJlckNvbXBvbmVudCh7IGRlZmF1bHRNYXJrZXJDb2xvciwgb25seVJlbmRlclZpc2libGVFbGVtZW50cywgcmZJZCwgZWRnZVR5cGVzLCBub1BhbkNsYXNzTmFtZSwgb25SZWNvbm5lY3QsIG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmUsIG9uRWRnZUNsaWNrLCByZWNvbm5lY3RSYWRpdXMsIG9uRWRnZURvdWJsZUNsaWNrLCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgZGlzYWJsZUtleWJvYXJkQTExeSwgfSkge1xuICAgIGNvbnN0IHsgZWRnZXNGb2N1c2FibGUsIGVkZ2VzUmVjb25uZWN0YWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBvbkVycm9yIH0gPSB1c2VTdG9yZShzZWxlY3RvciRhLCBzaGFsbG93KTtcbiAgICBjb25zdCBlZGdlSWRzID0gdXNlVmlzaWJsZUVkZ2VJZHMob25seVJlbmRlclZpc2libGVFbGVtZW50cyk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2VzXCIsIGNoaWxkcmVuOiBbanN4KE1hcmtlckRlZmluaXRpb25zJDEsIHsgZGVmYXVsdENvbG9yOiBkZWZhdWx0TWFya2VyQ29sb3IsIHJmSWQ6IHJmSWQgfSksIGVkZ2VJZHMubWFwKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoanN4KEVkZ2VXcmFwcGVyLCB7IGlkOiBpZCwgZWRnZXNGb2N1c2FibGU6IGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGU6IGVkZ2VzUmVjb25uZWN0YWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvbkNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25Nb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIG9uQ2xpY2s6IG9uRWRnZUNsaWNrLCByZWNvbm5lY3RSYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgb25Eb3VibGVDbGljazogb25FZGdlRG91YmxlQ2xpY2ssIG9uUmVjb25uZWN0U3RhcnQ6IG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kOiBvblJlY29ubmVjdEVuZCwgcmZJZDogcmZJZCwgb25FcnJvcjogb25FcnJvciwgZWRnZVR5cGVzOiBlZGdlVHlwZXMsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXkgfSwgaWQpKTtcbiAgICAgICAgICAgIH0pXSB9KSk7XG59XG5FZGdlUmVuZGVyZXJDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnRWRnZVJlbmRlcmVyJztcbmNvbnN0IEVkZ2VSZW5kZXJlciA9IG1lbW8oRWRnZVJlbmRlcmVyQ29tcG9uZW50KTtcblxuY29uc3Qgc2VsZWN0b3IkOSA9IChzKSA9PiBgdHJhbnNsYXRlKCR7cy50cmFuc2Zvcm1bMF19cHgsJHtzLnRyYW5zZm9ybVsxXX1weCkgc2NhbGUoJHtzLnRyYW5zZm9ybVsyXX0pYDtcbmZ1bmN0aW9uIFZpZXdwb3J0KHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHVzZVN0b3JlKHNlbGVjdG9yJDkpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3ZpZXdwb3J0IHh5Zmxvd19fdmlld3BvcnQgcmVhY3QtZmxvd19fY29udGFpbmVyXCIsIHN0eWxlOiB7IHRyYW5zZm9ybSB9LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIGNhbGxpbmcgb25Jbml0IGhhbmRsZXIuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZU9uSW5pdEhhbmRsZXIob25Jbml0KSB7XG4gICAgY29uc3QgcmZJbnN0YW5jZSA9IHVzZVJlYWN0RmxvdygpO1xuICAgIGNvbnN0IGlzSW5pdGlhbGl6ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaXNJbml0aWFsaXplZC5jdXJyZW50ICYmIHJmSW5zdGFuY2Uudmlld3BvcnRJbml0aWFsaXplZCAmJiBvbkluaXQpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gb25Jbml0KHJmSW5zdGFuY2UpLCAxKTtcbiAgICAgICAgICAgIGlzSW5pdGlhbGl6ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LCBbb25Jbml0LCByZkluc3RhbmNlLnZpZXdwb3J0SW5pdGlhbGl6ZWRdKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkOCA9IChzdGF0ZSkgPT4gc3RhdGUucGFuWm9vbT8uc3luY1ZpZXdwb3J0O1xuLyoqXG4gKiBIb29rIGZvciBzeW5jaW5nIHRoZSB2aWV3cG9ydCB3aXRoIHRoZSBwYW56b29tIGluc3RhbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHZpZXdwb3J0XG4gKi9cbmZ1bmN0aW9uIHVzZVZpZXdwb3J0U3luYyh2aWV3cG9ydCkge1xuICAgIGNvbnN0IHN5bmNWaWV3cG9ydCA9IHVzZVN0b3JlKHNlbGVjdG9yJDgpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodmlld3BvcnQpIHtcbiAgICAgICAgICAgIHN5bmNWaWV3cG9ydD8uKHZpZXdwb3J0KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgdHJhbnNmb3JtOiBbdmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQuem9vbV0gfSk7XG4gICAgICAgIH1cbiAgICB9LCBbdmlld3BvcnQsIHN5bmNWaWV3cG9ydF0pO1xuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBzdG9yZVNlbGVjdG9yJDEocykge1xuICAgIHJldHVybiBzLmNvbm5lY3Rpb24uaW5Qcm9ncmVzc1xuICAgICAgICA/IHsgLi4ucy5jb25uZWN0aW9uLCB0bzogcG9pbnRUb1JlbmRlcmVyUG9pbnQocy5jb25uZWN0aW9uLnRvLCBzLnRyYW5zZm9ybSkgfVxuICAgICAgICA6IHsgLi4ucy5jb25uZWN0aW9uIH07XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rvcihjb25uZWN0aW9uU2VsZWN0b3IpIHtcbiAgICBpZiAoY29ubmVjdGlvblNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkU2VsZWN0b3IgPSAocykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHN0b3JlU2VsZWN0b3IkMShzKTtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uU2VsZWN0b3IoY29ubmVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb21iaW5lZFNlbGVjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcmVTZWxlY3RvciQxO1xufVxuLyoqXG4gKiBUaGUgYHVzZUNvbm5lY3Rpb25gIGhvb2sgcmV0dXJucyB0aGUgY3VycmVudCBjb25uZWN0aW9uIHdoZW4gdGhlcmUgaXMgYW4gYWN0aXZlXG4gKiBjb25uZWN0aW9uIGludGVyYWN0aW9uLiBJZiBubyBjb25uZWN0aW9uIGludGVyYWN0aW9uIGlzIGFjdGl2ZSwgaXQgcmV0dXJucyBudWxsXG4gKiBmb3IgZXZlcnkgcHJvcGVydHkuIEEgdHlwaWNhbCB1c2UgY2FzZSBmb3IgdGhpcyBob29rIGlzIHRvIGNvbG9yaXplIGhhbmRsZXNcbiAqIGJhc2VkIG9uIGEgY2VydGFpbiBjb25kaXRpb24gKGUuZy4gaWYgdGhlIGNvbm5lY3Rpb24gaXMgdmFsaWQgb3Igbm90KS5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gY29ubmVjdGlvblNlbGVjdG9yIC0gQW4gb3B0aW9uYWwgc2VsZWN0b3IgZnVuY3Rpb24gdXNlZCB0byBleHRyYWN0IGEgc2xpY2Ugb2YgdGhlXG4gKiBgQ29ubmVjdGlvblN0YXRlYCBkYXRhLiBVc2luZyBhIHNlbGVjdG9yIGNhbiBwcmV2ZW50IGNvbXBvbmVudCByZS1yZW5kZXJzIHdoZXJlIGRhdGEgeW91IGRvbid0XG4gKiBvdGhlcndpc2UgY2FyZSBhYm91dCBtaWdodCBjaGFuZ2UuIElmIGEgc2VsZWN0b3IgaXMgbm90IHByb3ZpZGVkLCB0aGUgZW50aXJlIGBDb25uZWN0aW9uU3RhdGVgXG4gKiBvYmplY3QgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgdXNlQ29ubmVjdGlvbiB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZnVuY3Rpb24gQXBwKCkge1xuICogIGNvbnN0IGNvbm5lY3Rpb24gPSB1c2VDb25uZWN0aW9uKCk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PiB7Y29ubmVjdGlvbiA/IGBTb21lb25lIGlzIHRyeWluZyB0byBtYWtlIGEgY29ubmVjdGlvbiBmcm9tICR7Y29ubmVjdGlvbi5mcm9tTm9kZX0gdG8gdGhpcyBvbmUuYCA6ICdUaGVyZSBhcmUgY3VycmVudGx5IG5vIGluY29taW5nIGNvbm5lY3Rpb25zISd9XG4gKlxuICogICA8L2Rpdj5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIENvbm5lY3Rpb25TdGF0ZVxuICovXG5mdW5jdGlvbiB1c2VDb25uZWN0aW9uKGNvbm5lY3Rpb25TZWxlY3Rvcikge1xuICAgIGNvbnN0IGNvbWJpbmVkU2VsZWN0b3IgPSBnZXRTZWxlY3Rvcihjb25uZWN0aW9uU2VsZWN0b3IpO1xuICAgIHJldHVybiB1c2VTdG9yZShjb21iaW5lZFNlbGVjdG9yLCBzaGFsbG93KTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkNyA9IChzKSA9PiAoe1xuICAgIG5vZGVzQ29ubmVjdGFibGU6IHMubm9kZXNDb25uZWN0YWJsZSxcbiAgICBpc1ZhbGlkOiBzLmNvbm5lY3Rpb24uaXNWYWxpZCxcbiAgICBpblByb2dyZXNzOiBzLmNvbm5lY3Rpb24uaW5Qcm9ncmVzcyxcbiAgICB3aWR0aDogcy53aWR0aCxcbiAgICBoZWlnaHQ6IHMuaGVpZ2h0LFxufSk7XG5mdW5jdGlvbiBDb25uZWN0aW9uTGluZVdyYXBwZXIoeyBjb250YWluZXJTdHlsZSwgc3R5bGUsIHR5cGUsIGNvbXBvbmVudCwgfSkge1xuICAgIGNvbnN0IHsgbm9kZXNDb25uZWN0YWJsZSwgd2lkdGgsIGhlaWdodCwgaXNWYWxpZCwgaW5Qcm9ncmVzcyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkNywgc2hhbGxvdyk7XG4gICAgY29uc3QgcmVuZGVyQ29ubmVjdGlvbiA9ICEhKHdpZHRoICYmIG5vZGVzQ29ubmVjdGFibGUgJiYgaW5Qcm9ncmVzcyk7XG4gICAgaWYgKCFyZW5kZXJDb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHN0eWxlOiBjb250YWluZXJTdHlsZSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2Nvbm5lY3Rpb25saW5lIHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiLCBjaGlsZHJlbjoganN4KFwiZ1wiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19jb25uZWN0aW9uJywgZ2V0Q29ubmVjdGlvblN0YXR1cyhpc1ZhbGlkKV0pLCBjaGlsZHJlbjoganN4KENvbm5lY3Rpb25MaW5lLCB7IHN0eWxlOiBzdHlsZSwgdHlwZTogdHlwZSwgQ3VzdG9tQ29tcG9uZW50OiBjb21wb25lbnQsIGlzVmFsaWQ6IGlzVmFsaWQgfSkgfSkgfSkpO1xufVxuY29uc3QgQ29ubmVjdGlvbkxpbmUgPSAoeyBzdHlsZSwgdHlwZSA9IENvbm5lY3Rpb25MaW5lVHlwZS5CZXppZXIsIEN1c3RvbUNvbXBvbmVudCwgaXNWYWxpZCwgfSkgPT4ge1xuICAgIGNvbnN0IHsgaW5Qcm9ncmVzcywgZnJvbSwgZnJvbU5vZGUsIGZyb21IYW5kbGUsIGZyb21Qb3NpdGlvbiwgdG8sIHRvTm9kZSwgdG9IYW5kbGUsIHRvUG9zaXRpb24gfSA9IHVzZUNvbm5lY3Rpb24oKTtcbiAgICBpZiAoIWluUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQ3VzdG9tQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAoanN4KEN1c3RvbUNvbXBvbmVudCwgeyBjb25uZWN0aW9uTGluZVR5cGU6IHR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGU6IHN0eWxlLCBmcm9tTm9kZTogZnJvbU5vZGUsIGZyb21IYW5kbGU6IGZyb21IYW5kbGUsIGZyb21YOiBmcm9tLngsIGZyb21ZOiBmcm9tLnksIHRvWDogdG8ueCwgdG9ZOiB0by55LCBmcm9tUG9zaXRpb246IGZyb21Qb3NpdGlvbiwgdG9Qb3NpdGlvbjogdG9Qb3NpdGlvbiwgY29ubmVjdGlvblN0YXR1czogZ2V0Q29ubmVjdGlvblN0YXR1cyhpc1ZhbGlkKSwgdG9Ob2RlOiB0b05vZGUsIHRvSGFuZGxlOiB0b0hhbmRsZSB9KSk7XG4gICAgfVxuICAgIGxldCBwYXRoID0gJyc7XG4gICAgY29uc3QgcGF0aFBhcmFtcyA9IHtcbiAgICAgICAgc291cmNlWDogZnJvbS54LFxuICAgICAgICBzb3VyY2VZOiBmcm9tLnksXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uOiBmcm9tUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFg6IHRvLngsXG4gICAgICAgIHRhcmdldFk6IHRvLnksXG4gICAgICAgIHRhcmdldFBvc2l0aW9uOiB0b1Bvc2l0aW9uLFxuICAgIH07XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgQ29ubmVjdGlvbkxpbmVUeXBlLkJlemllcjpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldEJlemllclBhdGgocGF0aFBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb25uZWN0aW9uTGluZVR5cGUuU2ltcGxlQmV6aWVyOlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0U2ltcGxlQmV6aWVyUGF0aChwYXRoUGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbm5lY3Rpb25MaW5lVHlwZS5TdGVwOlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0U21vb3RoU3RlcFBhdGgoe1xuICAgICAgICAgICAgICAgIC4uLnBhdGhQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb25uZWN0aW9uTGluZVR5cGUuU21vb3RoU3RlcDpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldFNtb290aFN0ZXBQYXRoKHBhdGhQYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRTdHJhaWdodFBhdGgocGF0aFBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiBqc3goXCJwYXRoXCIsIHsgZDogcGF0aCwgZmlsbDogXCJub25lXCIsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb25uZWN0aW9uLXBhdGhcIiwgc3R5bGU6IHN0eWxlIH0pO1xufTtcbkNvbm5lY3Rpb25MaW5lLmRpc3BsYXlOYW1lID0gJ0Nvbm5lY3Rpb25MaW5lJztcblxuY29uc3QgZW1wdHlUeXBlcyA9IHt9O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHVzZU5vZGVPckVkZ2VUeXBlc1dhcm5pbmcobm9kZU9yRWRnZVR5cGVzID0gZW1wdHlUeXBlcykge1xuICAgIGNvbnN0IHR5cGVzUmVmID0gdXNlUmVmKG5vZGVPckVkZ2VUeXBlcyk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc3QgdXNlZEtleXMgPSBuZXcgU2V0KFsuLi5PYmplY3Qua2V5cyh0eXBlc1JlZi5jdXJyZW50KSwgLi4uT2JqZWN0LmtleXMobm9kZU9yRWRnZVR5cGVzKV0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXNlZEtleXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZXNSZWYuY3VycmVudFtrZXldICE9PSBub2RlT3JFZGdlVHlwZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDAyJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDInXSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZXNSZWYuY3VycmVudCA9IG5vZGVPckVkZ2VUeXBlcztcbiAgICAgICAgfVxuICAgIH0sIFtub2RlT3JFZGdlVHlwZXNdKTtcbn1cblxuZnVuY3Rpb24gdXNlU3R5bGVzTG9hZGVkV2FybmluZygpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgY2hlY2tlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrZWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhbmUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fcGFuZScpO1xuICAgICAgICAgICAgICAgIGlmIChwYW5lICYmICEod2luZG93LmdldENvbXB1dGVkU3R5bGUocGFuZSkuekluZGV4ID09PSAnMScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMTMnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMyddKCdyZWFjdCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hlY2tlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gR3JhcGhWaWV3Q29tcG9uZW50KHsgbm9kZVR5cGVzLCBlZGdlVHlwZXMsIG9uSW5pdCwgb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrLCBvbk5vZGVEb3VibGVDbGljaywgb25FZGdlRG91YmxlQ2xpY2ssIG9uTm9kZU1vdXNlRW50ZXIsIG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBjb25uZWN0aW9uTGluZVR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50LCBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlLCBzZWxlY3Rpb25LZXlDb2RlLCBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgZGVsZXRlS2V5Q29kZSwgb25seVJlbmRlclZpc2libGVFbGVtZW50cywgZWxlbWVudHNTZWxlY3RhYmxlLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZywgZGVmYXVsdE1hcmtlckNvbG9yLCB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoLCBwYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljaywgcGFuT25EcmFnLCBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51LCBwYW5lQ2xpY2tEaXN0YW5jZSwgbm9kZUNsaWNrRGlzdGFuY2UsIG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1cywgb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBub0RyYWdDbGFzc05hbWUsIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlRXh0ZW50LCByZklkLCB2aWV3cG9ydCwgb25WaWV3cG9ydENoYW5nZSwgfSkge1xuICAgIHVzZU5vZGVPckVkZ2VUeXBlc1dhcm5pbmcobm9kZVR5cGVzKTtcbiAgICB1c2VOb2RlT3JFZGdlVHlwZXNXYXJuaW5nKGVkZ2VUeXBlcyk7XG4gICAgdXNlU3R5bGVzTG9hZGVkV2FybmluZygpO1xuICAgIHVzZU9uSW5pdEhhbmRsZXIob25Jbml0KTtcbiAgICB1c2VWaWV3cG9ydFN5bmModmlld3BvcnQpO1xuICAgIHJldHVybiAoanN4KEZsb3dSZW5kZXJlciwgeyBvblBhbmVDbGljazogb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXI6IG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZTogb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlOiBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIG9uUGFuZVNjcm9sbDogb25QYW5lU2Nyb2xsLCBwYW5lQ2xpY2tEaXN0YW5jZTogcGFuZUNsaWNrRGlzdGFuY2UsIGRlbGV0ZUtleUNvZGU6IGRlbGV0ZUtleUNvZGUsIHNlbGVjdGlvbktleUNvZGU6IHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZzogc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLCBvblNlbGVjdGlvblN0YXJ0OiBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZDogb25TZWxlY3Rpb25FbmQsIG11bHRpU2VsZWN0aW9uS2V5Q29kZTogbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZTogcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgZGVmYXVsdFZpZXdwb3J0OiBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudDogdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBvblNlbGVjdGlvbkNvbnRleHRNZW51OiBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBwcmV2ZW50U2Nyb2xsaW5nOiBwcmV2ZW50U2Nyb2xsaW5nLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBvblZpZXdwb3J0Q2hhbmdlOiBvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydDogISF2aWV3cG9ydCwgY2hpbGRyZW46IGpzeHMoVmlld3BvcnQsIHsgY2hpbGRyZW46IFtqc3goRWRnZVJlbmRlcmVyLCB7IGVkZ2VUeXBlczogZWRnZVR5cGVzLCBvbkVkZ2VDbGljazogb25FZGdlQ2xpY2ssIG9uRWRnZURvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGljaywgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHM6IG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMsIG9uRWRnZUNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlTW91c2VFbnRlcjogb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlOiBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBkZWZhdWx0TWFya2VyQ29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCByZklkOiByZklkIH0pLCBqc3goQ29ubmVjdGlvbkxpbmVXcmFwcGVyLCB7IHN0eWxlOiBjb25uZWN0aW9uTGluZVN0eWxlLCB0eXBlOiBjb25uZWN0aW9uTGluZVR5cGUsIGNvbXBvbmVudDogY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbnRhaW5lclN0eWxlOiBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlIH0pLCBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZWxhYmVsLXJlbmRlcmVyXCIgfSksIGpzeChOb2RlUmVuZGVyZXIsIHsgbm9kZVR5cGVzOiBub2RlVHlwZXMsIG9uTm9kZUNsaWNrOiBvbk5vZGVDbGljaywgb25Ob2RlRG91YmxlQ2xpY2s6IG9uTm9kZURvdWJsZUNsaWNrLCBvbk5vZGVNb3VzZUVudGVyOiBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmU6IG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZTogb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnU6IG9uTm9kZUNvbnRleHRNZW51LCBub2RlQ2xpY2tEaXN0YW5jZTogbm9kZUNsaWNrRGlzdGFuY2UsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHM6IG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgbm9EcmFnQ2xhc3NOYW1lOiBub0RyYWdDbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXksIG5vZGVFeHRlbnQ6IG5vZGVFeHRlbnQsIHJmSWQ6IHJmSWQgfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X192aWV3cG9ydC1wb3J0YWxcIiB9KV0gfSkgfSkpO1xufVxuR3JhcGhWaWV3Q29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0dyYXBoVmlldyc7XG5jb25zdCBHcmFwaFZpZXcgPSBtZW1vKEdyYXBoVmlld0NvbXBvbmVudCk7XG5cbmNvbnN0IGdldEluaXRpYWxTdGF0ZSA9ICh7IG5vZGVzLCBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIHdpZHRoLCBoZWlnaHQsIGZpdFZpZXcsIGZpdFZpZXdPcHRpb25zLCBtaW5ab29tID0gMC41LCBtYXhab29tID0gMiwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgfSA9IHt9KSA9PiB7XG4gICAgY29uc3Qgbm9kZUxvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwYXJlbnRMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgY29ubmVjdGlvbkxvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBlZGdlTG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHN0b3JlRWRnZXMgPSBkZWZhdWx0RWRnZXMgPz8gZWRnZXMgPz8gW107XG4gICAgY29uc3Qgc3RvcmVOb2RlcyA9IGRlZmF1bHROb2RlcyA/PyBub2RlcyA/PyBbXTtcbiAgICBjb25zdCBzdG9yZU5vZGVPcmlnaW4gPSBub2RlT3JpZ2luID8/IFswLCAwXTtcbiAgICBjb25zdCBzdG9yZU5vZGVFeHRlbnQgPSBub2RlRXh0ZW50ID8/IGluZmluaXRlRXh0ZW50O1xuICAgIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAoY29ubmVjdGlvbkxvb2t1cCwgZWRnZUxvb2t1cCwgc3RvcmVFZGdlcyk7XG4gICAgY29uc3Qgbm9kZXNJbml0aWFsaXplZCA9IGFkb3B0VXNlck5vZGVzKHN0b3JlTm9kZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwge1xuICAgICAgICBub2RlT3JpZ2luOiBzdG9yZU5vZGVPcmlnaW4sXG4gICAgICAgIG5vZGVFeHRlbnQ6IHN0b3JlTm9kZUV4dGVudCxcbiAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IGZhbHNlLFxuICAgIH0pO1xuICAgIGxldCB0cmFuc2Zvcm0gPSBbMCwgMCwgMV07XG4gICAgaWYgKGZpdFZpZXcgJiYgd2lkdGggJiYgaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IGdldEludGVybmFsTm9kZXNCb3VuZHMobm9kZUxvb2t1cCwge1xuICAgICAgICAgICAgZmlsdGVyOiAobm9kZSkgPT4gISEoKG5vZGUud2lkdGggfHwgbm9kZS5pbml0aWFsV2lkdGgpICYmIChub2RlLmhlaWdodCB8fCBub2RlLmluaXRpYWxIZWlnaHQpKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBmaXRWaWV3T3B0aW9ucz8ucGFkZGluZyA/PyAwLjEpO1xuICAgICAgICB0cmFuc2Zvcm0gPSBbeCwgeSwgem9vbV07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJmSWQ6ICcxJyxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICBub2Rlczogc3RvcmVOb2RlcyxcbiAgICAgICAgbm9kZXNJbml0aWFsaXplZCxcbiAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgcGFyZW50TG9va3VwLFxuICAgICAgICBlZGdlczogc3RvcmVFZGdlcyxcbiAgICAgICAgZWRnZUxvb2t1cCxcbiAgICAgICAgY29ubmVjdGlvbkxvb2t1cCxcbiAgICAgICAgb25Ob2Rlc0NoYW5nZTogbnVsbCxcbiAgICAgICAgb25FZGdlc0NoYW5nZTogbnVsbCxcbiAgICAgICAgaGFzRGVmYXVsdE5vZGVzOiBkZWZhdWx0Tm9kZXMgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgaGFzRGVmYXVsdEVkZ2VzOiBkZWZhdWx0RWRnZXMgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgcGFuWm9vbTogbnVsbCxcbiAgICAgICAgbWluWm9vbSxcbiAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgdHJhbnNsYXRlRXh0ZW50OiBpbmZpbml0ZUV4dGVudCxcbiAgICAgICAgbm9kZUV4dGVudDogc3RvcmVOb2RlRXh0ZW50LFxuICAgICAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICB1c2VyU2VsZWN0aW9uUmVjdDogbnVsbCxcbiAgICAgICAgY29ubmVjdGlvbk1vZGU6IENvbm5lY3Rpb25Nb2RlLlN0cmljdCxcbiAgICAgICAgZG9tTm9kZTogbnVsbCxcbiAgICAgICAgcGFuZURyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgbm9QYW5DbGFzc05hbWU6ICdub3BhbicsXG4gICAgICAgIG5vZGVPcmlnaW46IHN0b3JlTm9kZU9yaWdpbixcbiAgICAgICAgbm9kZURyYWdUaHJlc2hvbGQ6IDEsXG4gICAgICAgIHNuYXBHcmlkOiBbMTUsIDE1XSxcbiAgICAgICAgc25hcFRvR3JpZDogZmFsc2UsXG4gICAgICAgIG5vZGVzRHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICBub2Rlc0Nvbm5lY3RhYmxlOiB0cnVlLFxuICAgICAgICBub2Rlc0ZvY3VzYWJsZTogdHJ1ZSxcbiAgICAgICAgZWRnZXNGb2N1c2FibGU6IHRydWUsXG4gICAgICAgIGVkZ2VzUmVjb25uZWN0YWJsZTogdHJ1ZSxcbiAgICAgICAgZWxlbWVudHNTZWxlY3RhYmxlOiB0cnVlLFxuICAgICAgICBlbGV2YXRlTm9kZXNPblNlbGVjdDogdHJ1ZSxcbiAgICAgICAgZWxldmF0ZUVkZ2VzT25TZWxlY3Q6IGZhbHNlLFxuICAgICAgICBzZWxlY3ROb2Rlc09uRHJhZzogdHJ1ZSxcbiAgICAgICAgbXVsdGlTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICBmaXRWaWV3UXVldWVkOiBmaXRWaWV3ID8/IGZhbHNlLFxuICAgICAgICBmaXRWaWV3T3B0aW9ucyxcbiAgICAgICAgZml0Vmlld1Jlc29sdmVyOiBudWxsLFxuICAgICAgICBjb25uZWN0aW9uOiB7IC4uLmluaXRpYWxDb25uZWN0aW9uIH0sXG4gICAgICAgIGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlOiBudWxsLFxuICAgICAgICBjb25uZWN0T25DbGljazogdHJ1ZSxcbiAgICAgICAgYXJpYUxpdmVNZXNzYWdlOiAnJyxcbiAgICAgICAgYXV0b1Bhbk9uQ29ubmVjdDogdHJ1ZSxcbiAgICAgICAgYXV0b1Bhbk9uTm9kZURyYWc6IHRydWUsXG4gICAgICAgIGF1dG9QYW5TcGVlZDogMTUsXG4gICAgICAgIGNvbm5lY3Rpb25SYWRpdXM6IDIwLFxuICAgICAgICBvbkVycm9yOiBkZXZXYXJuLFxuICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICBvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzOiBbXSxcbiAgICAgICAgbGliOiAncmVhY3QnLFxuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZVN0b3JlID0gKHsgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgd2lkdGgsIGhlaWdodCwgZml0VmlldywgZml0Vmlld09wdGlvbnMsIG1pblpvb20sIG1heFpvb20sIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIH0pID0+IGNyZWF0ZVdpdGhFcXVhbGl0eUZuKChzZXQsIGdldCkgPT4ge1xuICAgIGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVGaXRWaWV3KCkge1xuICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHBhblpvb20sIGZpdFZpZXdPcHRpb25zLCBmaXRWaWV3UmVzb2x2ZXIsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20gfSA9IGdldCgpO1xuICAgICAgICBpZiAoIXBhblpvb20pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBmaXRWaWV3cG9ydCh7XG4gICAgICAgICAgICBub2Rlczogbm9kZUxvb2t1cCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgcGFuWm9vbSxcbiAgICAgICAgICAgIG1pblpvb20sXG4gICAgICAgICAgICBtYXhab29tLFxuICAgICAgICB9LCBmaXRWaWV3T3B0aW9ucyk7XG4gICAgICAgIGZpdFZpZXdSZXNvbHZlcj8ucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdhaXQgZm9yIHRoZSBmaXRWaWV3cG9ydCB0byByZXNvbHZlIGJlZm9yZSBkZWxldGluZyB0aGUgcmVzb2x2ZXIsXG4gICAgICAgICAqIHdlIHdhbnQgdG8gcmV1c2UgdGhlIG9sZCByZXNvbHZlciBpZiB0aGUgdXNlciBjYWxscyBmaXRWaWV3IGFnYWluIGluIHRoZSBtZWFuIHRpbWVcbiAgICAgICAgICovXG4gICAgICAgIHNldCh7IGZpdFZpZXdSZXNvbHZlcjogbnVsbCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZ2V0SW5pdGlhbFN0YXRlKHtcbiAgICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIGZpdFZpZXcsXG4gICAgICAgICAgICBmaXRWaWV3T3B0aW9ucyxcbiAgICAgICAgICAgIG1pblpvb20sXG4gICAgICAgICAgICBtYXhab29tLFxuICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgIG5vZGVFeHRlbnQsXG4gICAgICAgICAgICBkZWZhdWx0Tm9kZXMsXG4gICAgICAgICAgICBkZWZhdWx0RWRnZXMsXG4gICAgICAgIH0pLFxuICAgICAgICBzZXROb2RlczogKG5vZGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiwgZWxldmF0ZU5vZGVzT25TZWxlY3QsIGZpdFZpZXdRdWV1ZWQgfSA9IGdldCgpO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHNldE5vZGVzKCkgaXMgY2FsbGVkIGV4Y2x1c2l2ZWx5IGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9uczpcbiAgICAgICAgICAgICAqIC0gZWl0aGVyIHdoZW4gdGhlIGA8UmVhY3RGbG93IG5vZGVzPmAgcHJvcCBpcyB1cGRhdGVkIGluIHRoZSBjb250cm9sbGVkIFJlYWN0RmxvdyBzZXR1cCxcbiAgICAgICAgICAgICAqIC0gb3Igd2hlbiB0aGUgdXNlciBjYWxscyBzb21ldGhpbmcgbGlrZSBgcmVhY3RGbG93SW5zdGFuY2Uuc2V0Tm9kZXMoKWAgaW4gYW4gdW5jb250cm9sbGVkIFJlYWN0RmxvdyBzZXR1cC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBXaGVuIHRoaXMgaGFwcGVucywgd2UgdGFrZSB0aGUgbm90ZSBvYmplY3RzIHBhc3NlZCBieSB0aGUgdXNlciBhbmQgZXh0ZW5kIHRoZW0gd2l0aCBmaWVsZHNcbiAgICAgICAgICAgICAqIHJlbGV2YW50IGZvciBpbnRlcm5hbCBSZWFjdCBGbG93IG9wZXJhdGlvbnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IG5vZGVzSW5pdGlhbGl6ZWQgPSBhZG9wdFVzZXJOb2Rlcyhub2Rlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7XG4gICAgICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgICAgICBub2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0LFxuICAgICAgICAgICAgICAgIGNoZWNrRXF1YWxpdHk6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChmaXRWaWV3UXVldWVkICYmIG5vZGVzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlRml0VmlldygpO1xuICAgICAgICAgICAgICAgIHNldCh7IG5vZGVzLCBub2Rlc0luaXRpYWxpemVkLCBmaXRWaWV3UXVldWVkOiBmYWxzZSwgZml0Vmlld09wdGlvbnM6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldCh7IG5vZGVzLCBub2Rlc0luaXRpYWxpemVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRFZGdlczogKGVkZ2VzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb25Mb29rdXAsIGVkZ2VMb29rdXAgfSA9IGdldCgpO1xuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvbkxvb2t1cChjb25uZWN0aW9uTG9va3VwLCBlZGdlTG9va3VwLCBlZGdlcyk7XG4gICAgICAgICAgICBzZXQoeyBlZGdlcyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXM6IChub2RlcywgZWRnZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2V0Tm9kZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgICAgIHNldE5vZGVzKG5vZGVzKTtcbiAgICAgICAgICAgICAgICBzZXQoeyBoYXNEZWZhdWx0Tm9kZXM6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWRnZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNldEVkZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgICAgICBzZXRFZGdlcyhlZGdlcyk7XG4gICAgICAgICAgICAgICAgc2V0KHsgaGFzRGVmYXVsdEVkZ2VzOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKlxuICAgICAgICAgKiBFdmVyeSBub2RlIGdldHMgcmVnaXN0ZXJkIGF0IGEgUmVzaXplT2JzZXJ2ZXIuIFdoZW5ldmVyIGEgbm9kZVxuICAgICAgICAgKiBjaGFuZ2VzIGl0cyBkaW1lbnNpb25zLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBtZWFzdXJlIHRoZVxuICAgICAgICAgKiBuZXcgZGltZW5zaW9ucyBhbmQgdXBkYXRlIHRoZSBub2Rlcy5cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZU5vZGVJbnRlcm5hbHM6ICh1cGRhdGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHRyaWdnZXJOb2RlQ2hhbmdlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBkb21Ob2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBkZWJ1ZywgZml0Vmlld1F1ZXVlZCB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBjb25zdCB7IGNoYW5nZXMsIHVwZGF0ZWRJbnRlcm5hbHMgfSA9IHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBkb21Ob2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50KTtcbiAgICAgICAgICAgIGlmICghdXBkYXRlZEludGVybmFscykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZUFic29sdXRlUG9zaXRpb25zKG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgeyBub2RlT3JpZ2luLCBub2RlRXh0ZW50IH0pO1xuICAgICAgICAgICAgaWYgKGZpdFZpZXdRdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlRml0VmlldygpO1xuICAgICAgICAgICAgICAgIHNldCh7IGZpdFZpZXdRdWV1ZWQ6IGZhbHNlLCBmaXRWaWV3T3B0aW9uczogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYWx3YXlzIHdhbnQgdG8gdHJpZ2dlciB1c2VTdG9yZSBjYWxscyB3aGVuZXZlciB1cGRhdGVOb2RlSW50ZXJuYWxzIGlzIGNhbGxlZFxuICAgICAgICAgICAgICAgIHNldCh7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVhY3QgRmxvdzogdHJpZ2dlciBub2RlIGNoYW5nZXMnLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzPy4oY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnM6IChub2RlRHJhZ0l0ZW1zLCBkcmFnZ2luZyA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCB0cmlnZ2VyTm9kZUNoYW5nZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaWQsIGRyYWdJdGVtXSBvZiBub2RlRHJhZ0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIHVzaW5nIHRoZSBub2RlbG9va3VwIHRvIGJlIHN1cmUgdG8gdXNlIHRoZSBjdXJyZW50IGV4cGFuZFBhcmVudCBhbmQgcGFyZW50SWQgdmFsdWVcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGFuZFBhcmVudCA9ICEhKG5vZGU/LmV4cGFuZFBhcmVudCAmJiBub2RlPy5wYXJlbnRJZCAmJiBkcmFnSXRlbT8ucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHBhbmRQYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IE1hdGgubWF4KDAsIGRyYWdJdGVtLnBvc2l0aW9uLngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IE1hdGgubWF4KDAsIGRyYWdJdGVtLnBvc2l0aW9uLnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBkcmFnSXRlbS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwYW5kUGFyZW50ICYmIG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RXhwYW5kQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBub2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRyYWdJdGVtLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkcmFnSXRlbS5tZWFzdXJlZC53aWR0aCA/PyAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZHJhZ0l0ZW0ubWVhc3VyZWQuaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50RXhwYW5kQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luIH0gPSBnZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGFuZ2VzID0gaGFuZGxlRXhwYW5kUGFyZW50KHBhcmVudEV4cGFuZENoaWxkcmVuLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCguLi5wYXJlbnRFeHBhbmRDaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzOiAoY2hhbmdlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbk5vZGVzQ2hhbmdlLCBzZXROb2Rlcywgbm9kZXMsIGhhc0RlZmF1bHROb2RlcywgZGVidWcgfSA9IGdldCgpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZE5vZGVzID0gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBub2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIHNldE5vZGVzKHVwZGF0ZWROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVhY3QgRmxvdzogdHJpZ2dlciBub2RlIGNoYW5nZXMnLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZT8uKGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXM6IChjaGFuZ2VzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9uRWRnZXNDaGFuZ2UsIHNldEVkZ2VzLCBlZGdlcywgaGFzRGVmYXVsdEVkZ2VzLCBkZWJ1ZyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHRFZGdlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkRWRnZXMgPSBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIGVkZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0RWRnZXModXBkYXRlZEVkZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWFjdCBGbG93OiB0cmlnZ2VyIGVkZ2UgY2hhbmdlcycsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbkVkZ2VzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFNlbGVjdGVkTm9kZXM6IChzZWxlY3RlZE5vZGVJZHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VMb29rdXAsIG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmIChtdWx0aVNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVDaGFuZ2VzID0gc2VsZWN0ZWROb2RlSWRzLm1hcCgobm9kZUlkKSA9PiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobm9kZUlkLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKG5vZGVDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhub2RlTG9va3VwLCBuZXcgU2V0KFsuLi5zZWxlY3RlZE5vZGVJZHNdKSwgdHJ1ZSkpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGdldFNlbGVjdGlvbkNoYW5nZXMoZWRnZUxvb2t1cCkpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRTZWxlY3RlZEVkZ2VzOiAoc2VsZWN0ZWRFZGdlSWRzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG11bHRpU2VsZWN0aW9uQWN0aXZlLCBlZGdlTG9va3VwLCBub2RlTG9va3VwLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBpZiAobXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VkRWRnZXMgPSBzZWxlY3RlZEVkZ2VJZHMubWFwKChlZGdlSWQpID0+IGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShlZGdlSWQsIHRydWUpKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoY2hhbmdlZEVkZ2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlTG9va3VwLCBuZXcgU2V0KFsuLi5zZWxlY3RlZEVkZ2VJZHNdKSkpO1xuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGdldFNlbGVjdGlvbkNoYW5nZXMobm9kZUxvb2t1cCwgbmV3IFNldCgpLCB0cnVlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlczogKHsgbm9kZXMsIGVkZ2VzIH0gPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlczogc3RvcmVFZGdlcywgbm9kZXM6IHN0b3JlTm9kZXMsIG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzVG9VbnNlbGVjdCA9IG5vZGVzID8gbm9kZXMgOiBzdG9yZU5vZGVzO1xuICAgICAgICAgICAgY29uc3QgZWRnZXNUb1Vuc2VsZWN0ID0gZWRnZXMgPyBlZGdlcyA6IHN0b3JlRWRnZXM7XG4gICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IG5vZGVzVG9VbnNlbGVjdC5tYXAoKG4pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGUgPSBub2RlTG9va3VwLmdldChuLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIHdlIG5lZWQgdG8gdW5zZWxlY3QgdGhlIGludGVybmFsIG5vZGUgdGhhdCB3YXMgc2VsZWN0ZWQgcHJldmlvdXNseSBiZWZvcmUgd2VcbiAgICAgICAgICAgICAgICAgICAgICogc2VuZCB0aGUgY2hhbmdlIHRvIHRoZSB1c2VyIHRvIHByZXZlbnQgaXQgdG8gYmUgc2VsZWN0ZWQgd2hpbGUgZHJhZ2dpbmcgdGhlIG5ldyBub2RlXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbE5vZGUuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShuLmlkLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VDaGFuZ2VzID0gZWRnZXNUb1Vuc2VsZWN0Lm1hcCgoZWRnZSkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2UuaWQsIGZhbHNlKSk7XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGVkZ2VDaGFuZ2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TWluWm9vbTogKG1pblpvb20pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSwgbWF4Wm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBwYW5ab29tPy5zZXRTY2FsZUV4dGVudChbbWluWm9vbSwgbWF4Wm9vbV0pO1xuICAgICAgICAgICAgc2V0KHsgbWluWm9vbSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TWF4Wm9vbTogKG1heFpvb20pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSwgbWluWm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBwYW5ab29tPy5zZXRTY2FsZUV4dGVudChbbWluWm9vbSwgbWF4Wm9vbV0pO1xuICAgICAgICAgICAgc2V0KHsgbWF4Wm9vbSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VHJhbnNsYXRlRXh0ZW50OiAodHJhbnNsYXRlRXh0ZW50KSA9PiB7XG4gICAgICAgICAgICBnZXQoKS5wYW5ab29tPy5zZXRUcmFuc2xhdGVFeHRlbnQodHJhbnNsYXRlRXh0ZW50KTtcbiAgICAgICAgICAgIHNldCh7IHRyYW5zbGF0ZUV4dGVudCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0UGFuZUNsaWNrRGlzdGFuY2U6IChjbGlja0Rpc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICBnZXQoKS5wYW5ab29tPy5zZXRDbGlja0Rpc3RhbmNlKGNsaWNrRGlzdGFuY2UpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldFNlbGVjdGVkRWxlbWVudHM6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRnZXMsIG5vZGVzLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcywgZWxlbWVudHNTZWxlY3RhYmxlIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmICghZWxlbWVudHNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9kZUNoYW5nZXMgPSBub2Rlcy5yZWR1Y2UoKHJlcywgbm9kZSkgPT4gKG5vZGUuc2VsZWN0ZWQgPyBbLi4ucmVzLCBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobm9kZS5pZCwgZmFsc2UpXSA6IHJlcyksIFtdKTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VDaGFuZ2VzID0gZWRnZXMucmVkdWNlKChyZXMsIGVkZ2UpID0+IChlZGdlLnNlbGVjdGVkID8gWy4uLnJlcywgY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2UuaWQsIGZhbHNlKV0gOiByZXMpLCBbXSk7XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGVkZ2VDaGFuZ2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Tm9kZUV4dGVudDogKG5leHROb2RlRXh0ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4sIGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBub2RlRXh0ZW50IH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0Tm9kZUV4dGVudFswXVswXSA9PT0gbm9kZUV4dGVudFswXVswXSAmJlxuICAgICAgICAgICAgICAgIG5leHROb2RlRXh0ZW50WzBdWzFdID09PSBub2RlRXh0ZW50WzBdWzFdICYmXG4gICAgICAgICAgICAgICAgbmV4dE5vZGVFeHRlbnRbMV1bMF0gPT09IG5vZGVFeHRlbnRbMV1bMF0gJiZcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZUV4dGVudFsxXVsxXSA9PT0gbm9kZUV4dGVudFsxXVsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkb3B0VXNlck5vZGVzKG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHtcbiAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgIG5vZGVFeHRlbnQ6IG5leHROb2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0LFxuICAgICAgICAgICAgICAgIGNoZWNrRXF1YWxpdHk6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXQoeyBub2RlRXh0ZW50OiBuZXh0Tm9kZUV4dGVudCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFuQnk6IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHdpZHRoLCBoZWlnaHQsIHBhblpvb20sIHRyYW5zbGF0ZUV4dGVudCB9ID0gZ2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gcGFuQnkoeyBkZWx0YSwgcGFuWm9vbSwgdHJhbnNmb3JtLCB0cmFuc2xhdGVFeHRlbnQsIHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbENvbm5lY3Rpb246ICgpID0+IHtcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbjogeyAuLi5pbml0aWFsQ29ubmVjdGlvbiB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUNvbm5lY3Rpb246IChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBzZXQoeyBjb25uZWN0aW9uIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZXNldDogKCkgPT4gc2V0KHsgLi4uZ2V0SW5pdGlhbFN0YXRlKCkgfSksXG4gICAgfTtcbn0sIE9iamVjdC5pcyk7XG5cbi8qKlxuICogVGhlIGA8UmVhY3RGbG93UHJvdmlkZXIgLz5gIGNvbXBvbmVudCBpcyBhIFtjb250ZXh0IHByb3ZpZGVyXShodHRwczovL3JlYWN0LmRldi9sZWFybi9wYXNzaW5nLWRhdGEtZGVlcGx5LXdpdGgtY29udGV4dCMpXG4gKiB0aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvIGFjY2VzcyBhIGZsb3cncyBpbnRlcm5hbCBzdGF0ZSBvdXRzaWRlIG9mIHRoZVxuICogW2A8UmVhY3RGbG93IC8+YF0oL2FwaS1yZWZlcmVuY2UvcmVhY3QtZmxvdykgY29tcG9uZW50LiBNYW55IG9mIHRoZSBob29rcyB3ZVxuICogcHJvdmlkZSByZWx5IG9uIHRoaXMgY29tcG9uZW50IHRvIHdvcmsuXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIFJlYWN0Rmxvd1Byb3ZpZGVyLCB1c2VOb2RlcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnXG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93UHJvdmlkZXI+XG4gKiAgICAgIDxSZWFjdEZsb3cgbm9kZXM9ey4uLn0gZWRnZXM9ey4uLn0gLz5cbiAqICAgICAgPFNpZGViYXIgLz5cbiAqICAgIDwvUmVhY3RGbG93UHJvdmlkZXI+XG4gKiAgKTtcbiAqfVxuICpcbiAqZnVuY3Rpb24gU2lkZWJhcigpIHtcbiAqICAvLyBUaGlzIGhvb2sgd2lsbCBvbmx5IHdvcmsgaWYgdGhlIGNvbXBvbmVudCBpdCdzIHVzZWQgaW4gaXMgYSBjaGlsZCBvZiBhXG4gKiAgLy8gPFJlYWN0Rmxvd1Byb3ZpZGVyIC8+LlxuICogIGNvbnN0IG5vZGVzID0gdXNlTm9kZXMoKVxuICpcbiAqICByZXR1cm4gPGFzaWRlPmRvIHNvbWV0aGluZyB3aXRoIG5vZGVzPC9hc2lkZT47XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgSWYgeW91J3JlIHVzaW5nIGEgcm91dGVyIGFuZCB3YW50IHlvdXIgZmxvdydzIHN0YXRlIHRvIHBlcnNpc3QgYWNyb3NzIHJvdXRlcyxcbiAqIGl0J3Mgdml0YWwgdGhhdCB5b3UgcGxhY2UgdGhlIGA8UmVhY3RGbG93UHJvdmlkZXIgLz5gIGNvbXBvbmVudCBfb3V0c2lkZV8gb2ZcbiAqIHlvdXIgcm91dGVyLiBJZiB5b3UgaGF2ZSBtdWx0aXBsZSBmbG93cyBvbiB0aGUgc2FtZSBwYWdlIHlvdSB3aWxsIG5lZWQgdG8gdXNlIGEgc2VwYXJhdGVcbiAqIGA8UmVhY3RGbG93UHJvdmlkZXIgLz5gIGZvciBlYWNoIGZsb3cuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0Rmxvd1Byb3ZpZGVyKHsgaW5pdGlhbE5vZGVzOiBub2RlcywgaW5pdGlhbEVkZ2VzOiBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIGluaXRpYWxXaWR0aDogd2lkdGgsIGluaXRpYWxIZWlnaHQ6IGhlaWdodCwgaW5pdGlhbE1pblpvb206IG1pblpvb20sIGluaXRpYWxNYXhab29tOiBtYXhab29tLCBpbml0aWFsRml0Vmlld09wdGlvbnM6IGZpdFZpZXdPcHRpb25zLCBmaXRWaWV3LCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBjaGlsZHJlbiwgfSkge1xuICAgIGNvbnN0IFtzdG9yZV0gPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGVTdG9yZSh7XG4gICAgICAgIG5vZGVzLFxuICAgICAgICBlZGdlcyxcbiAgICAgICAgZGVmYXVsdE5vZGVzLFxuICAgICAgICBkZWZhdWx0RWRnZXMsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGZpdFZpZXcsXG4gICAgICAgIG1pblpvb20sXG4gICAgICAgIG1heFpvb20sXG4gICAgICAgIGZpdFZpZXdPcHRpb25zLFxuICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICBub2RlRXh0ZW50LFxuICAgIH0pKTtcbiAgICByZXR1cm4gKGpzeChQcm92aWRlciQxLCB7IHZhbHVlOiBzdG9yZSwgY2hpbGRyZW46IGpzeChCYXRjaFByb3ZpZGVyLCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIFdyYXBwZXIoeyBjaGlsZHJlbiwgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgd2lkdGgsIGhlaWdodCwgZml0VmlldywgZml0Vmlld09wdGlvbnMsIG1pblpvb20sIG1heFpvb20sIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIH0pIHtcbiAgICBjb25zdCBpc1dyYXBwZWQgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKGlzV3JhcHBlZCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiB3ZSBuZWVkIHRvIHdyYXAgaXQgd2l0aCBhIGZyYWdtZW50IGJlY2F1c2UgaXQncyBub3QgYWxsb3dlZCBmb3IgY2hpbGRyZW4gdG8gYmUgYSBSZWFjdE5vZGVcbiAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL0RlZmluaXRlbHlUeXBlZC9EZWZpbml0ZWx5VHlwZWQvaXNzdWVzLzE4MDUxXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goUmVhY3RGbG93UHJvdmlkZXIsIHsgaW5pdGlhbE5vZGVzOiBub2RlcywgaW5pdGlhbEVkZ2VzOiBlZGdlcywgZGVmYXVsdE5vZGVzOiBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlczogZGVmYXVsdEVkZ2VzLCBpbml0aWFsV2lkdGg6IHdpZHRoLCBpbml0aWFsSGVpZ2h0OiBoZWlnaHQsIGZpdFZpZXc6IGZpdFZpZXcsIGluaXRpYWxGaXRWaWV3T3B0aW9uczogZml0Vmlld09wdGlvbnMsIGluaXRpYWxNaW5ab29tOiBtaW5ab29tLCBpbml0aWFsTWF4Wm9vbTogbWF4Wm9vbSwgbm9kZU9yaWdpbjogbm9kZU9yaWdpbiwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cblxuY29uc3Qgd3JhcHBlclN0eWxlID0ge1xuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIHpJbmRleDogMCxcbn07XG5mdW5jdGlvbiBSZWFjdEZsb3coeyBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCBjbGFzc05hbWUsIG5vZGVUeXBlcywgZWRnZVR5cGVzLCBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2ssIG9uSW5pdCwgb25Nb3ZlLCBvbk1vdmVTdGFydCwgb25Nb3ZlRW5kLCBvbkNvbm5lY3QsIG9uQ29ubmVjdFN0YXJ0LCBvbkNvbm5lY3RFbmQsIG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kLCBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51LCBvbk5vZGVEb3VibGVDbGljaywgb25Ob2RlRHJhZ1N0YXJ0LCBvbk5vZGVEcmFnLCBvbk5vZGVEcmFnU3RvcCwgb25Ob2Rlc0RlbGV0ZSwgb25FZGdlc0RlbGV0ZSwgb25EZWxldGUsIG9uU2VsZWN0aW9uQ2hhbmdlLCBvblNlbGVjdGlvbkRyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnLCBvblNlbGVjdGlvbkRyYWdTdG9wLCBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgb25CZWZvcmVEZWxldGUsIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uTGluZVR5cGUgPSBDb25uZWN0aW9uTGluZVR5cGUuQmV6aWVyLCBjb25uZWN0aW9uTGluZVN0eWxlLCBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSwgZGVsZXRlS2V5Q29kZSA9ICdCYWNrc3BhY2UnLCBzZWxlY3Rpb25LZXlDb2RlID0gJ1NoaWZ0Jywgc2VsZWN0aW9uT25EcmFnID0gZmFsc2UsIHNlbGVjdGlvbk1vZGUgPSBTZWxlY3Rpb25Nb2RlLkZ1bGwsIHBhbkFjdGl2YXRpb25LZXlDb2RlID0gJ1NwYWNlJywgbXVsdGlTZWxlY3Rpb25LZXlDb2RlID0gaXNNYWNPcygpID8gJ01ldGEnIDogJ0NvbnRyb2wnLCB6b29tQWN0aXZhdGlvbktleUNvZGUgPSBpc01hY09zKCkgPyAnTWV0YScgOiAnQ29udHJvbCcsIHNuYXBUb0dyaWQsIHNuYXBHcmlkLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzID0gZmFsc2UsIHNlbGVjdE5vZGVzT25EcmFnLCBub2Rlc0RyYWdnYWJsZSwgbm9kZXNDb25uZWN0YWJsZSwgbm9kZXNGb2N1c2FibGUsIG5vZGVPcmlnaW4gPSBkZWZhdWx0Tm9kZU9yaWdpbiwgZWRnZXNGb2N1c2FibGUsIGVkZ2VzUmVjb25uZWN0YWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlID0gdHJ1ZSwgZGVmYXVsdFZpZXdwb3J0OiBkZWZhdWx0Vmlld3BvcnQkMSA9IGRlZmF1bHRWaWV3cG9ydCwgbWluWm9vbSA9IDAuNSwgbWF4Wm9vbSA9IDIsIHRyYW5zbGF0ZUV4dGVudCA9IGluZmluaXRlRXh0ZW50LCBwcmV2ZW50U2Nyb2xsaW5nID0gdHJ1ZSwgbm9kZUV4dGVudCwgZGVmYXVsdE1hcmtlckNvbG9yID0gJyNiMWIxYjcnLCB6b29tT25TY3JvbGwgPSB0cnVlLCB6b29tT25QaW5jaCA9IHRydWUsIHBhbk9uU2Nyb2xsID0gZmFsc2UsIHBhbk9uU2Nyb2xsU3BlZWQgPSAwLjUsIHBhbk9uU2Nyb2xsTW9kZSA9IFBhbk9uU2Nyb2xsTW9kZS5GcmVlLCB6b29tT25Eb3VibGVDbGljayA9IHRydWUsIHBhbk9uRHJhZyA9IHRydWUsIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZVNjcm9sbCwgb25QYW5lQ29udGV4dE1lbnUsIHBhbmVDbGlja0Rpc3RhbmNlID0gMCwgbm9kZUNsaWNrRGlzdGFuY2UgPSAwLCBjaGlsZHJlbiwgb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlRG91YmxlQ2xpY2ssIG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzID0gMTAsIG9uTm9kZXNDaGFuZ2UsIG9uRWRnZXNDaGFuZ2UsIG5vRHJhZ0NsYXNzTmFtZSA9ICdub2RyYWcnLCBub1doZWVsQ2xhc3NOYW1lID0gJ25vd2hlZWwnLCBub1BhbkNsYXNzTmFtZSA9ICdub3BhbicsIGZpdFZpZXcsIGZpdFZpZXdPcHRpb25zLCBjb25uZWN0T25DbGljaywgYXR0cmlidXRpb25Qb3NpdGlvbiwgcHJvT3B0aW9ucywgZGVmYXVsdEVkZ2VPcHRpb25zLCBlbGV2YXRlTm9kZXNPblNlbGVjdCwgZWxldmF0ZUVkZ2VzT25TZWxlY3QsIGRpc2FibGVLZXlib2FyZEExMXkgPSBmYWxzZSwgYXV0b1Bhbk9uQ29ubmVjdCwgYXV0b1Bhbk9uTm9kZURyYWcsIGF1dG9QYW5TcGVlZCwgY29ubmVjdGlvblJhZGl1cywgaXNWYWxpZENvbm5lY3Rpb24sIG9uRXJyb3IsIHN0eWxlLCBpZCwgbm9kZURyYWdUaHJlc2hvbGQsIHZpZXdwb3J0LCBvblZpZXdwb3J0Q2hhbmdlLCB3aWR0aCwgaGVpZ2h0LCBjb2xvck1vZGUgPSAnbGlnaHQnLCBkZWJ1Zywgb25TY3JvbGwsIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgY29uc3QgcmZJZCA9IGlkIHx8ICcxJztcbiAgICBjb25zdCBjb2xvck1vZGVDbGFzc05hbWUgPSB1c2VDb2xvck1vZGVDbGFzcyhjb2xvck1vZGUpO1xuICAgIC8vIFVuZG8gc2Nyb2xsIGV2ZW50cywgcHJldmVudGluZyB2aWV3cG9ydCBmcm9tIHNoaWZ0aW5nIHdoZW4gbm9kZXMgb3V0c2lkZSBvZiBpdCBhcmUgZm9jdXNlZFxuICAgIGNvbnN0IHdyYXBwZXJPblNjcm9sbCA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XG4gICAgICAgIGUuY3VycmVudFRhcmdldC5zY3JvbGxUbyh7IHRvcDogMCwgbGVmdDogMCwgYmVoYXZpb3I6ICdpbnN0YW50JyB9KTtcbiAgICAgICAgb25TY3JvbGw/LihlKTtcbiAgICB9LCBbb25TY3JvbGxdKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IFwiZGF0YS10ZXN0aWRcIjogXCJyZl9fd3JhcHBlclwiLCAuLi5yZXN0LCBvblNjcm9sbDogd3JhcHBlck9uU2Nyb2xsLCBzdHlsZTogeyAuLi5zdHlsZSwgLi4ud3JhcHBlclN0eWxlIH0sIHJlZjogcmVmLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvdycsIGNsYXNzTmFtZSwgY29sb3JNb2RlQ2xhc3NOYW1lXSksIGlkOiBpZCwgY2hpbGRyZW46IGpzeHMoV3JhcHBlciwgeyBub2Rlczogbm9kZXMsIGVkZ2VzOiBlZGdlcywgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgZml0VmlldzogZml0VmlldywgZml0Vmlld09wdGlvbnM6IGZpdFZpZXdPcHRpb25zLCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCBjaGlsZHJlbjogW2pzeChHcmFwaFZpZXcsIHsgb25Jbml0OiBvbkluaXQsIG9uTm9kZUNsaWNrOiBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2s6IG9uRWRnZUNsaWNrLCBvbk5vZGVNb3VzZUVudGVyOiBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmU6IG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZTogb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnU6IG9uTm9kZUNvbnRleHRNZW51LCBvbk5vZGVEb3VibGVDbGljazogb25Ob2RlRG91YmxlQ2xpY2ssIG5vZGVUeXBlczogbm9kZVR5cGVzLCBlZGdlVHlwZXM6IGVkZ2VUeXBlcywgY29ubmVjdGlvbkxpbmVUeXBlOiBjb25uZWN0aW9uTGluZVR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGU6IGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50OiBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZTogY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSwgc2VsZWN0aW9uS2V5Q29kZTogc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnOiBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIGRlbGV0ZUtleUNvZGU6IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZTogbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZTogcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCQxLCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZzogcHJldmVudFNjcm9sbGluZywgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBub2RlQ2xpY2tEaXN0YW5jZTogbm9kZUNsaWNrRGlzdGFuY2UsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIG9uRWRnZUNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VNb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIGRlZmF1bHRNYXJrZXJDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCByZklkOiByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCB2aWV3cG9ydDogdmlld3BvcnQsIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UgfSksIGpzeChTdG9yZVVwZGF0ZXIsIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMsIGRlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXM6IGRlZmF1bHRFZGdlcywgb25Db25uZWN0OiBvbkNvbm5lY3QsIG9uQ29ubmVjdFN0YXJ0OiBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kOiBvbkNvbm5lY3RFbmQsIG9uQ2xpY2tDb25uZWN0U3RhcnQ6IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kOiBvbkNsaWNrQ29ubmVjdEVuZCwgbm9kZXNEcmFnZ2FibGU6IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlOiBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZTogbm9kZXNGb2N1c2FibGUsIGVkZ2VzRm9jdXNhYmxlOiBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlOiBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCBlbGV2YXRlTm9kZXNPblNlbGVjdDogZWxldmF0ZU5vZGVzT25TZWxlY3QsIGVsZXZhdGVFZGdlc09uU2VsZWN0OiBlbGV2YXRlRWRnZXNPblNlbGVjdCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgb25Ob2Rlc0NoYW5nZTogb25Ob2Rlc0NoYW5nZSwgb25FZGdlc0NoYW5nZTogb25FZGdlc0NoYW5nZSwgc25hcFRvR3JpZDogc25hcFRvR3JpZCwgc25hcEdyaWQ6IHNuYXBHcmlkLCBjb25uZWN0aW9uTW9kZTogY29ubmVjdGlvbk1vZGUsIHRyYW5zbGF0ZUV4dGVudDogdHJhbnNsYXRlRXh0ZW50LCBjb25uZWN0T25DbGljazogY29ubmVjdE9uQ2xpY2ssIGRlZmF1bHRFZGdlT3B0aW9uczogZGVmYXVsdEVkZ2VPcHRpb25zLCBmaXRWaWV3OiBmaXRWaWV3LCBmaXRWaWV3T3B0aW9uczogZml0Vmlld09wdGlvbnMsIG9uTm9kZXNEZWxldGU6IG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGU6IG9uRWRnZXNEZWxldGUsIG9uRGVsZXRlOiBvbkRlbGV0ZSwgb25Ob2RlRHJhZ1N0YXJ0OiBvbk5vZGVEcmFnU3RhcnQsIG9uTm9kZURyYWc6IG9uTm9kZURyYWcsIG9uTm9kZURyYWdTdG9wOiBvbk5vZGVEcmFnU3RvcCwgb25TZWxlY3Rpb25EcmFnOiBvblNlbGVjdGlvbkRyYWcsIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0OiBvblNlbGVjdGlvbkRyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnU3RvcDogb25TZWxlY3Rpb25EcmFnU3RvcCwgb25Nb3ZlOiBvbk1vdmUsIG9uTW92ZVN0YXJ0OiBvbk1vdmVTdGFydCwgb25Nb3ZlRW5kOiBvbk1vdmVFbmQsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgbm9kZU9yaWdpbjogbm9kZU9yaWdpbiwgcmZJZDogcmZJZCwgYXV0b1Bhbk9uQ29ubmVjdDogYXV0b1Bhbk9uQ29ubmVjdCwgYXV0b1Bhbk9uTm9kZURyYWc6IGF1dG9QYW5Pbk5vZGVEcmFnLCBhdXRvUGFuU3BlZWQ6IGF1dG9QYW5TcGVlZCwgb25FcnJvcjogb25FcnJvciwgY29ubmVjdGlvblJhZGl1czogY29ubmVjdGlvblJhZGl1cywgaXNWYWxpZENvbm5lY3Rpb246IGlzVmFsaWRDb25uZWN0aW9uLCBzZWxlY3ROb2Rlc09uRHJhZzogc2VsZWN0Tm9kZXNPbkRyYWcsIG5vZGVEcmFnVGhyZXNob2xkOiBub2RlRHJhZ1RocmVzaG9sZCwgb25CZWZvcmVEZWxldGU6IG9uQmVmb3JlRGVsZXRlLCBwYW5lQ2xpY2tEaXN0YW5jZTogcGFuZUNsaWNrRGlzdGFuY2UsIGRlYnVnOiBkZWJ1ZyB9KSwganN4KFNlbGVjdGlvbkxpc3RlbmVyLCB7IG9uU2VsZWN0aW9uQ2hhbmdlOiBvblNlbGVjdGlvbkNoYW5nZSB9KSwgY2hpbGRyZW4sIGpzeChBdHRyaWJ1dGlvbiwgeyBwcm9PcHRpb25zOiBwcm9PcHRpb25zLCBwb3NpdGlvbjogYXR0cmlidXRpb25Qb3NpdGlvbiB9KSwganN4KEExMXlEZXNjcmlwdGlvbnMsIHsgcmZJZDogcmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSB9KV0gfSkgfSkpO1xufVxuLyoqXG4gKiBUaGUgYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudCBpcyB0aGUgaGVhcnQgb2YgeW91ciBSZWFjdCBGbG93IGFwcGxpY2F0aW9uLlxuICogSXQgcmVuZGVycyB5b3VyIG5vZGVzIGFuZCBlZGdlcyBhbmQgaGFuZGxlcyB1c2VyIGludGVyYWN0aW9uXG4gKlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93IH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCdcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuICg8UmVhY3RGbG93XG4gKiAgICBub2Rlcz17Li4ufVxuICogICAgZWRnZXM9ey4uLn1cbiAqICAgIG9uTm9kZXNDaGFuZ2U9ey4uLn1cbiAqICAgIC4uLlxuICogIC8+KTtcbiAqfVxuICpgYGBcbiAqL1xudmFyIGluZGV4ID0gZml4ZWRGb3J3YXJkUmVmKFJlYWN0Rmxvdyk7XG5cbmNvbnN0IHNlbGVjdG9yJDYgPSAocykgPT4gcy5kb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fZWRnZWxhYmVsLXJlbmRlcmVyJyk7XG4vKipcbiAqIEVkZ2VzIGFyZSBTVkctYmFzZWQuIElmIHlvdSB3YW50IHRvIHJlbmRlciBtb3JlIGNvbXBsZXggbGFiZWxzIHlvdSBjYW4gdXNlIHRoZVxuICogYDxFZGdlTGFiZWxSZW5kZXJlciAvPmAgY29tcG9uZW50IHRvIGFjY2VzcyBhIGRpdiBiYXNlZCByZW5kZXJlci4gVGhpcyBjb21wb25lbnRcbiAqIGlzIGEgcG9ydGFsIHRoYXQgcmVuZGVycyB0aGUgbGFiZWwgaW4gYSBgPGRpdiAvPmAgdGhhdCBpcyBwb3NpdGlvbmVkIG9uIHRvcCBvZlxuICogdGhlIGVkZ2VzLiBZb3UgY2FuIHNlZSBhbiBleGFtcGxlIHVzYWdlIG9mIHRoZSBjb21wb25lbnQgaW4gdGhlXG4gKiBbZWRnZSBsYWJlbCByZW5kZXJlciBleGFtcGxlXSgvZXhhbXBsZXMvZWRnZXMvZWRnZS1sYWJlbC1yZW5kZXJlcikuXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbiAqIGltcG9ydCB7IGdldEJlemllclBhdGgsIEVkZ2VMYWJlbFJlbmRlcmVyLCBCYXNlRWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGV4cG9ydCBmdW5jdGlvbiBDdXN0b21FZGdlKHsgaWQsIGRhdGEsIC4uLnByb3BzIH0pIHtcbiAqICAgY29uc3QgW2VkZ2VQYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRCZXppZXJQYXRoKHByb3BzKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPD5cbiAqICAgICAgIDxCYXNlRWRnZSBpZD17aWR9IHBhdGg9e2VkZ2VQYXRofSAvPlxuICogICAgICAgPEVkZ2VMYWJlbFJlbmRlcmVyPlxuICogICAgICAgICA8ZGl2XG4gKiAgICAgICAgICAgc3R5bGU9e3tcbiAqICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICogICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKC01MCUsIC01MCUpIHRyYW5zbGF0ZSgke2xhYmVsWH1weCwke2xhYmVsWX1weClgLFxuICogICAgICAgICAgICAgYmFja2dyb3VuZDogJyNmZmNjMDAnLFxuICogICAgICAgICAgICAgcGFkZGluZzogMTAsXG4gKiAgICAgICAgIH19XG4gKiAgICAgICAgICAgY2xhc3NOYW1lPVwibm9kcmFnIG5vcGFuXCJcbiAqICAgICAgICAgPlxuICogICAgICAgICAge2RhdGEubGFiZWx9XG4gKiAgICAgICAgIDwvZGl2PlxuICogICAgICAgPC9FZGdlTGFiZWxSZW5kZXJlcj5cbiAqICAgICA8Lz5cbiAqICAgKTtcbiAqIH07XG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrcyBUaGUgYDxFZGdlTGFiZWxSZW5kZXJlciAvPmAgaGFzIG5vIHBvaW50ZXIgZXZlbnRzIGJ5IGRlZmF1bHQuIElmIHlvdSB3YW50IHRvXG4gKiBhZGQgbW91c2UgaW50ZXJhY3Rpb25zIHlvdSBuZWVkIHRvIHNldCB0aGUgc3R5bGUgYHBvaW50ZXJFdmVudHM6IGFsbGAgYW5kIGFkZFxuICogdGhlIGBub3BhbmAgY2xhc3Mgb24gdGhlIGxhYmVsIG9yIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIGludGVyYWN0IHdpdGguXG4gKi9cbmZ1bmN0aW9uIEVkZ2VMYWJlbFJlbmRlcmVyKHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IGVkZ2VMYWJlbFJlbmRlcmVyID0gdXNlU3RvcmUoc2VsZWN0b3IkNik7XG4gICAgaWYgKCFlZGdlTGFiZWxSZW5kZXJlcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgZWRnZUxhYmVsUmVuZGVyZXIpO1xufVxuXG5jb25zdCBzZWxlY3RvciQ1ID0gKHMpID0+IHMuZG9tTm9kZT8ucXVlcnlTZWxlY3RvcignLnJlYWN0LWZsb3dfX3ZpZXdwb3J0LXBvcnRhbCcpO1xuLyoqXG4gKiBUaGUgYDxWaWV3cG9ydFBvcnRhbCAvPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGFkZCBjb21wb25lbnRzIHRvIHRoZSBzYW1lIHZpZXdwb3J0XG4gKiBvZiB0aGUgZmxvdyB3aGVyZSBub2RlcyBhbmQgZWRnZXMgYXJlIHJlbmRlcmVkLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIHJlbmRlclxuICogeW91ciBvd24gY29tcG9uZW50cyB0aGF0IGFyZSBhZGhlcmUgdG8gdGhlIHNhbWUgY29vcmRpbmF0ZSBzeXN0ZW0gYXMgdGhlIG5vZGVzICYgZWRnZXNcbiAqIGFuZCBhcmUgYWxzbyBhZmZlY3RlZCBieSB6b29taW5nIGFuZCBwYW5uaW5nXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzeFxuICppbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBWaWV3cG9ydFBvcnRhbCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIHJldHVybiAoXG4gKiAgICA8Vmlld3BvcnRQb3J0YWw+XG4gKiAgICAgIDxkaXZcbiAqICAgICAgICBzdHlsZT17eyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMTAwcHgsIDEwMHB4KScsIHBvc2l0aW9uOiAnYWJzb2x1dGUnIH19XG4gKiAgICAgID5cbiAqICAgICAgICBUaGlzIGRpdiBpcyBwb3NpdGlvbmVkIGF0IFsxMDAsIDEwMF0gb24gdGhlIGZsb3cuXG4gKiAgICAgIDwvZGl2PlxuICogICAgPC9WaWV3cG9ydFBvcnRhbD5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiBWaWV3cG9ydFBvcnRhbCh7IGNoaWxkcmVuIH0pIHtcbiAgICBjb25zdCB2aWV3UG9ydGFsRGl2ID0gdXNlU3RvcmUoc2VsZWN0b3IkNSk7XG4gICAgaWYgKCF2aWV3UG9ydGFsRGl2KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCB2aWV3UG9ydGFsRGl2KTtcbn1cblxuLyoqXG4gKiBXaGVuIHlvdSBwcm9ncmFtbWF0aWNhbGx5IGFkZCBvciByZW1vdmUgaGFuZGxlcyB0byBhIG5vZGUgb3IgdXBkYXRlIGEgbm9kZSdzXG4gKiBoYW5kbGUgcG9zaXRpb24sIHlvdSBuZWVkIHRvIGxldCBSZWFjdCBGbG93IGtub3cgYWJvdXQgaXQgdXNpbmcgdGhpcyBob29rLiBUaGlzXG4gKiB3aWxsIHVwZGF0ZSB0aGUgaW50ZXJuYWwgZGltZW5zaW9ucyBvZiB0aGUgbm9kZSBhbmQgcHJvcGVybHkgcmVwb3NpdGlvbiBoYW5kbGVzXG4gKiBvbiB0aGUgY2FudmFzIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBVc2UgdGhpcyBmdW5jdGlvbiB0byB0ZWxsIFJlYWN0IEZsb3cgdG8gdXBkYXRlIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBvbmUgb3IgbW9yZSBub2Rlc1xuICogdGhhdCB5b3UgaGF2ZSBjaGFuZ2VkIHByb2dyYW1tYXRpY2FsbHkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IEhhbmRsZSwgdXNlVXBkYXRlTm9kZUludGVybmFscyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUmFuZG9tSGFuZGxlTm9kZSh7IGlkIH0pIHtcbiAqICBjb25zdCB1cGRhdGVOb2RlSW50ZXJuYWxzID0gdXNlVXBkYXRlTm9kZUludGVybmFscygpO1xuICogIGNvbnN0IFtoYW5kbGVDb3VudCwgc2V0SGFuZGxlQ291bnRdID0gdXNlU3RhdGUoMCk7XG4gKiAgY29uc3QgcmFuZG9taXplSGFuZGxlQ291bnQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gKiAgIHNldEhhbmRsZUNvdW50KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKSk7XG4gKiAgICB1cGRhdGVOb2RlSW50ZXJuYWxzKGlkKTtcbiAqICB9LCBbaWQsIHVwZGF0ZU5vZGVJbnRlcm5hbHNdKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDw+XG4gKiAgICAgIHtBcnJheS5mcm9tKHsgbGVuZ3RoOiBoYW5kbGVDb3VudCB9KS5tYXAoKF8sIGluZGV4KSA9PiAoXG4gKiAgICAgICAgPEhhbmRsZVxuICogICAgICAgICAga2V5PXtpbmRleH1cbiAqICAgICAgICAgIHR5cGU9XCJ0YXJnZXRcIlxuICogICAgICAgICAgcG9zaXRpb249XCJsZWZ0XCJcbiAqICAgICAgICAgIGlkPXtgaGFuZGxlLSR7aW5kZXh9YH1cbiAqICAgICAgICAvPlxuICogICAgICApKX1cbiAqXG4gKiAgICAgIDxkaXY+XG4gKiAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtyYW5kb21pemVIYW5kbGVDb3VudH0+UmFuZG9taXplIGhhbmRsZSBjb3VudDwvYnV0dG9uPlxuICogICAgICAgIDxwPlRoZXJlIGFyZSB7aGFuZGxlQ291bnR9IGhhbmRsZXMgb24gdGhpcyBub2RlLjwvcD5cbiAqICAgICAgPC9kaXY+XG4gKiAgICA8Lz5cbiAqICApO1xuICp9XG4gKmBgYFxuICogQHJlbWFya3MgVGhpcyBob29rIGNhbiBvbmx5IGJlIHVzZWQgaW4gYSBjb21wb25lbnQgdGhhdCBpcyBhIGNoaWxkIG9mIGFcbiAqe0BsaW5rIFJlYWN0Rmxvd1Byb3ZpZGVyfSBvciBhIHtAbGluayBSZWFjdEZsb3d9IGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gdXNlVXBkYXRlTm9kZUludGVybmFscygpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKChpZCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRvbU5vZGUsIHVwZGF0ZU5vZGVJbnRlcm5hbHMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUlkcyA9IEFycmF5LmlzQXJyYXkoaWQpID8gaWQgOiBbaWRdO1xuICAgICAgICBjb25zdCB1cGRhdGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB1cGRhdGVJZHMuZm9yRWFjaCgodXBkYXRlSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVFbGVtZW50ID0gZG9tTm9kZT8ucXVlcnlTZWxlY3RvcihgLnJlYWN0LWZsb3dfX25vZGVbZGF0YS1pZD1cIiR7dXBkYXRlSWR9XCJdYCk7XG4gICAgICAgICAgICBpZiAobm9kZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVzLnNldCh1cGRhdGVJZCwgeyBpZDogdXBkYXRlSWQsIG5vZGVFbGVtZW50LCBmb3JjZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB1cGRhdGVOb2RlSW50ZXJuYWxzKHVwZGF0ZXMsIHsgdHJpZ2dlckZpdFZpZXc6IGZhbHNlIH0pKTtcbiAgICB9LCBbXSk7XG59XG5cbmNvbnN0IG5vZGVzU2VsZWN0b3IgPSAoc3RhdGUpID0+IHN0YXRlLm5vZGVzO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgY3VycmVudCBub2Rlcy4gQ29tcG9uZW50cyB0aGF0IHVzZSB0aGlzIGhvb2tcbiAqIHdpbGwgcmUtcmVuZGVyICoqd2hlbmV2ZXIgYW55IG5vZGUgY2hhbmdlcyoqLCBpbmNsdWRpbmcgd2hlbiBhIG5vZGUgaXMgc2VsZWN0ZWRcbiAqIG9yIG1vdmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFsbCBub2RlcyBjdXJyZW50bHkgaW4gdGhlIGZsb3cuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VOb2RlcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gKiAgY29uc3Qgbm9kZXMgPSB1c2VOb2RlcygpO1xuICpcbiAqICByZXR1cm4gPGRpdj5UaGVyZSBhcmUgY3VycmVudGx5IHtub2Rlcy5sZW5ndGh9IG5vZGVzITwvZGl2PjtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZXMoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB1c2VTdG9yZShub2Rlc1NlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gbm9kZXM7XG59XG5cbmNvbnN0IGVkZ2VzU2VsZWN0b3IgPSAoc3RhdGUpID0+IHN0YXRlLmVkZ2VzO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgY3VycmVudCBlZGdlcy4gQ29tcG9uZW50cyB0aGF0IHVzZSB0aGlzIGhvb2tcbiAqIHdpbGwgcmUtcmVuZGVyICoqd2hlbmV2ZXIgYW55IGVkZ2UgY2hhbmdlcyoqLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFsbCBlZGdlcyBjdXJyZW50bHkgaW4gdGhlIGZsb3cuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyB1c2VFZGdlcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IGVkZ2VzID0gdXNlRWRnZXMoKTtcbiAqXG4gKiAgcmV0dXJuIDxkaXY+VGhlcmUgYXJlIGN1cnJlbnRseSB7ZWRnZXMubGVuZ3RofSBlZGdlcyE8L2Rpdj47XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZUVkZ2VzKCkge1xuICAgIGNvbnN0IGVkZ2VzID0gdXNlU3RvcmUoZWRnZXNTZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIGVkZ2VzO1xufVxuXG5jb25zdCB2aWV3cG9ydFNlbGVjdG9yID0gKHN0YXRlKSA9PiAoe1xuICAgIHg6IHN0YXRlLnRyYW5zZm9ybVswXSxcbiAgICB5OiBzdGF0ZS50cmFuc2Zvcm1bMV0sXG4gICAgem9vbTogc3RhdGUudHJhbnNmb3JtWzJdLFxufSk7XG4vKipcbiAqIFRoZSBgdXNlVmlld3BvcnRgIGhvb2sgaXMgYSBjb252ZW5pZW50IHdheSB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZVxuICoge0BsaW5rIFZpZXdwb3J0fSBpbiBhIGNvbXBvbmVudC4gQ29tcG9uZW50cyB0aGF0IHVzZSB0aGlzIGhvb2tcbiAqIHdpbGwgcmUtcmVuZGVyICoqd2hlbmV2ZXIgdGhlIHZpZXdwb3J0IGNoYW5nZXMqKi5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBUaGUgY3VycmVudCB2aWV3cG9ydC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqYGBganN4XG4gKmltcG9ydCB7IHVzZVZpZXdwb3J0IH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBWaWV3cG9ydERpc3BsYXkoKSB7XG4gKiAgY29uc3QgeyB4LCB5LCB6b29tIH0gPSB1c2VWaWV3cG9ydCgpO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICAgPHA+XG4gKiAgICAgICAgVGhlIHZpZXdwb3J0IGlzIGN1cnJlbnRseSBhdCAoe3h9LCB7eX0pIGFuZCB6b29tZWQgdG8ge3pvb219LlxuICogICAgICA8L3A+XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFRoaXMgaG9vayBjYW4gb25seSBiZSB1c2VkIGluIGEgY29tcG9uZW50IHRoYXQgaXMgYSBjaGlsZCBvZiBhXG4gKntAbGluayBSZWFjdEZsb3dQcm92aWRlcn0gb3IgYSB7QGxpbmsgUmVhY3RGbG93fSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIHVzZVZpZXdwb3J0KCkge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gdXNlU3RvcmUodmlld3BvcnRTZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0O1xufVxuXG4vKipcbiAqIFRoaXMgaG9vayBtYWtlcyBpdCBlYXN5IHRvIHByb3RvdHlwZSBhIGNvbnRyb2xsZWQgZmxvdyB3aGVyZSB5b3UgbWFuYWdlIHRoZVxuICogc3RhdGUgb2Ygbm9kZXMgYW5kIGVkZ2VzIG91dHNpZGUgdGhlIGBSZWFjdEZsb3dJbnN0YW5jZWAuIFlvdSBjYW4gdGhpbmsgb2YgaXRcbiAqIGxpa2UgUmVhY3QncyBgdXNlU3RhdGVgIGhvb2sgd2l0aCBhbiBhZGRpdGlvbmFsIGhlbHBlciBjYWxsYmFjay5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuc1xuICogLSBgbm9kZXNgOiBUaGUgY3VycmVudCBhcnJheSBvZiBub2Rlcy4gWW91IG1pZ2h0IHBhc3MgdGhpcyBkaXJlY3RseSB0byB0aGUgYG5vZGVzYCBwcm9wIG9mIHlvdXJcbiAqIGA8UmVhY3RGbG93IC8+YCBjb21wb25lbnQsIG9yIHlvdSBtYXkgd2FudCB0byBtYW5pcHVsYXRlIGl0IGZpcnN0IHRvIHBlcmZvcm0gc29tZSBsYXlvdXRpbmcsXG4gKiBmb3IgZXhhbXBsZS5cbiAqIC0gYHNldE5vZGVzYDogQSBmdW5jdGlvbiB0aGF0IHlvdSBjYW4gdXNlIHRvIHVwZGF0ZSB0aGUgbm9kZXMuIFlvdSBjYW4gcGFzcyBpdCBhIG5ldyBhcnJheSBvZlxuICogbm9kZXMgb3IgYSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBjdXJyZW50IGFycmF5IG9mIG5vZGVzIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIG5vZGVzLlxuICogVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgc2Vjb25kIGVsZW1lbnQgb2YgdGhlIHR1cGxlIHJldHVybmVkIGJ5IFJlYWN0J3MgYHVzZVN0YXRlYCBob29rLlxuICogLSBgb25Ob2Rlc0NoYW5nZWA6IEEgaGFuZHkgY2FsbGJhY2sgdGhhdCBjYW4gdGFrZSBhbiBhcnJheSBvZiBgTm9kZUNoYW5nZXNgIGFuZCB1cGRhdGUgdGhlIG5vZGVzXG4gKiBzdGF0ZSBhY2NvcmRpbmdseS4gWW91J2xsIHR5cGljYWxseSBwYXNzIHRoaXMgZGlyZWN0bHkgdG8gdGhlIGBvbk5vZGVzQ2hhbmdlYCBwcm9wIG9mIHlvdXJcbiAqIGA8UmVhY3RGbG93IC8+YCBjb21wb25lbnQuXG4gKiBAZXhhbXBsZVxuICpcbiAqYGBgdHN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgdXNlTm9kZXNTdGF0ZSwgdXNlRWRnZXNTdGF0ZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqY29uc3QgaW5pdGlhbE5vZGVzID0gW107XG4gKmNvbnN0IGluaXRpYWxFZGdlcyA9IFtdO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXMsIG9uTm9kZXNDaGFuZ2VdID0gdXNlTm9kZXNTdGF0ZShpbml0aWFsTm9kZXMpO1xuICogIGNvbnN0IFtlZGdlcywgc2V0RWRnZXMsIG9uRWRnZXNDaGFuZ2VdID0gdXNlRWRnZXNTdGF0ZShpbml0aWFsRWRnZXMpO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0Rmxvd1xuICogICAgICBub2Rlcz17bm9kZXN9XG4gKiAgICAgIGVkZ2VzPXtlZGdlc31cbiAqICAgICAgb25Ob2Rlc0NoYW5nZT17b25Ob2Rlc0NoYW5nZX1cbiAqICAgICAgb25FZGdlc0NoYW5nZT17b25FZGdlc0NoYW5nZX1cbiAqICAgIC8+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGhvb2sgd2FzIGNyZWF0ZWQgdG8gbWFrZSBwcm90b3R5cGluZyBlYXNpZXIgYW5kIG91ciBkb2N1bWVudGF0aW9uXG4gKiBleGFtcGxlcyBjbGVhcmVyLiBBbHRob3VnaCBpdCBpcyBPSyB0byB1c2UgdGhpcyBob29rIGluIHByb2R1Y3Rpb24sIGluXG4gKiBwcmFjdGljZSB5b3UgbWF5IHdhbnQgdG8gdXNlIGEgbW9yZSBzb3BoaXN0aWNhdGVkIHN0YXRlIG1hbmFnZW1lbnQgc29sdXRpb25cbiAqIGxpa2UgWnVzdGFuZCB7QGxpbmsgaHR0cHM6Ly9yZWFjdGZsb3cuZGV2L2RvY3MvZ3VpZGVzL3N0YXRlLW1hbmFnZW1lbnQvfSBpbnN0ZWFkLlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZXNTdGF0ZShpbml0aWFsTm9kZXMpIHtcbiAgICBjb25zdCBbbm9kZXMsIHNldE5vZGVzXSA9IHVzZVN0YXRlKGluaXRpYWxOb2Rlcyk7XG4gICAgY29uc3Qgb25Ob2Rlc0NoYW5nZSA9IHVzZUNhbGxiYWNrKChjaGFuZ2VzKSA9PiBzZXROb2RlcygobmRzKSA9PiBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIG5kcykpLCBbXSk7XG4gICAgcmV0dXJuIFtub2Rlcywgc2V0Tm9kZXMsIG9uTm9kZXNDaGFuZ2VdO1xufVxuLyoqXG4gKiBUaGlzIGhvb2sgbWFrZXMgaXQgZWFzeSB0byBwcm90b3R5cGUgYSBjb250cm9sbGVkIGZsb3cgd2hlcmUgeW91IG1hbmFnZSB0aGVcbiAqIHN0YXRlIG9mIG5vZGVzIGFuZCBlZGdlcyBvdXRzaWRlIHRoZSBgUmVhY3RGbG93SW5zdGFuY2VgLiBZb3UgY2FuIHRoaW5rIG9mIGl0XG4gKiBsaWtlIFJlYWN0J3MgYHVzZVN0YXRlYCBob29rIHdpdGggYW4gYWRkaXRpb25hbCBoZWxwZXIgY2FsbGJhY2suXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnNcbiAqIC0gYGVkZ2VzYDogVGhlIGN1cnJlbnQgYXJyYXkgb2YgZWRnZXMuIFlvdSBtaWdodCBwYXNzIHRoaXMgZGlyZWN0bHkgdG8gdGhlIGBlZGdlc2AgcHJvcCBvZiB5b3VyXG4gKiBgPFJlYWN0RmxvdyAvPmAgY29tcG9uZW50LCBvciB5b3UgbWF5IHdhbnQgdG8gbWFuaXB1bGF0ZSBpdCBmaXJzdCB0byBwZXJmb3JtIHNvbWUgbGF5b3V0aW5nLFxuICogZm9yIGV4YW1wbGUuXG4gKlxuICogLSBgc2V0RWRnZXNgOiBBIGZ1bmN0aW9uIHRoYXQgeW91IGNhbiB1c2UgdG8gdXBkYXRlIHRoZSBlZGdlcy4gWW91IGNhbiBwYXNzIGl0IGEgbmV3IGFycmF5IG9mXG4gKiBlZGdlcyBvciBhIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGN1cnJlbnQgYXJyYXkgb2YgZWRnZXMgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWRnZXMuXG4gKiBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBzZWNvbmQgZWxlbWVudCBvZiB0aGUgdHVwbGUgcmV0dXJuZWQgYnkgUmVhY3QncyBgdXNlU3RhdGVgIGhvb2suXG4gKlxuICogLSBgb25FZGdlc0NoYW5nZWA6IEEgaGFuZHkgY2FsbGJhY2sgdGhhdCBjYW4gdGFrZSBhbiBhcnJheSBvZiBgRWRnZUNoYW5nZXNgIGFuZCB1cGRhdGUgdGhlIGVkZ2VzXG4gKiBzdGF0ZSBhY2NvcmRpbmdseS4gWW91J2xsIHR5cGljYWxseSBwYXNzIHRoaXMgZGlyZWN0bHkgdG8gdGhlIGBvbkVkZ2VzQ2hhbmdlYCBwcm9wIG9mIHlvdXJcbiAqIGA8UmVhY3RGbG93IC8+YCBjb21wb25lbnQuXG4gKiBAZXhhbXBsZVxuICpcbiAqYGBgdHN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgdXNlTm9kZXNTdGF0ZSwgdXNlRWRnZXNTdGF0ZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqY29uc3QgaW5pdGlhbE5vZGVzID0gW107XG4gKmNvbnN0IGluaXRpYWxFZGdlcyA9IFtdO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXMsIG9uTm9kZXNDaGFuZ2VdID0gdXNlTm9kZXNTdGF0ZShpbml0aWFsTm9kZXMpO1xuICogIGNvbnN0IFtlZGdlcywgc2V0RWRnZXMsIG9uRWRnZXNDaGFuZ2VdID0gdXNlRWRnZXNTdGF0ZShpbml0aWFsRWRnZXMpO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0Rmxvd1xuICogICAgICBub2Rlcz17bm9kZXN9XG4gKiAgICAgIGVkZ2VzPXtlZGdlc31cbiAqICAgICAgb25Ob2Rlc0NoYW5nZT17b25Ob2Rlc0NoYW5nZX1cbiAqICAgICAgb25FZGdlc0NoYW5nZT17b25FZGdlc0NoYW5nZX1cbiAqICAgIC8+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGhvb2sgd2FzIGNyZWF0ZWQgdG8gbWFrZSBwcm90b3R5cGluZyBlYXNpZXIgYW5kIG91ciBkb2N1bWVudGF0aW9uXG4gKiBleGFtcGxlcyBjbGVhcmVyLiBBbHRob3VnaCBpdCBpcyBPSyB0byB1c2UgdGhpcyBob29rIGluIHByb2R1Y3Rpb24sIGluXG4gKiBwcmFjdGljZSB5b3UgbWF5IHdhbnQgdG8gdXNlIGEgbW9yZSBzb3BoaXN0aWNhdGVkIHN0YXRlIG1hbmFnZW1lbnQgc29sdXRpb25cbiAqIGxpa2UgWnVzdGFuZCB7QGxpbmsgaHR0cHM6Ly9yZWFjdGZsb3cuZGV2L2RvY3MvZ3VpZGVzL3N0YXRlLW1hbmFnZW1lbnQvfSBpbnN0ZWFkLlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlRWRnZXNTdGF0ZShpbml0aWFsRWRnZXMpIHtcbiAgICBjb25zdCBbZWRnZXMsIHNldEVkZ2VzXSA9IHVzZVN0YXRlKGluaXRpYWxFZGdlcyk7XG4gICAgY29uc3Qgb25FZGdlc0NoYW5nZSA9IHVzZUNhbGxiYWNrKChjaGFuZ2VzKSA9PiBzZXRFZGdlcygoZWRzKSA9PiBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIGVkcykpLCBbXSk7XG4gICAgcmV0dXJuIFtlZGdlcywgc2V0RWRnZXMsIG9uRWRnZXNDaGFuZ2VdO1xufVxuXG4vKipcbiAqIFRoZSBgdXNlT25WaWV3cG9ydENoYW5nZWAgaG9vayBsZXRzIHlvdSBsaXN0ZW4gZm9yIGNoYW5nZXMgdG8gdGhlIHZpZXdwb3J0IHN1Y2hcbiAqIGFzIHBhbm5pbmcgYW5kIHpvb21pbmcuIFlvdSBjYW4gcHJvdmlkZSBhIGNhbGxiYWNrIGZvciBlYWNoIHBoYXNlIG9mIGEgdmlld3BvcnRcbiAqIGNoYW5nZTogYG9uU3RhcnRgLCBgb25DaGFuZ2VgLCBhbmQgYG9uRW5kYC5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyB1c2VPblZpZXdwb3J0Q2hhbmdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpmdW5jdGlvbiBWaWV3cG9ydENoYW5nZUxvZ2dlcigpIHtcbiAqICB1c2VPblZpZXdwb3J0Q2hhbmdlKHtcbiAqICAgIG9uU3RhcnQ6ICh2aWV3cG9ydDogVmlld3BvcnQpID0+IGNvbnNvbGUubG9nKCdzdGFydCcsIHZpZXdwb3J0KSxcbiAqICAgIG9uQ2hhbmdlOiAodmlld3BvcnQ6IFZpZXdwb3J0KSA9PiBjb25zb2xlLmxvZygnY2hhbmdlJywgdmlld3BvcnQpLFxuICogICAgb25FbmQ6ICh2aWV3cG9ydDogVmlld3BvcnQpID0+IGNvbnNvbGUubG9nKCdlbmQnLCB2aWV3cG9ydCksXG4gKiAgfSk7XG4gKlxuICogIHJldHVybiBudWxsO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VPblZpZXdwb3J0Q2hhbmdlKHsgb25TdGFydCwgb25DaGFuZ2UsIG9uRW5kIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblZpZXdwb3J0Q2hhbmdlU3RhcnQ6IG9uU3RhcnQgfSk7XG4gICAgfSwgW29uU3RhcnRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uVmlld3BvcnRDaGFuZ2U6IG9uQ2hhbmdlIH0pO1xuICAgIH0sIFtvbkNoYW5nZV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25WaWV3cG9ydENoYW5nZUVuZDogb25FbmQgfSk7XG4gICAgfSwgW29uRW5kXSk7XG59XG5cbi8qKlxuICogVGhpcyBob29rIGxldHMgeW91IGxpc3RlbiBmb3IgY2hhbmdlcyB0byBib3RoIG5vZGUgYW5kIGVkZ2Ugc2VsZWN0aW9uLiBBcyB0aGVcbiAqbmFtZSBpbXBsaWVzLCB0aGUgY2FsbGJhY2sgeW91IHByb3ZpZGUgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHNlbGVjdGlvbiBvZlxuICpfZWl0aGVyXyBub2RlcyBvciBlZGdlcyBjaGFuZ2VzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgdXNlT25TZWxlY3Rpb25DaGFuZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIFNlbGVjdGlvbkRpc3BsYXkoKSB7XG4gKiAgY29uc3QgW3NlbGVjdGVkTm9kZXMsIHNldFNlbGVjdGVkTm9kZXNdID0gdXNlU3RhdGUoW10pO1xuICogIGNvbnN0IFtzZWxlY3RlZEVkZ2VzLCBzZXRTZWxlY3RlZEVkZ2VzXSA9IHVzZVN0YXRlKFtdKTtcbiAqXG4gKiAgLy8gdGhlIHBhc3NlZCBoYW5kbGVyIGhhcyB0byBiZSBtZW1vaXplZCwgb3RoZXJ3aXNlIHRoZSBob29rIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5XG4gKiAgY29uc3Qgb25DaGFuZ2UgPSB1c2VDYWxsYmFjaygoeyBub2RlcywgZWRnZXMgfSkgPT4ge1xuICogICAgc2V0U2VsZWN0ZWROb2Rlcyhub2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuaWQpKTtcbiAqICAgIHNldFNlbGVjdGVkRWRnZXMoZWRnZXMubWFwKChlZGdlKSA9PiBlZGdlLmlkKSk7XG4gKiAgfSwgW10pO1xuICpcbiAqICB1c2VPblNlbGVjdGlvbkNoYW5nZSh7XG4gKiAgICBvbkNoYW5nZSxcbiAqICB9KTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAgIDxwPlNlbGVjdGVkIG5vZGVzOiB7c2VsZWN0ZWROb2Rlcy5qb2luKCcsICcpfTwvcD5cbiAqICAgICAgPHA+U2VsZWN0ZWQgZWRnZXM6IHtzZWxlY3RlZEVkZ2VzLmpvaW4oJywgJyl9PC9wPlxuICogICAgPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBZb3UgbmVlZCB0byBtZW1vaXplIHRoZSBwYXNzZWQgYG9uQ2hhbmdlYCBoYW5kbGVyLCBvdGhlcndpc2UgdGhlIGhvb2sgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkuXG4gKi9cbmZ1bmN0aW9uIHVzZU9uU2VsZWN0aW9uQ2hhbmdlKHsgb25DaGFuZ2UsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dE9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMgPSBbLi4uc3RvcmUuZ2V0U3RhdGUoKS5vblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzLCBvbkNoYW5nZV07XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVyczogbmV4dE9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXh0SGFuZGxlcnMgPSBzdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMuZmlsdGVyKChmbikgPT4gZm4gIT09IG9uQ2hhbmdlKTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVyczogbmV4dEhhbmRsZXJzIH0pO1xuICAgICAgICB9O1xuICAgIH0sIFtvbkNoYW5nZV0pO1xufVxuXG5jb25zdCBzZWxlY3RvciQ0ID0gKG9wdGlvbnMpID0+IChzKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGVIaWRkZW5Ob2Rlcykge1xuICAgICAgICByZXR1cm4gcy5ub2Rlc0luaXRpYWxpemVkO1xuICAgIH1cbiAgICBpZiAocy5ub2RlTG9va3VwLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFssIHsgaW50ZXJuYWxzIH1dIG9mIHMubm9kZUxvb2t1cCkge1xuICAgICAgICBpZiAoaW50ZXJuYWxzLmhhbmRsZUJvdW5kcyA9PT0gdW5kZWZpbmVkIHx8ICFub2RlSGFzRGltZW5zaW9ucyhpbnRlcm5hbHMudXNlck5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBUaGlzIGhvb2sgdGVsbHMgeW91IHdoZXRoZXIgYWxsIHRoZSBub2RlcyBpbiBhIGZsb3cgaGF2ZSBiZWVuIG1lYXN1cmVkIGFuZCBnaXZlblxuICphIHdpZHRoIGFuZCBoZWlnaHQuIFdoZW4geW91IGFkZCBhIG5vZGUgdG8gdGhlIGZsb3csIHRoaXMgaG9vayB3aWxsIHJldHVyblxuICpgZmFsc2VgIGFuZCB0aGVuIGB0cnVlYCBhZ2FpbiBvbmNlIHRoZSBub2RlIGhhcyBiZWVuIG1lYXN1cmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIFdoZXRoZXIgb3Igbm90IHRoZSBub2RlcyBoYXZlIGJlZW4gaW5pdGlhbGl6ZWQgYnkgdGhlIGA8UmVhY3RGbG93IC8+YCBjb21wb25lbnQgYW5kXG4gKiBnaXZlbiBhIHdpZHRoIGFuZCBoZWlnaHQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VSZWFjdEZsb3csIHVzZU5vZGVzSW5pdGlhbGl6ZWQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqXG4gKmNvbnN0IG9wdGlvbnMgPSB7XG4gKiAgaW5jbHVkZUhpZGRlbk5vZGVzOiBmYWxzZSxcbiAqfTtcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZUxheW91dCgpIHtcbiAqICBjb25zdCB7IGdldE5vZGVzIH0gPSB1c2VSZWFjdEZsb3coKTtcbiAqICBjb25zdCBub2Rlc0luaXRpYWxpemVkID0gdXNlTm9kZXNJbml0aWFsaXplZChvcHRpb25zKTtcbiAqICBjb25zdCBbbGF5b3V0ZWROb2Rlcywgc2V0TGF5b3V0ZWROb2Rlc10gPSB1c2VTdGF0ZShnZXROb2RlcygpKTtcbiAqXG4gKiAgdXNlRWZmZWN0KCgpID0+IHtcbiAqICAgIGlmIChub2Rlc0luaXRpYWxpemVkKSB7XG4gKiAgICAgIHNldExheW91dGVkTm9kZXMoeW91ckxheW91dGluZ0Z1bmN0aW9uKGdldE5vZGVzKCkpKTtcbiAqICAgIH1cbiAqICB9LCBbbm9kZXNJbml0aWFsaXplZF0pO1xuICpcbiAqICByZXR1cm4gbGF5b3V0ZWROb2RlcztcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZXNJbml0aWFsaXplZChvcHRpb25zID0ge1xuICAgIGluY2x1ZGVIaWRkZW5Ob2RlczogZmFsc2UsXG59KSB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZWQgPSB1c2VTdG9yZShzZWxlY3RvciQ0KG9wdGlvbnMpKTtcbiAgICByZXR1cm4gaW5pdGlhbGl6ZWQ7XG59XG5cbi8qKlxuICogSG9vayB0byBjaGVjayBpZiBhIDxIYW5kbGUgLz4gaXMgY29ubmVjdGVkIHRvIGFub3RoZXIgPEhhbmRsZSAvPiBhbmQgZ2V0IHRoZSBjb25uZWN0aW9ucy5cbiAqXG4gKiBAcHVibGljXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHVzZU5vZGVDb25uZWN0aW9uc2AgaW5zdGVhZC5cbiAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggaGFuZGxlIGNvbm5lY3Rpb25zLlxuICovXG5mdW5jdGlvbiB1c2VIYW5kbGVDb25uZWN0aW9ucyh7IHR5cGUsIGlkLCBub2RlSWQsIG9uQ29ubmVjdCwgb25EaXNjb25uZWN0LCB9KSB7XG4gICAgY29uc29sZS53YXJuKCdbREVQUkVDQVRFRF0gYHVzZUhhbmRsZUNvbm5lY3Rpb25zYCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHVzZSBgdXNlTm9kZUNvbm5lY3Rpb25zYCBodHRwczovL3JlYWN0Zmxvdy5kZXYvYXBpLXJlZmVyZW5jZS9ob29rcy91c2VOb2RlQ29ubmVjdGlvbnMnKTtcbiAgICBjb25zdCBfbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJZCA9IG5vZGVJZCA/PyBfbm9kZUlkO1xuICAgIGNvbnN0IHByZXZDb25uZWN0aW9ucyA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IHVzZVN0b3JlKChzdGF0ZSkgPT4gc3RhdGUuY29ubmVjdGlvbkxvb2t1cC5nZXQoYCR7Y3VycmVudE5vZGVJZH0tJHt0eXBlfSR7aWQgPyBgLSR7aWR9YCA6ICcnfWApLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBAdG9kbyBkaWN1c3MgaWYgb25Db25uZWN0L29uRGlzY29ubmVjdCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBtb3VudHMvdW5tb3VudHNcbiAgICAgICAgaWYgKHByZXZDb25uZWN0aW9ucy5jdXJyZW50ICYmIHByZXZDb25uZWN0aW9ucy5jdXJyZW50ICE9PSBjb25uZWN0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgX2Nvbm5lY3Rpb25zID0gY29ubmVjdGlvbnMgPz8gbmV3IE1hcCgpO1xuICAgICAgICAgICAgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZShwcmV2Q29ubmVjdGlvbnMuY3VycmVudCwgX2Nvbm5lY3Rpb25zLCBvbkRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZShfY29ubmVjdGlvbnMsIHByZXZDb25uZWN0aW9ucy5jdXJyZW50LCBvbkNvbm5lY3QpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZDb25uZWN0aW9ucy5jdXJyZW50ID0gY29ubmVjdGlvbnMgPz8gbmV3IE1hcCgpO1xuICAgIH0sIFtjb25uZWN0aW9ucywgb25Db25uZWN0LCBvbkRpc2Nvbm5lY3RdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiBBcnJheS5mcm9tKGNvbm5lY3Rpb25zPy52YWx1ZXMoKSA/PyBbXSksIFtjb25uZWN0aW9uc10pO1xufVxuXG5jb25zdCBlcnJvcjAxNCA9IGVycm9yTWVzc2FnZXNbJ2Vycm9yMDE0J10oKTtcbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgYW4gYXJyYXkgb2YgY29ubmVjdGlvbnMgb24gYSBzcGVjaWZpYyBub2RlLCBoYW5kbGUgdHlwZSAoJ3NvdXJjZScsICd0YXJnZXQnKSBvciBoYW5kbGUgSUQuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCBjb25uZWN0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZU5vZGVDb25uZWN0aW9ucyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IGNvbm5lY3Rpb25zID0gdXNlTm9kZUNvbm5lY3Rpb25zKHtcbiAqICAgIGhhbmRsZVR5cGU6ICd0YXJnZXQnLFxuICogICAgaGFuZGxlSWQ6ICdteS1oYW5kbGUnLFxuICogIH0pO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5UaGVyZSBhcmUgY3VycmVudGx5IHtjb25uZWN0aW9ucy5sZW5ndGh9IGluY29taW5nIGNvbm5lY3Rpb25zITwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVDb25uZWN0aW9ucyh7IGlkLCBoYW5kbGVUeXBlLCBoYW5kbGVJZCwgb25Db25uZWN0LCBvbkRpc2Nvbm5lY3QsIH0gPSB7fSkge1xuICAgIGNvbnN0IG5vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICAgIGNvbnN0IGN1cnJlbnROb2RlSWQgPSBpZCA/PyBub2RlSWQ7XG4gICAgaWYgKCFjdXJyZW50Tm9kZUlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcjAxNCk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZDb25uZWN0aW9ucyA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IHVzZVN0b3JlKChzdGF0ZSkgPT4gc3RhdGUuY29ubmVjdGlvbkxvb2t1cC5nZXQoYCR7Y3VycmVudE5vZGVJZH0ke2hhbmRsZVR5cGUgPyAoaGFuZGxlSWQgPyBgLSR7aGFuZGxlVHlwZX0tJHtoYW5kbGVJZH1gIDogYC0ke2hhbmRsZVR5cGV9YCkgOiAnJ31gKSwgYXJlQ29ubmVjdGlvbk1hcHNFcXVhbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gQHRvZG8gZGlzY3VzcyBpZiBvbkNvbm5lY3Qvb25EaXNjb25uZWN0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IG1vdW50cy91bm1vdW50c1xuICAgICAgICBpZiAocHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgJiYgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgIT09IGNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBfY29ubmVjdGlvbnMgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKHByZXZDb25uZWN0aW9ucy5jdXJyZW50LCBfY29ubmVjdGlvbnMsIG9uRGlzY29ubmVjdCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKF9jb25uZWN0aW9ucywgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQsIG9uQ29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgfSwgW2Nvbm5lY3Rpb25zLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdF0pO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IEFycmF5LmZyb20oY29ubmVjdGlvbnM/LnZhbHVlcygpID8/IFtdKSwgW2Nvbm5lY3Rpb25zXSk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB1c2VOb2Rlc0RhdGEobm9kZUlkcykge1xuICAgIGNvbnN0IG5vZGVzRGF0YSA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgY29uc3QgaXNBcnJheU9mSWRzID0gQXJyYXkuaXNBcnJheShub2RlSWRzKTtcbiAgICAgICAgY29uc3QgX25vZGVJZHMgPSBpc0FycmF5T2ZJZHMgPyBub2RlSWRzIDogW25vZGVJZHNdO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGVJZCBvZiBfbm9kZUlkcykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHMubm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbm9kZS5kYXRhLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5T2ZJZHMgPyBkYXRhIDogZGF0YVswXSA/PyBudWxsO1xuICAgIH0sIFtub2RlSWRzXSksIHNoYWxsb3dOb2RlRGF0YSk7XG4gICAgcmV0dXJuIG5vZGVzRGF0YTtcbn1cblxuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBzcGVjaWZpYyBub2RlLlxuICogQ29tcG9uZW50cyB0aGF0IHVzZSB0aGlzIGhvb2sgd2lsbCByZS1yZW5kZXIgKip3aGVuZXZlciB0aGUgbm9kZSBjaGFuZ2VzKiosXG4gKiBpbmNsdWRpbmcgd2hlbiBhIG5vZGUgaXMgc2VsZWN0ZWQgb3IgbW92ZWQuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIGEgbm9kZSB5b3Ugd2FudCB0byBvYnNlcnZlLlxuICogQHJldHVybnMgVGhlIGBJbnRlcm5hbE5vZGVgIG9iamVjdCBmb3IgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4gSUQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyB1c2VJbnRlcm5hbE5vZGUgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICBjb25zdCBpbnRlcm5hbE5vZGUgPSB1c2VJbnRlcm5hbE5vZGUoJ25vZGUtMScpO1xuICogIGNvbnN0IGFic29sdXRlUG9zaXRpb24gPSBpbnRlcm5hbE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGU7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgaXMgYXQ6XG4gKiAgICAgIDxwPng6IHthYnNvbHV0ZVBvc2l0aW9uLnh9PC9wPlxuICogICAgICA8cD55OiB7YWJzb2x1dGVQb3NpdGlvbi55fTwvcD5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZUludGVybmFsTm9kZShpZCkge1xuICAgIGNvbnN0IG5vZGUgPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygocykgPT4gcy5ub2RlTG9va3VwLmdldChpZCksIFtpZF0pLCBzaGFsbG93KTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gTGluZVBhdHRlcm4oeyBkaW1lbnNpb25zLCBsaW5lV2lkdGgsIHZhcmlhbnQsIGNsYXNzTmFtZSB9KSB7XG4gICAgcmV0dXJuIChqc3goXCJwYXRoXCIsIHsgc3Ryb2tlV2lkdGg6IGxpbmVXaWR0aCwgZDogYE0ke2RpbWVuc2lvbnNbMF0gLyAyfSAwIFYke2RpbWVuc2lvbnNbMV19IE0wICR7ZGltZW5zaW9uc1sxXSAvIDJ9IEgke2RpbWVuc2lvbnNbMF19YCwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2JhY2tncm91bmQtcGF0dGVybicsIHZhcmlhbnQsIGNsYXNzTmFtZV0pIH0pKTtcbn1cbmZ1bmN0aW9uIERvdFBhdHRlcm4oeyByYWRpdXMsIGNsYXNzTmFtZSB9KSB7XG4gICAgcmV0dXJuIChqc3goXCJjaXJjbGVcIiwgeyBjeDogcmFkaXVzLCBjeTogcmFkaXVzLCByOiByYWRpdXMsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19iYWNrZ3JvdW5kLXBhdHRlcm4nLCAnZG90cycsIGNsYXNzTmFtZV0pIH0pKTtcbn1cblxuLyoqXG4gKiBUaGUgdGhyZWUgdmFyaWFudHMgYXJlIGV4cG9ydGVkIGFzIGFuIGVudW0gZm9yIGNvbnZlbmllbmNlLiBZb3UgY2FuIGVpdGhlciBpbXBvcnRcbiAqIHRoZSBlbnVtIGFuZCB1c2UgaXQgbGlrZSBgQmFja2dyb3VuZFZhcmlhbnQuTGluZXNgIG9yIHlvdSBjYW4gdXNlIHRoZSByYXcgc3RyaW5nXG4gKiB2YWx1ZSBkaXJlY3RseS5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIEJhY2tncm91bmRWYXJpYW50O1xuKGZ1bmN0aW9uIChCYWNrZ3JvdW5kVmFyaWFudCkge1xuICAgIEJhY2tncm91bmRWYXJpYW50W1wiTGluZXNcIl0gPSBcImxpbmVzXCI7XG4gICAgQmFja2dyb3VuZFZhcmlhbnRbXCJEb3RzXCJdID0gXCJkb3RzXCI7XG4gICAgQmFja2dyb3VuZFZhcmlhbnRbXCJDcm9zc1wiXSA9IFwiY3Jvc3NcIjtcbn0pKEJhY2tncm91bmRWYXJpYW50IHx8IChCYWNrZ3JvdW5kVmFyaWFudCA9IHt9KSk7XG5cbmNvbnN0IGRlZmF1bHRTaXplID0ge1xuICAgIFtCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzXTogMSxcbiAgICBbQmFja2dyb3VuZFZhcmlhbnQuTGluZXNdOiAxLFxuICAgIFtCYWNrZ3JvdW5kVmFyaWFudC5Dcm9zc106IDYsXG59O1xuY29uc3Qgc2VsZWN0b3IkMyA9IChzKSA9PiAoeyB0cmFuc2Zvcm06IHMudHJhbnNmb3JtLCBwYXR0ZXJuSWQ6IGBwYXR0ZXJuLSR7cy5yZklkfWAgfSk7XG5mdW5jdGlvbiBCYWNrZ3JvdW5kQ29tcG9uZW50KHsgaWQsIHZhcmlhbnQgPSBCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzLCBcbi8vIG9ubHkgdXNlZCBmb3IgZG90cyBhbmQgY3Jvc3NcbmdhcCA9IDIwLCBcbi8vIG9ubHkgdXNlZCBmb3IgbGluZXMgYW5kIGNyb3NzXG5zaXplLCBsaW5lV2lkdGggPSAxLCBvZmZzZXQgPSAwLCBjb2xvciwgYmdDb2xvciwgc3R5bGUsIGNsYXNzTmFtZSwgcGF0dGVybkNsYXNzTmFtZSwgfSkge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCB7IHRyYW5zZm9ybSwgcGF0dGVybklkIH0gPSB1c2VTdG9yZShzZWxlY3RvciQzLCBzaGFsbG93KTtcbiAgICBjb25zdCBwYXR0ZXJuU2l6ZSA9IHNpemUgfHwgZGVmYXVsdFNpemVbdmFyaWFudF07XG4gICAgY29uc3QgaXNEb3RzID0gdmFyaWFudCA9PT0gQmFja2dyb3VuZFZhcmlhbnQuRG90cztcbiAgICBjb25zdCBpc0Nyb3NzID0gdmFyaWFudCA9PT0gQmFja2dyb3VuZFZhcmlhbnQuQ3Jvc3M7XG4gICAgY29uc3QgZ2FwWFkgPSBBcnJheS5pc0FycmF5KGdhcCkgPyBnYXAgOiBbZ2FwLCBnYXBdO1xuICAgIGNvbnN0IHNjYWxlZEdhcCA9IFtnYXBYWVswXSAqIHRyYW5zZm9ybVsyXSB8fCAxLCBnYXBYWVsxXSAqIHRyYW5zZm9ybVsyXSB8fCAxXTtcbiAgICBjb25zdCBzY2FsZWRTaXplID0gcGF0dGVyblNpemUgKiB0cmFuc2Zvcm1bMl07XG4gICAgY29uc3Qgb2Zmc2V0WFkgPSBBcnJheS5pc0FycmF5KG9mZnNldCkgPyBvZmZzZXQgOiBbb2Zmc2V0LCBvZmZzZXRdO1xuICAgIGNvbnN0IHBhdHRlcm5EaW1lbnNpb25zID0gaXNDcm9zcyA/IFtzY2FsZWRTaXplLCBzY2FsZWRTaXplXSA6IHNjYWxlZEdhcDtcbiAgICBjb25zdCBzY2FsZWRPZmZzZXQgPSBbXG4gICAgICAgIG9mZnNldFhZWzBdICogdHJhbnNmb3JtWzJdIHx8IDEgKyBwYXR0ZXJuRGltZW5zaW9uc1swXSAvIDIsXG4gICAgICAgIG9mZnNldFhZWzFdICogdHJhbnNmb3JtWzJdIHx8IDEgKyBwYXR0ZXJuRGltZW5zaW9uc1sxXSAvIDIsXG4gICAgXTtcbiAgICBjb25zdCBfcGF0dGVybklkID0gYCR7cGF0dGVybklkfSR7aWQgPyBpZCA6ICcnfWA7XG4gICAgcmV0dXJuIChqc3hzKFwic3ZnXCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2JhY2tncm91bmQnLCBjbGFzc05hbWVdKSwgc3R5bGU6IHtcbiAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgLi4uY29udGFpbmVyU3R5bGUsXG4gICAgICAgICAgICAnLS14eS1iYWNrZ3JvdW5kLWNvbG9yLXByb3BzJzogYmdDb2xvcixcbiAgICAgICAgICAgICctLXh5LWJhY2tncm91bmQtcGF0dGVybi1jb2xvci1wcm9wcyc6IGNvbG9yLFxuICAgICAgICB9LCByZWY6IHJlZiwgXCJkYXRhLXRlc3RpZFwiOiBcInJmX19iYWNrZ3JvdW5kXCIsIGNoaWxkcmVuOiBbanN4KFwicGF0dGVyblwiLCB7IGlkOiBfcGF0dGVybklkLCB4OiB0cmFuc2Zvcm1bMF0gJSBzY2FsZWRHYXBbMF0sIHk6IHRyYW5zZm9ybVsxXSAlIHNjYWxlZEdhcFsxXSwgd2lkdGg6IHNjYWxlZEdhcFswXSwgaGVpZ2h0OiBzY2FsZWRHYXBbMV0sIHBhdHRlcm5Vbml0czogXCJ1c2VyU3BhY2VPblVzZVwiLCBwYXR0ZXJuVHJhbnNmb3JtOiBgdHJhbnNsYXRlKC0ke3NjYWxlZE9mZnNldFswXX0sLSR7c2NhbGVkT2Zmc2V0WzFdfSlgLCBjaGlsZHJlbjogaXNEb3RzID8gKGpzeChEb3RQYXR0ZXJuLCB7IHJhZGl1czogc2NhbGVkU2l6ZSAvIDIsIGNsYXNzTmFtZTogcGF0dGVybkNsYXNzTmFtZSB9KSkgOiAoanN4KExpbmVQYXR0ZXJuLCB7IGRpbWVuc2lvbnM6IHBhdHRlcm5EaW1lbnNpb25zLCBsaW5lV2lkdGg6IGxpbmVXaWR0aCwgdmFyaWFudDogdmFyaWFudCwgY2xhc3NOYW1lOiBwYXR0ZXJuQ2xhc3NOYW1lIH0pKSB9KSwganN4KFwicmVjdFwiLCB7IHg6IFwiMFwiLCB5OiBcIjBcIiwgd2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiMTAwJVwiLCBmaWxsOiBgdXJsKCMke19wYXR0ZXJuSWR9KWAgfSldIH0pKTtcbn1cbkJhY2tncm91bmRDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnQmFja2dyb3VuZCc7XG4vKipcbiAqIFRoZSBgPEJhY2tncm91bmQgLz5gIGNvbXBvbmVudCBtYWtlcyBpdCBjb252ZW5pZW50IHRvIHJlbmRlciBkaWZmZXJlbnQgdHlwZXMgb2YgYmFja2dyb3VuZHMgY29tbW9uIGluIG5vZGUtYmFzZWQgVUlzLiBJdCBjb21lcyB3aXRoIHRocmVlIHZhcmlhbnRzOiBsaW5lcywgZG90cyBhbmQgY3Jvc3MuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBBIHNpbXBsZSBleGFtcGxlIG9mIGhvdyB0byB1c2UgdGhlIEJhY2tncm91bmQgY29tcG9uZW50LlxuICpcbiAqIGBgYHRzeFxuICogaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG4gKiBpbXBvcnQgeyBSZWFjdEZsb3csIEJhY2tncm91bmQsIEJhY2tncm91bmRWYXJpYW50IH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8UmVhY3RGbG93IGRlZmF1bHROb2Rlcz17Wy4uLl19IGRlZmF1bHRFZGdlcz17Wy4uLl19PlxuICogICAgICAgPEJhY2tncm91bmQgY29sb3I9XCIjY2NjXCIgdmFyaWFudD17QmFja2dyb3VuZFZhcmlhbnQuRG90c30gLz5cbiAqICAgICA8L1JlYWN0Rmxvdz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogSW4gdGhpcyBleGFtcGxlIHlvdSBjYW4gc2VlIGhvdyB0byBjb21iaW5lIG11bHRpcGxlIGJhY2tncm91bmRzXG4gKlxuICogYGBgdHN4XG4gKiBpbXBvcnQgeyBSZWFjdEZsb3csIEJhY2tncm91bmQsIEJhY2tncm91bmRWYXJpYW50IH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKiBpbXBvcnQgJ0B4eWZsb3cvcmVhY3QvZGlzdC9zdHlsZS5jc3MnO1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPFJlYWN0RmxvdyBkZWZhdWx0Tm9kZXM9e1suLi5dfSBkZWZhdWx0RWRnZXM9e1suLi5dfT5cbiAqICAgICAgIDxCYWNrZ3JvdW5kXG4gKiAgICAgICAgIGlkPVwiMVwiXG4gKiAgICAgICAgIGdhcD17MTB9XG4gKiAgICAgICAgIGNvbG9yPVwiI2YxZjFmMVwiXG4gKiAgICAgICAgIHZhcmlhbnQ9e0JhY2tncm91bmRWYXJpYW50LkxpbmVzfVxuICogICAgICAgLz5cbiAqICAgICAgIDxCYWNrZ3JvdW5kXG4gKiAgICAgICAgIGlkPVwiMlwiXG4gKiAgICAgICAgIGdhcD17MTAwfVxuICogICAgICAgICBjb2xvcj1cIiNjY2NcIlxuICogICAgICAgICB2YXJpYW50PXtCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc31cbiAqICAgICAgIC8+XG4gKiAgICAgPC9SZWFjdEZsb3c+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIFdoZW4gY29tYmluaW5nIG11bHRpcGxlIDxCYWNrZ3JvdW5kIC8+IGNvbXBvbmVudHMgaXTigJlzIGltcG9ydGFudCB0byBnaXZlIGVhY2ggb2YgdGhlbSBhIHVuaXF1ZSBpZCBwcm9wIVxuICpcbiAqL1xuY29uc3QgQmFja2dyb3VuZCA9IG1lbW8oQmFja2dyb3VuZENvbXBvbmVudCk7XG5cbmZ1bmN0aW9uIFBsdXNJY29uKCkge1xuICAgIHJldHVybiAoanN4KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmlld0JveDogXCIwIDAgMzIgMzJcIiwgY2hpbGRyZW46IGpzeChcInBhdGhcIiwgeyBkOiBcIk0zMiAxOC4xMzNIMTguMTMzVjMyaC00LjI2NlYxOC4xMzNIMHYtNC4yNjZoMTMuODY3VjBoNC4yNjZ2MTMuODY3SDMyelwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gTWludXNJY29uKCkge1xuICAgIHJldHVybiAoanN4KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmlld0JveDogXCIwIDAgMzIgNVwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTAgMGgzMnY0LjJIMHpcIiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIEZpdFZpZXdJY29uKCkge1xuICAgIHJldHVybiAoanN4KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmlld0JveDogXCIwIDAgMzIgMzBcIiwgY2hpbGRyZW46IGpzeChcInBhdGhcIiwgeyBkOiBcIk0zLjY5MiA0LjYzYzAtLjUzLjQtLjkzOC45MzktLjkzOGg1LjIxNVYwSDQuNzA4QzIuMTMgMCAwIDIuMDU0IDAgNC42M3Y1LjIxNmgzLjY5MlY0LjYzMXpNMjcuMzU0IDBoLTUuMnYzLjY5Mmg1LjE3Yy41MyAwIC45ODQuNC45ODQuOTM5djUuMjE1SDMyVjQuNjMxQTQuNjI0IDQuNjI0IDAgMDAyNy4zNTQgMHptLjk1NCAyNC44M2MwIC41MzItLjQuOTQtLjkzOS45NGgtNS4yMTV2My43NjhoNS4yMTVjMi41NzcgMCA0LjYzMS0yLjEzIDQuNjMxLTQuNzA3di01LjEzOWgtMy42OTJ2NS4xMzl6bS0yMy42NzcuOTRjLS41MzEgMC0uOTM5LS40LS45MzktLjk0di01LjEzOEgwdjUuMTM5YzAgMi41NzcgMi4xMyA0LjcwNyA0LjcwOCA0LjcwN2g1LjEzOFYyNS43N0g0LjYzMXpcIiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIExvY2tJY29uKCkge1xuICAgIHJldHVybiAoanN4KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmlld0JveDogXCIwIDAgMjUgMzJcIiwgY2hpbGRyZW46IGpzeChcInBhdGhcIiwgeyBkOiBcIk0yMS4zMzMgMTAuNjY3SDE5LjgxVjcuNjE5QzE5LjgxIDMuNDI5IDE2LjM4IDAgMTIuMTkgMCA4IDAgNC41NzEgMy40MjkgNC41NzEgNy42MTl2My4wNDhIMy4wNDhBMy4wNTYgMy4wNTYgMCAwMDAgMTMuNzE0djE1LjIzOEEzLjA1NiAzLjA1NiAwIDAwMy4wNDggMzJoMTguMjg1YTMuMDU2IDMuMDU2IDAgMDAzLjA0OC0zLjA0OFYxMy43MTRhMy4wNTYgMy4wNTYgMCAwMC0zLjA0OC0zLjA0N3pNMTIuMTkgMjQuNTMzYTMuMDU2IDMuMDU2IDAgMDEtMy4wNDctMy4wNDcgMy4wNTYgMy4wNTYgMCAwMTMuMDQ3LTMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEzLjA0OCAzLjA0OCAzLjA1NiAzLjA1NiAwIDAxLTMuMDQ4IDMuMDQ3em00LjcyNC0xMy44NjZINy40NjdWNy42MTljMC0yLjU5IDIuMTMzLTQuNzI0IDQuNzIzLTQuNzI0IDIuNTkxIDAgNC43MjQgMi4xMzMgNC43MjQgNC43MjR2My4wNDh6XCIgfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBVbmxvY2tJY29uKCkge1xuICAgIHJldHVybiAoanN4KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmlld0JveDogXCIwIDAgMjUgMzJcIiwgY2hpbGRyZW46IGpzeChcInBhdGhcIiwgeyBkOiBcIk0yMS4zMzMgMTAuNjY3SDE5LjgxVjcuNjE5QzE5LjgxIDMuNDI5IDE2LjM4IDAgMTIuMTkgMGMtNC4xMTQgMS44MjgtMS4zNyAyLjEzMy4zMDUgMi40MzggMS42NzYuMzA1IDQuNDIgMi41OSA0LjQyIDUuMTgxdjMuMDQ4SDMuMDQ3QTMuMDU2IDMuMDU2IDAgMDAwIDEzLjcxNHYxNS4yMzhBMy4wNTYgMy4wNTYgMCAwMDMuMDQ4IDMyaDE4LjI4NWEzLjA1NiAzLjA1NiAwIDAwMy4wNDgtMy4wNDhWMTMuNzE0YTMuMDU2IDMuMDU2IDAgMDAtMy4wNDgtMy4wNDd6TTEyLjE5IDI0LjUzM2EzLjA1NiAzLjA1NiAwIDAxLTMuMDQ3LTMuMDQ3IDMuMDU2IDMuMDU2IDAgMDEzLjA0Ny0zLjA0OCAzLjA1NiAzLjA1NiAwIDAxMy4wNDggMy4wNDggMy4wNTYgMy4wNTYgMCAwMS0zLjA0OCAzLjA0N3pcIiB9KSB9KSk7XG59XG5cbi8qKlxuICogWW91IGNhbiBhZGQgYnV0dG9ucyB0byB0aGUgY29udHJvbCBwYW5lbCBieSB1c2luZyB0aGUgYDxDb250cm9sQnV0dG9uIC8+YCBjb21wb25lbnRcbiAqIGFuZCBwYXNzIGl0IGFzIGEgY2hpbGQgdG8gdGhlIFtgPENvbnRyb2xzIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9jb250cm9scykgY29tcG9uZW50LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKmBgYGpzeFxuICppbXBvcnQgeyBNYWdpY1dhbmQgfSBmcm9tICdAcmFkaXgtdWkvcmVhY3QtaWNvbnMnXG4gKmltcG9ydCB7IFJlYWN0RmxvdywgQ29udHJvbHMsIENvbnRyb2xCdXR0b24gfSBmcm9tICdAeHlmbG93L3JlYWN0J1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0RmxvdyBub2Rlcz17Wy4uLl19IGVkZ2VzPXtbLi4uXX0+XG4gKiAgICAgIDxDb250cm9scz5cbiAqICAgICAgICA8Q29udHJvbEJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBhbGVydCgnU29tZXRoaW5nIG1hZ2ljYWwganVzdCBoYXBwZW5lZC4g4pyoJyl9PlxuICogICAgICAgICAgPE1hZ2ljV2FuZCAvPlxuICogICAgICAgIDwvQ29udHJvbEJ1dHRvbj5cbiAqICAgICAgPC9Db250cm9scz5cbiAqICAgIDwvUmVhY3RGbG93PlxuICogIClcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gQ29udHJvbEJ1dHRvbih7IGNoaWxkcmVuLCBjbGFzc05hbWUsIC4uLnJlc3QgfSkge1xuICAgIHJldHVybiAoanN4KFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2NvbnRyb2xzLWJ1dHRvbicsIGNsYXNzTmFtZV0pLCAuLi5yZXN0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciQyID0gKHMpID0+ICh7XG4gICAgaXNJbnRlcmFjdGl2ZTogcy5ub2Rlc0RyYWdnYWJsZSB8fCBzLm5vZGVzQ29ubmVjdGFibGUgfHwgcy5lbGVtZW50c1NlbGVjdGFibGUsXG4gICAgbWluWm9vbVJlYWNoZWQ6IHMudHJhbnNmb3JtWzJdIDw9IHMubWluWm9vbSxcbiAgICBtYXhab29tUmVhY2hlZDogcy50cmFuc2Zvcm1bMl0gPj0gcy5tYXhab29tLFxufSk7XG5mdW5jdGlvbiBDb250cm9sc0NvbXBvbmVudCh7IHN0eWxlLCBzaG93Wm9vbSA9IHRydWUsIHNob3dGaXRWaWV3ID0gdHJ1ZSwgc2hvd0ludGVyYWN0aXZlID0gdHJ1ZSwgZml0Vmlld09wdGlvbnMsIG9uWm9vbUluLCBvblpvb21PdXQsIG9uRml0Vmlldywgb25JbnRlcmFjdGl2ZUNoYW5nZSwgY2xhc3NOYW1lLCBjaGlsZHJlbiwgcG9zaXRpb24gPSAnYm90dG9tLWxlZnQnLCBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCcsICdhcmlhLWxhYmVsJzogYXJpYUxhYmVsID0gJ1JlYWN0IEZsb3cgY29udHJvbHMnLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgaXNJbnRlcmFjdGl2ZSwgbWluWm9vbVJlYWNoZWQsIG1heFpvb21SZWFjaGVkIH0gPSB1c2VTdG9yZShzZWxlY3RvciQyLCBzaGFsbG93KTtcbiAgICBjb25zdCB7IHpvb21Jbiwgem9vbU91dCwgZml0VmlldyB9ID0gdXNlUmVhY3RGbG93KCk7XG4gICAgY29uc3Qgb25ab29tSW5IYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB6b29tSW4oKTtcbiAgICAgICAgb25ab29tSW4/LigpO1xuICAgIH07XG4gICAgY29uc3Qgb25ab29tT3V0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgem9vbU91dCgpO1xuICAgICAgICBvblpvb21PdXQ/LigpO1xuICAgIH07XG4gICAgY29uc3Qgb25GaXRWaWV3SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgZml0VmlldyhmaXRWaWV3T3B0aW9ucyk7XG4gICAgICAgIG9uRml0Vmlldz8uKCk7XG4gICAgfTtcbiAgICBjb25zdCBvblRvZ2dsZUludGVyYWN0aXZpdHkgPSAoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIG5vZGVzRHJhZ2dhYmxlOiAhaXNJbnRlcmFjdGl2ZSxcbiAgICAgICAgICAgIG5vZGVzQ29ubmVjdGFibGU6ICFpc0ludGVyYWN0aXZlLFxuICAgICAgICAgICAgZWxlbWVudHNTZWxlY3RhYmxlOiAhaXNJbnRlcmFjdGl2ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uSW50ZXJhY3RpdmVDaGFuZ2U/LighaXNJbnRlcmFjdGl2ZSk7XG4gICAgfTtcbiAgICBjb25zdCBvcmllbnRhdGlvbkNsYXNzID0gb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCc7XG4gICAgcmV0dXJuIChqc3hzKFBhbmVsLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19jb250cm9scycsIG9yaWVudGF0aW9uQ2xhc3MsIGNsYXNzTmFtZV0pLCBwb3NpdGlvbjogcG9zaXRpb24sIHN0eWxlOiBzdHlsZSwgXCJkYXRhLXRlc3RpZFwiOiBcInJmX19jb250cm9sc1wiLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsLCBjaGlsZHJlbjogW3Nob3dab29tICYmIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KENvbnRyb2xCdXR0b24sIHsgb25DbGljazogb25ab29tSW5IYW5kbGVyLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtem9vbWluXCIsIHRpdGxlOiBcInpvb20gaW5cIiwgXCJhcmlhLWxhYmVsXCI6IFwiem9vbSBpblwiLCBkaXNhYmxlZDogbWF4Wm9vbVJlYWNoZWQsIGNoaWxkcmVuOiBqc3goUGx1c0ljb24sIHt9KSB9KSwganN4KENvbnRyb2xCdXR0b24sIHsgb25DbGljazogb25ab29tT3V0SGFuZGxlciwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2NvbnRyb2xzLXpvb21vdXRcIiwgdGl0bGU6IFwiem9vbSBvdXRcIiwgXCJhcmlhLWxhYmVsXCI6IFwiem9vbSBvdXRcIiwgZGlzYWJsZWQ6IG1pblpvb21SZWFjaGVkLCBjaGlsZHJlbjoganN4KE1pbnVzSWNvbiwge30pIH0pXSB9KSksIHNob3dGaXRWaWV3ICYmIChqc3goQ29udHJvbEJ1dHRvbiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtZml0dmlld1wiLCBvbkNsaWNrOiBvbkZpdFZpZXdIYW5kbGVyLCB0aXRsZTogXCJmaXQgdmlld1wiLCBcImFyaWEtbGFiZWxcIjogXCJmaXQgdmlld1wiLCBjaGlsZHJlbjoganN4KEZpdFZpZXdJY29uLCB7fSkgfSkpLCBzaG93SW50ZXJhY3RpdmUgJiYgKGpzeChDb250cm9sQnV0dG9uLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy1pbnRlcmFjdGl2ZVwiLCBvbkNsaWNrOiBvblRvZ2dsZUludGVyYWN0aXZpdHksIHRpdGxlOiBcInRvZ2dsZSBpbnRlcmFjdGl2aXR5XCIsIFwiYXJpYS1sYWJlbFwiOiBcInRvZ2dsZSBpbnRlcmFjdGl2aXR5XCIsIGNoaWxkcmVuOiBpc0ludGVyYWN0aXZlID8ganN4KFVubG9ja0ljb24sIHt9KSA6IGpzeChMb2NrSWNvbiwge30pIH0pKSwgY2hpbGRyZW5dIH0pKTtcbn1cbkNvbnRyb2xzQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0NvbnRyb2xzJztcbi8qKlxuICogVGhlIGA8Q29udHJvbHMgLz5gIGNvbXBvbmVudCByZW5kZXJzIGEgc21hbGwgcGFuZWwgdGhhdCBjb250YWlucyBjb252ZW5pZW50XG4gKiBidXR0b25zIHRvIHpvb20gaW4sIHpvb20gb3V0LCBmaXQgdGhlIHZpZXcsIGFuZCBsb2NrIHRoZSB2aWV3cG9ydC5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpgYGB0c3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBDb250cm9scyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnXG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbLi4uXX0gZWRnZXM9e1suLi5dfT5cbiAqICAgICAgPENvbnRyb2xzIC8+XG4gKiAgICA8L1JlYWN0Rmxvdz5cbiAqICApXG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVG8gZXh0ZW5kIG9yIGN1c3RvbWlzZSB0aGUgY29udHJvbHMsIHlvdSBjYW4gdXNlIHRoZSBbYDxDb250cm9sQnV0dG9uIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9jb250cm9sLWJ1dHRvbikgY29tcG9uZW50XG4gKlxuICovXG5jb25zdCBDb250cm9scyA9IG1lbW8oQ29udHJvbHNDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBNaW5pTWFwTm9kZUNvbXBvbmVudCh7IGlkLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdHlsZSwgY29sb3IsIHN0cm9rZUNvbG9yLCBzdHJva2VXaWR0aCwgY2xhc3NOYW1lLCBib3JkZXJSYWRpdXMsIHNoYXBlUmVuZGVyaW5nLCBzZWxlY3RlZCwgb25DbGljaywgfSkge1xuICAgIGNvbnN0IHsgYmFja2dyb3VuZCwgYmFja2dyb3VuZENvbG9yIH0gPSBzdHlsZSB8fCB7fTtcbiAgICBjb25zdCBmaWxsID0gKGNvbG9yIHx8IGJhY2tncm91bmQgfHwgYmFja2dyb3VuZENvbG9yKTtcbiAgICByZXR1cm4gKGpzeChcInJlY3RcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fbWluaW1hcC1ub2RlJywgeyBzZWxlY3RlZCB9LCBjbGFzc05hbWVdKSwgeDogeCwgeTogeSwgcng6IGJvcmRlclJhZGl1cywgcnk6IGJvcmRlclJhZGl1cywgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgc3R5bGU6IHtcbiAgICAgICAgICAgIGZpbGwsXG4gICAgICAgICAgICBzdHJva2U6IHN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIH0sIHNoYXBlUmVuZGVyaW5nOiBzaGFwZVJlbmRlcmluZywgb25DbGljazogb25DbGljayA/IChldmVudCkgPT4gb25DbGljayhldmVudCwgaWQpIDogdW5kZWZpbmVkIH0pKTtcbn1cbmNvbnN0IE1pbmlNYXBOb2RlID0gbWVtbyhNaW5pTWFwTm9kZUNvbXBvbmVudCk7XG5cbmNvbnN0IHNlbGVjdG9yTm9kZUlkcyA9IChzKSA9PiBzLm5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5pZCk7XG5jb25zdCBnZXRBdHRyRnVuY3Rpb24gPSAoZnVuYykgPT4gZnVuYyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZnVuYyA6ICgpID0+IGZ1bmM7XG5mdW5jdGlvbiBNaW5pTWFwTm9kZXMoeyBub2RlU3Ryb2tlQ29sb3IsIG5vZGVDb2xvciwgbm9kZUNsYXNzTmFtZSA9ICcnLCBub2RlQm9yZGVyUmFkaXVzID0gNSwgbm9kZVN0cm9rZVdpZHRoLCBcbi8qXG4gKiBXZSBuZWVkIHRvIHJlbmFtZSB0aGUgcHJvcCB0byBiZSBgQ2FwaXRhbENhc2VgIHNvIHRoYXQgSlNYIHdpbGwgcmVuZGVyIGl0IGFzXG4gKiBhIGNvbXBvbmVudCBwcm9wZXJseS5cbiAqL1xubm9kZUNvbXBvbmVudDogTm9kZUNvbXBvbmVudCA9IE1pbmlNYXBOb2RlLCBvbkNsaWNrLCB9KSB7XG4gICAgY29uc3Qgbm9kZUlkcyA9IHVzZVN0b3JlKHNlbGVjdG9yTm9kZUlkcywgc2hhbGxvdyk7XG4gICAgY29uc3Qgbm9kZUNvbG9yRnVuYyA9IGdldEF0dHJGdW5jdGlvbihub2RlQ29sb3IpO1xuICAgIGNvbnN0IG5vZGVTdHJva2VDb2xvckZ1bmMgPSBnZXRBdHRyRnVuY3Rpb24obm9kZVN0cm9rZUNvbG9yKTtcbiAgICBjb25zdCBub2RlQ2xhc3NOYW1lRnVuYyA9IGdldEF0dHJGdW5jdGlvbihub2RlQ2xhc3NOYW1lKTtcbiAgICBjb25zdCBzaGFwZVJlbmRlcmluZyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICEhd2luZG93LmNocm9tZSA/ICdjcmlzcEVkZ2VzJyA6ICdnZW9tZXRyaWNQcmVjaXNpb24nO1xuICAgIHJldHVybiAoanN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBub2RlSWRzLm1hcCgobm9kZUlkKSA9PiAoXG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBzcGxpdCBvZiByZXNwb25zaWJpbGl0aWVzIGJldHdlZW4gTWluaU1hcE5vZGVzIGFuZFxuICAgICAgICAgKiBOb2RlQ29tcG9uZW50V3JhcHBlciBtYXkgYXBwZWFyIHdlaXJkLiBIb3dldmVyLCBpdOKAmXMgZGVzaWduZWQgdG9cbiAgICAgICAgICogbWluaW1pemUgdGhlIGNvc3Qgb2YgdXBkYXRlcyB3aGVuIGluZGl2aWR1YWwgbm9kZXMgY2hhbmdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgYSBzaW1pbGFyIGNvbW1pdCBpbiBgTm9kZVJlbmRlcmVyL2luZGV4LnRzeGAuXG4gICAgICAgICAqL1xuICAgICAgICBqc3goTm9kZUNvbXBvbmVudFdyYXBwZXIsIHsgaWQ6IG5vZGVJZCwgbm9kZUNvbG9yRnVuYzogbm9kZUNvbG9yRnVuYywgbm9kZVN0cm9rZUNvbG9yRnVuYzogbm9kZVN0cm9rZUNvbG9yRnVuYywgbm9kZUNsYXNzTmFtZUZ1bmM6IG5vZGVDbGFzc05hbWVGdW5jLCBub2RlQm9yZGVyUmFkaXVzOiBub2RlQm9yZGVyUmFkaXVzLCBub2RlU3Ryb2tlV2lkdGg6IG5vZGVTdHJva2VXaWR0aCwgTm9kZUNvbXBvbmVudDogTm9kZUNvbXBvbmVudCwgb25DbGljazogb25DbGljaywgc2hhcGVSZW5kZXJpbmc6IHNoYXBlUmVuZGVyaW5nIH0sIG5vZGVJZCkpKSB9KSk7XG59XG5mdW5jdGlvbiBOb2RlQ29tcG9uZW50V3JhcHBlcklubmVyKHsgaWQsIG5vZGVDb2xvckZ1bmMsIG5vZGVTdHJva2VDb2xvckZ1bmMsIG5vZGVDbGFzc05hbWVGdW5jLCBub2RlQm9yZGVyUmFkaXVzLCBub2RlU3Ryb2tlV2lkdGgsIHNoYXBlUmVuZGVyaW5nLCBOb2RlQ29tcG9uZW50LCBvbkNsaWNrLCB9KSB7XG4gICAgY29uc3QgeyBub2RlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VTdG9yZSgocykgPT4ge1xuICAgICAgICBjb25zdCB7IGludGVybmFscyB9ID0gcy5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBpbnRlcm5hbHMudXNlck5vZGU7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9LCBzaGFsbG93KTtcbiAgICBpZiAoIW5vZGUgfHwgbm9kZS5oaWRkZW4gfHwgIW5vZGVIYXNEaW1lbnNpb25zKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChOb2RlQ29tcG9uZW50LCB7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHN0eWxlOiBub2RlLnN0eWxlLCBzZWxlY3RlZDogISFub2RlLnNlbGVjdGVkLCBjbGFzc05hbWU6IG5vZGVDbGFzc05hbWVGdW5jKG5vZGUpLCBjb2xvcjogbm9kZUNvbG9yRnVuYyhub2RlKSwgYm9yZGVyUmFkaXVzOiBub2RlQm9yZGVyUmFkaXVzLCBzdHJva2VDb2xvcjogbm9kZVN0cm9rZUNvbG9yRnVuYyhub2RlKSwgc3Ryb2tlV2lkdGg6IG5vZGVTdHJva2VXaWR0aCwgc2hhcGVSZW5kZXJpbmc6IHNoYXBlUmVuZGVyaW5nLCBvbkNsaWNrOiBvbkNsaWNrLCBpZDogbm9kZS5pZCB9KSk7XG59XG5jb25zdCBOb2RlQ29tcG9uZW50V3JhcHBlciA9IG1lbW8oTm9kZUNvbXBvbmVudFdyYXBwZXJJbm5lcik7XG52YXIgTWluaU1hcE5vZGVzJDEgPSBtZW1vKE1pbmlNYXBOb2Rlcyk7XG5cbmNvbnN0IGRlZmF1bHRXaWR0aCA9IDIwMDtcbmNvbnN0IGRlZmF1bHRIZWlnaHQgPSAxNTA7XG5jb25zdCBmaWx0ZXJIaWRkZW4gPSAobm9kZSkgPT4gIW5vZGUuaGlkZGVuO1xuY29uc3Qgc2VsZWN0b3IkMSA9IChzKSA9PiB7XG4gICAgY29uc3Qgdmlld0JCID0ge1xuICAgICAgICB4OiAtcy50cmFuc2Zvcm1bMF0gLyBzLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgeTogLXMudHJhbnNmb3JtWzFdIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIHdpZHRoOiBzLndpZHRoIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIGhlaWdodDogcy5oZWlnaHQgLyBzLnRyYW5zZm9ybVsyXSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHZpZXdCQixcbiAgICAgICAgYm91bmRpbmdSZWN0OiBzLm5vZGVMb29rdXAuc2l6ZSA+IDBcbiAgICAgICAgICAgID8gZ2V0Qm91bmRzT2ZSZWN0cyhnZXRJbnRlcm5hbE5vZGVzQm91bmRzKHMubm9kZUxvb2t1cCwgeyBmaWx0ZXI6IGZpbHRlckhpZGRlbiB9KSwgdmlld0JCKVxuICAgICAgICAgICAgOiB2aWV3QkIsXG4gICAgICAgIHJmSWQ6IHMucmZJZCxcbiAgICAgICAgcGFuWm9vbTogcy5wYW5ab29tLFxuICAgICAgICB0cmFuc2xhdGVFeHRlbnQ6IHMudHJhbnNsYXRlRXh0ZW50LFxuICAgICAgICBmbG93V2lkdGg6IHMud2lkdGgsXG4gICAgICAgIGZsb3dIZWlnaHQ6IHMuaGVpZ2h0LFxuICAgIH07XG59O1xuY29uc3QgQVJJQV9MQUJFTF9LRVkgPSAncmVhY3QtZmxvd19fbWluaW1hcC1kZXNjJztcbmZ1bmN0aW9uIE1pbmlNYXBDb21wb25lbnQoeyBzdHlsZSwgY2xhc3NOYW1lLCBub2RlU3Ryb2tlQ29sb3IsIG5vZGVDb2xvciwgbm9kZUNsYXNzTmFtZSA9ICcnLCBub2RlQm9yZGVyUmFkaXVzID0gNSwgbm9kZVN0cm9rZVdpZHRoLCBcbi8qXG4gKiBXZSBuZWVkIHRvIHJlbmFtZSB0aGUgcHJvcCB0byBiZSBgQ2FwaXRhbENhc2VgIHNvIHRoYXQgSlNYIHdpbGwgcmVuZGVyIGl0IGFzXG4gKiBhIGNvbXBvbmVudCBwcm9wZXJseS5cbiAqL1xubm9kZUNvbXBvbmVudCwgYmdDb2xvciwgbWFza0NvbG9yLCBtYXNrU3Ryb2tlQ29sb3IsIG1hc2tTdHJva2VXaWR0aCwgcG9zaXRpb24gPSAnYm90dG9tLXJpZ2h0Jywgb25DbGljaywgb25Ob2RlQ2xpY2ssIHBhbm5hYmxlID0gZmFsc2UsIHpvb21hYmxlID0gZmFsc2UsIGFyaWFMYWJlbCA9ICdSZWFjdCBGbG93IG1pbmkgbWFwJywgaW52ZXJzZVBhbiwgem9vbVN0ZXAgPSAxMCwgb2Zmc2V0U2NhbGUgPSA1LCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHN2ZyA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCB7IGJvdW5kaW5nUmVjdCwgdmlld0JCLCByZklkLCBwYW5ab29tLCB0cmFuc2xhdGVFeHRlbnQsIGZsb3dXaWR0aCwgZmxvd0hlaWdodCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkMSwgc2hhbGxvdyk7XG4gICAgY29uc3QgZWxlbWVudFdpZHRoID0gc3R5bGU/LndpZHRoID8/IGRlZmF1bHRXaWR0aDtcbiAgICBjb25zdCBlbGVtZW50SGVpZ2h0ID0gc3R5bGU/LmhlaWdodCA/PyBkZWZhdWx0SGVpZ2h0O1xuICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gYm91bmRpbmdSZWN0LndpZHRoIC8gZWxlbWVudFdpZHRoO1xuICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IGJvdW5kaW5nUmVjdC5oZWlnaHQgLyBlbGVtZW50SGVpZ2h0O1xuICAgIGNvbnN0IHZpZXdTY2FsZSA9IE1hdGgubWF4KHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgIGNvbnN0IHZpZXdXaWR0aCA9IHZpZXdTY2FsZSAqIGVsZW1lbnRXaWR0aDtcbiAgICBjb25zdCB2aWV3SGVpZ2h0ID0gdmlld1NjYWxlICogZWxlbWVudEhlaWdodDtcbiAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRTY2FsZSAqIHZpZXdTY2FsZTtcbiAgICBjb25zdCB4ID0gYm91bmRpbmdSZWN0LnggLSAodmlld1dpZHRoIC0gYm91bmRpbmdSZWN0LndpZHRoKSAvIDIgLSBvZmZzZXQ7XG4gICAgY29uc3QgeSA9IGJvdW5kaW5nUmVjdC55IC0gKHZpZXdIZWlnaHQgLSBib3VuZGluZ1JlY3QuaGVpZ2h0KSAvIDIgLSBvZmZzZXQ7XG4gICAgY29uc3Qgd2lkdGggPSB2aWV3V2lkdGggKyBvZmZzZXQgKiAyO1xuICAgIGNvbnN0IGhlaWdodCA9IHZpZXdIZWlnaHQgKyBvZmZzZXQgKiAyO1xuICAgIGNvbnN0IGxhYmVsbGVkQnkgPSBgJHtBUklBX0xBQkVMX0tFWX0tJHtyZklkfWA7XG4gICAgY29uc3Qgdmlld1NjYWxlUmVmID0gdXNlUmVmKDApO1xuICAgIGNvbnN0IG1pbmltYXBJbnN0YW5jZSA9IHVzZVJlZigpO1xuICAgIHZpZXdTY2FsZVJlZi5jdXJyZW50ID0gdmlld1NjYWxlO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzdmcuY3VycmVudCAmJiBwYW5ab29tKSB7XG4gICAgICAgICAgICBtaW5pbWFwSW5zdGFuY2UuY3VycmVudCA9IFhZTWluaW1hcCh7XG4gICAgICAgICAgICAgICAgZG9tTm9kZTogc3ZnLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcGFuWm9vbSxcbiAgICAgICAgICAgICAgICBnZXRUcmFuc2Zvcm06ICgpID0+IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIGdldFZpZXdTY2FsZTogKCkgPT4gdmlld1NjYWxlUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWluaW1hcEluc3RhbmNlLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbcGFuWm9vbV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIG1pbmltYXBJbnN0YW5jZS5jdXJyZW50Py51cGRhdGUoe1xuICAgICAgICAgICAgdHJhbnNsYXRlRXh0ZW50LFxuICAgICAgICAgICAgd2lkdGg6IGZsb3dXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogZmxvd0hlaWdodCxcbiAgICAgICAgICAgIGludmVyc2VQYW4sXG4gICAgICAgICAgICBwYW5uYWJsZSxcbiAgICAgICAgICAgIHpvb21TdGVwLFxuICAgICAgICAgICAgem9vbWFibGUsXG4gICAgICAgIH0pO1xuICAgIH0sIFtwYW5uYWJsZSwgem9vbWFibGUsIGludmVyc2VQYW4sIHpvb21TdGVwLCB0cmFuc2xhdGVFeHRlbnQsIGZsb3dXaWR0aCwgZmxvd0hlaWdodF0pO1xuICAgIGNvbnN0IG9uU3ZnQ2xpY2sgPSBvbkNsaWNrXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbeCwgeV0gPSBtaW5pbWFwSW5zdGFuY2UuY3VycmVudD8ucG9pbnRlcihldmVudCkgfHwgWzAsIDBdO1xuICAgICAgICAgICAgb25DbGljayhldmVudCwgeyB4LCB5IH0pO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uU3ZnTm9kZUNsaWNrID0gb25Ob2RlQ2xpY2tcbiAgICAgICAgPyB1c2VDYWxsYmFjaygoZXZlbnQsIG5vZGVJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHN0b3JlLmdldFN0YXRlKCkubm9kZUxvb2t1cC5nZXQobm9kZUlkKS5pbnRlcm5hbHMudXNlck5vZGU7XG4gICAgICAgICAgICBvbk5vZGVDbGljayhldmVudCwgbm9kZSk7XG4gICAgICAgIH0sIFtdKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gKGpzeChQYW5lbCwgeyBwb3NpdGlvbjogcG9zaXRpb24sIHN0eWxlOiB7XG4gICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtYmFja2dyb3VuZC1jb2xvci1wcm9wcyc6IHR5cGVvZiBiZ0NvbG9yID09PSAnc3RyaW5nJyA/IGJnQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW1hc2stYmFja2dyb3VuZC1jb2xvci1wcm9wcyc6IHR5cGVvZiBtYXNrQ29sb3IgPT09ICdzdHJpbmcnID8gbWFza0NvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1tYXNrLXN0cm9rZS1jb2xvci1wcm9wcyc6IHR5cGVvZiBtYXNrU3Ryb2tlQ29sb3IgPT09ICdzdHJpbmcnID8gbWFza1N0cm9rZUNvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1tYXNrLXN0cm9rZS13aWR0aC1wcm9wcyc6IHR5cGVvZiBtYXNrU3Ryb2tlV2lkdGggPT09ICdudW1iZXInID8gbWFza1N0cm9rZVdpZHRoICogdmlld1NjYWxlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1ub2RlLWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiB0eXBlb2Ygbm9kZUNvbG9yID09PSAnc3RyaW5nJyA/IG5vZGVDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbm9kZS1zdHJva2UtY29sb3ItcHJvcHMnOiB0eXBlb2Ygbm9kZVN0cm9rZUNvbG9yID09PSAnc3RyaW5nJyA/IG5vZGVTdHJva2VDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbm9kZS1zdHJva2Utd2lkdGgtcHJvcHMnOiB0eXBlb2Ygbm9kZVN0cm9rZVdpZHRoID09PSAnbnVtYmVyJyA/IG5vZGVTdHJva2VXaWR0aCA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX21pbmltYXAnLCBjbGFzc05hbWVdKSwgXCJkYXRhLXRlc3RpZFwiOiBcInJmX19taW5pbWFwXCIsIGNoaWxkcmVuOiBqc3hzKFwic3ZnXCIsIHsgd2lkdGg6IGVsZW1lbnRXaWR0aCwgaGVpZ2h0OiBlbGVtZW50SGVpZ2h0LCB2aWV3Qm94OiBgJHt4fSAke3l9ICR7d2lkdGh9ICR7aGVpZ2h0fWAsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19taW5pbWFwLXN2Z1wiLCByb2xlOiBcImltZ1wiLCBcImFyaWEtbGFiZWxsZWRieVwiOiBsYWJlbGxlZEJ5LCByZWY6IHN2Zywgb25DbGljazogb25TdmdDbGljaywgY2hpbGRyZW46IFthcmlhTGFiZWwgJiYganN4KFwidGl0bGVcIiwgeyBpZDogbGFiZWxsZWRCeSwgY2hpbGRyZW46IGFyaWFMYWJlbCB9KSwganN4KE1pbmlNYXBOb2RlcyQxLCB7IG9uQ2xpY2s6IG9uU3ZnTm9kZUNsaWNrLCBub2RlQ29sb3I6IG5vZGVDb2xvciwgbm9kZVN0cm9rZUNvbG9yOiBub2RlU3Ryb2tlQ29sb3IsIG5vZGVCb3JkZXJSYWRpdXM6IG5vZGVCb3JkZXJSYWRpdXMsIG5vZGVDbGFzc05hbWU6IG5vZGVDbGFzc05hbWUsIG5vZGVTdHJva2VXaWR0aDogbm9kZVN0cm9rZVdpZHRoLCBub2RlQ29tcG9uZW50OiBub2RlQ29tcG9uZW50IH0pLCBqc3goXCJwYXRoXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX21pbmltYXAtbWFza1wiLCBkOiBgTSR7eCAtIG9mZnNldH0sJHt5IC0gb2Zmc2V0fWgke3dpZHRoICsgb2Zmc2V0ICogMn12JHtoZWlnaHQgKyBvZmZzZXQgKiAyfWgkey13aWR0aCAtIG9mZnNldCAqIDJ9elxuICAgICAgICBNJHt2aWV3QkIueH0sJHt2aWV3QkIueX1oJHt2aWV3QkIud2lkdGh9diR7dmlld0JCLmhlaWdodH1oJHstdmlld0JCLndpZHRofXpgLCBmaWxsUnVsZTogXCJldmVub2RkXCIsIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiIH0pXSB9KSB9KSk7XG59XG5NaW5pTWFwQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ01pbmlNYXAnO1xuLyoqXG4gKiBUaGUgYDxNaW5pTWFwIC8+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gcmVuZGVyIGFuIG92ZXJ2aWV3IG9mIHlvdXIgZmxvdy4gSXRcbiAqIHJlbmRlcnMgZWFjaCBub2RlIGFzIGFuIFNWRyBlbGVtZW50IGFuZCB2aXN1YWxpemVzIHdoZXJlIHRoZSBjdXJyZW50IHZpZXdwb3J0IGlzXG4gKiBpbiByZWxhdGlvbiB0byB0aGUgcmVzdCBvZiB0aGUgZmxvdy5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIE1pbmlNYXAgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3cgbm9kZXM9e1suLi5dXX0gZWRnZXM9e1suLi5dXX0+XG4gKiAgICAgIDxNaW5pTWFwIG5vZGVTdHJva2VXaWR0aD17M30gLz5cbiAqICAgIDwvUmVhY3RGbG93PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IE1pbmlNYXAgPSBtZW1vKE1pbmlNYXBDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBSZXNpemVDb250cm9sKHsgbm9kZUlkLCBwb3NpdGlvbiwgdmFyaWFudCA9IFJlc2l6ZUNvbnRyb2xWYXJpYW50LkhhbmRsZSwgY2xhc3NOYW1lLCBzdHlsZSA9IHt9LCBjaGlsZHJlbiwgY29sb3IsIG1pbldpZHRoID0gMTAsIG1pbkhlaWdodCA9IDEwLCBtYXhXaWR0aCA9IE51bWJlci5NQVhfVkFMVUUsIG1heEhlaWdodCA9IE51bWJlci5NQVhfVkFMVUUsIGtlZXBBc3BlY3RSYXRpbyA9IGZhbHNlLCByZXNpemVEaXJlY3Rpb24sIHNob3VsZFJlc2l6ZSwgb25SZXNpemVTdGFydCwgb25SZXNpemUsIG9uUmVzaXplRW5kLCB9KSB7XG4gICAgY29uc3QgY29udGV4dE5vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICAgIGNvbnN0IGlkID0gdHlwZW9mIG5vZGVJZCA9PT0gJ3N0cmluZycgPyBub2RlSWQgOiBjb250ZXh0Tm9kZUlkO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCByZXNpemVDb250cm9sUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGRlZmF1bHRQb3NpdGlvbiA9IHZhcmlhbnQgPT09IFJlc2l6ZUNvbnRyb2xWYXJpYW50LkxpbmUgPyAncmlnaHQnIDogJ2JvdHRvbS1yaWdodCc7XG4gICAgY29uc3QgY29udHJvbFBvc2l0aW9uID0gcG9zaXRpb24gPz8gZGVmYXVsdFBvc2l0aW9uO1xuICAgIGNvbnN0IHJlc2l6ZXIgPSB1c2VSZWYobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFyZXNpemVDb250cm9sUmVmLmN1cnJlbnQgfHwgIWlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNpemVyLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJlc2l6ZXIuY3VycmVudCA9IFhZUmVzaXplcih7XG4gICAgICAgICAgICAgICAgZG9tTm9kZTogcmVzaXplQ29udHJvbFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIG5vZGVJZDogaWQsXG4gICAgICAgICAgICAgICAgZ2V0U3RvcmVJdGVtczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIG5vZGVPcmlnaW4sIGRvbU5vZGUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAgc25hcEdyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwVG9HcmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVEb21Ob2RlOiBkb21Ob2RlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IChjaGFuZ2UsIGNoaWxkQ2hhbmdlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRyaWdnZXJOb2RlQ2hhbmdlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRQb3NpdGlvbiA9IHsgeDogY2hhbmdlLngsIHk6IGNoYW5nZS55IH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUuZXhwYW5kUGFyZW50ICYmIG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IG5vZGUub3JpZ2luID8/IG5vZGVPcmlnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IGNoYW5nZS53aWR0aCA/PyBub2RlLm1lYXN1cmVkLndpZHRoID8/IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBjaGFuZ2UuaGVpZ2h0ID8/IG5vZGUubWVhc3VyZWQuaGVpZ2h0ID8/IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogbm9kZS5wYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjaGFuZ2UueCA/PyBub2RlLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBjaGFuZ2UueSA/PyBub2RlLnBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHsgd2lkdGgsIGhlaWdodCB9LCBub2RlLnBhcmVudElkLCBub2RlTG9va3VwLCBvcmlnaW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50RXhwYW5kQ2hhbmdlcyA9IGhhbmRsZUV4cGFuZFBhcmVudChbY2hpbGRdLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKC4uLnBhcmVudEV4cGFuZENoYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHdoZW4gdGhlIHBhcmVudCB3YXMgZXhwYW5kZWQgYnkgdGhlIGNoaWxkIG5vZGUsIGl0cyBwb3NpdGlvbiB3aWxsIGJlIGNsYW1wZWQgYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIDAsMCB3aGVuIG5vZGUgb3JpZ2luIGlzIDAsMCBhbmQgdG8gd2lkdGgsIGhlaWdodCBpZiBpdCdzIDEsMVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24ueCA9IGNoYW5nZS54ID8gTWF0aC5tYXgob3JpZ2luWzBdICogd2lkdGgsIGNoYW5nZS54KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbi55ID0gY2hhbmdlLnkgPyBNYXRoLm1heChvcmlnaW5bMV0gKiBoZWlnaHQsIGNoYW5nZS55KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFBvc2l0aW9uLnggIT09IHVuZGVmaW5lZCAmJiBuZXh0UG9zaXRpb24ueSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IC4uLm5leHRQb3NpdGlvbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChwb3NpdGlvbkNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS53aWR0aCAhPT0gdW5kZWZpbmVkICYmIGNoYW5nZS5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0QXR0cmlidXRlcyA9ICFyZXNpemVEaXJlY3Rpb24gPyB0cnVlIDogcmVzaXplRGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaW1lbnNpb25DaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RpbWVuc2lvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6aW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY2hhbmdlLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNoYW5nZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goZGltZW5zaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkQ2hhbmdlIG9mIGNoaWxkQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25DaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2hpbGRDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2gocG9zaXRpb25DaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uRW5kOiAoeyB3aWR0aCwgaGVpZ2h0IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uQ2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RpbWVuc2lvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXppbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkudHJpZ2dlck5vZGVDaGFuZ2VzKFtkaW1lbnNpb25DaGFuZ2VdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzaXplci5jdXJyZW50LnVwZGF0ZSh7XG4gICAgICAgICAgICBjb250cm9sUG9zaXRpb24sXG4gICAgICAgICAgICBib3VuZGFyaWVzOiB7XG4gICAgICAgICAgICAgICAgbWluV2lkdGgsXG4gICAgICAgICAgICAgICAgbWluSGVpZ2h0LFxuICAgICAgICAgICAgICAgIG1heFdpZHRoLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZWVwQXNwZWN0UmF0aW8sXG4gICAgICAgICAgICByZXNpemVEaXJlY3Rpb24sXG4gICAgICAgICAgICBvblJlc2l6ZVN0YXJ0LFxuICAgICAgICAgICAgb25SZXNpemUsXG4gICAgICAgICAgICBvblJlc2l6ZUVuZCxcbiAgICAgICAgICAgIHNob3VsZFJlc2l6ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXNpemVyLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGNvbnRyb2xQb3NpdGlvbixcbiAgICAgICAgbWluV2lkdGgsXG4gICAgICAgIG1pbkhlaWdodCxcbiAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgIG1heEhlaWdodCxcbiAgICAgICAga2VlcEFzcGVjdFJhdGlvLFxuICAgICAgICBvblJlc2l6ZVN0YXJ0LFxuICAgICAgICBvblJlc2l6ZSxcbiAgICAgICAgb25SZXNpemVFbmQsXG4gICAgICAgIHNob3VsZFJlc2l6ZSxcbiAgICBdKTtcbiAgICBjb25zdCBwb3NpdGlvbkNsYXNzTmFtZXMgPSBjb250cm9sUG9zaXRpb24uc3BsaXQoJy0nKTtcbiAgICBjb25zdCBjb2xvclN0eWxlUHJvcCA9IHZhcmlhbnQgPT09IFJlc2l6ZUNvbnRyb2xWYXJpYW50LkxpbmUgPyAnYm9yZGVyQ29sb3InIDogJ2JhY2tncm91bmRDb2xvcic7XG4gICAgY29uc3QgY29udHJvbFN0eWxlID0gY29sb3IgPyB7IC4uLnN0eWxlLCBbY29sb3JTdHlsZVByb3BdOiBjb2xvciB9IDogc3R5bGU7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fcmVzaXplLWNvbnRyb2wnLCAnbm9kcmFnJywgLi4ucG9zaXRpb25DbGFzc05hbWVzLCB2YXJpYW50LCBjbGFzc05hbWVdKSwgcmVmOiByZXNpemVDb250cm9sUmVmLCBzdHlsZTogY29udHJvbFN0eWxlLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuLyoqXG4gKiBUbyBjcmVhdGUgeW91ciBvd24gcmVzaXppbmcgVUksIHlvdSBjYW4gdXNlIHRoZSBgTm9kZVJlc2l6ZUNvbnRyb2xgIGNvbXBvbmVudCB3aGVyZSB5b3UgY2FuIHBhc3MgY2hpbGRyZW4gKHN1Y2ggYXMgaWNvbnMpLlxuICogQHB1YmxpY1xuICpcbiAqL1xuY29uc3QgTm9kZVJlc2l6ZUNvbnRyb2wgPSBtZW1vKFJlc2l6ZUNvbnRyb2wpO1xuXG4vKipcbiAqIFRoZSBgPE5vZGVSZXNpemVyIC8+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gYWRkIGEgcmVzaXplIGZ1bmN0aW9uYWxpdHkgdG8geW91clxuICogbm9kZXMuIEl0IHJlbmRlcnMgZHJhZ2dhYmxlIGNvbnRyb2xzIGFyb3VuZCB0aGUgbm9kZSB0byByZXNpemUgaW4gYWxsIGRpcmVjdGlvbnMuXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqYGBganN4XG4gKmltcG9ydCB7IG1lbW8gfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IEhhbmRsZSwgUG9zaXRpb24sIE5vZGVSZXNpemVyIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpmdW5jdGlvbiBSZXNpemFibGVOb2RlKHsgZGF0YSB9KSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDw+XG4gKiAgICAgIDxOb2RlUmVzaXplciBtaW5XaWR0aD17MTAwfSBtaW5IZWlnaHQ9ezMwfSAvPlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJ0YXJnZXRcIiBwb3NpdGlvbj17UG9zaXRpb24uTGVmdH0gLz5cbiAqICAgICAgPGRpdiBzdHlsZT17eyBwYWRkaW5nOiAxMCB9fT57ZGF0YS5sYWJlbH08L2Rpdj5cbiAqICAgICAgPEhhbmRsZSB0eXBlPVwic291cmNlXCIgcG9zaXRpb249e1Bvc2l0aW9uLlJpZ2h0fSAvPlxuICogICAgPC8+XG4gKiAgKTtcbiAqfTtcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IG1lbW8oUmVzaXphYmxlTm9kZSk7XG4gKmBgYFxuICovXG5mdW5jdGlvbiBOb2RlUmVzaXplcih7IG5vZGVJZCwgaXNWaXNpYmxlID0gdHJ1ZSwgaGFuZGxlQ2xhc3NOYW1lLCBoYW5kbGVTdHlsZSwgbGluZUNsYXNzTmFtZSwgbGluZVN0eWxlLCBjb2xvciwgbWluV2lkdGggPSAxMCwgbWluSGVpZ2h0ID0gMTAsIG1heFdpZHRoID0gTnVtYmVyLk1BWF9WQUxVRSwgbWF4SGVpZ2h0ID0gTnVtYmVyLk1BWF9WQUxVRSwga2VlcEFzcGVjdFJhdGlvID0gZmFsc2UsIHNob3VsZFJlc2l6ZSwgb25SZXNpemVTdGFydCwgb25SZXNpemUsIG9uUmVzaXplRW5kLCB9KSB7XG4gICAgaWYgKCFpc1Zpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1hZX1JFU0laRVJfTElORV9QT1NJVElPTlMubWFwKChwb3NpdGlvbikgPT4gKGpzeChOb2RlUmVzaXplQ29udHJvbCwgeyBjbGFzc05hbWU6IGxpbmVDbGFzc05hbWUsIHN0eWxlOiBsaW5lU3R5bGUsIG5vZGVJZDogbm9kZUlkLCBwb3NpdGlvbjogcG9zaXRpb24sIHZhcmlhbnQ6IFJlc2l6ZUNvbnRyb2xWYXJpYW50LkxpbmUsIGNvbG9yOiBjb2xvciwgbWluV2lkdGg6IG1pbldpZHRoLCBtaW5IZWlnaHQ6IG1pbkhlaWdodCwgbWF4V2lkdGg6IG1heFdpZHRoLCBtYXhIZWlnaHQ6IG1heEhlaWdodCwgb25SZXNpemVTdGFydDogb25SZXNpemVTdGFydCwga2VlcEFzcGVjdFJhdGlvOiBrZWVwQXNwZWN0UmF0aW8sIHNob3VsZFJlc2l6ZTogc2hvdWxkUmVzaXplLCBvblJlc2l6ZTogb25SZXNpemUsIG9uUmVzaXplRW5kOiBvblJlc2l6ZUVuZCB9LCBwb3NpdGlvbikpKSwgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TLm1hcCgocG9zaXRpb24pID0+IChqc3goTm9kZVJlc2l6ZUNvbnRyb2wsIHsgY2xhc3NOYW1lOiBoYW5kbGVDbGFzc05hbWUsIHN0eWxlOiBoYW5kbGVTdHlsZSwgbm9kZUlkOiBub2RlSWQsIHBvc2l0aW9uOiBwb3NpdGlvbiwgY29sb3I6IGNvbG9yLCBtaW5XaWR0aDogbWluV2lkdGgsIG1pbkhlaWdodDogbWluSGVpZ2h0LCBtYXhXaWR0aDogbWF4V2lkdGgsIG1heEhlaWdodDogbWF4SGVpZ2h0LCBvblJlc2l6ZVN0YXJ0OiBvblJlc2l6ZVN0YXJ0LCBrZWVwQXNwZWN0UmF0aW86IGtlZXBBc3BlY3RSYXRpbywgc2hvdWxkUmVzaXplOiBzaG91bGRSZXNpemUsIG9uUmVzaXplOiBvblJlc2l6ZSwgb25SZXNpemVFbmQ6IG9uUmVzaXplRW5kIH0sIHBvc2l0aW9uKSkpXSB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yID0gKHN0YXRlKSA9PiBzdGF0ZS5kb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fcmVuZGVyZXInKTtcbmZ1bmN0aW9uIE5vZGVUb29sYmFyUG9ydGFsKHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHdyYXBwZXJSZWYgPSB1c2VTdG9yZShzZWxlY3Rvcik7XG4gICAgaWYgKCF3cmFwcGVyUmVmKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCB3cmFwcGVyUmVmKTtcbn1cblxuY29uc3Qgbm9kZUVxdWFsaXR5Rm4gPSAoYSwgYikgPT4gYT8uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCAhPT0gYj8uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCB8fFxuICAgIGE/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnkgIT09IGI/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnkgfHxcbiAgICBhPy5tZWFzdXJlZC53aWR0aCAhPT0gYj8ubWVhc3VyZWQud2lkdGggfHxcbiAgICBhPy5tZWFzdXJlZC5oZWlnaHQgIT09IGI/Lm1lYXN1cmVkLmhlaWdodCB8fFxuICAgIGE/LnNlbGVjdGVkICE9PSBiPy5zZWxlY3RlZCB8fFxuICAgIGE/LmludGVybmFscy56ICE9PSBiPy5pbnRlcm5hbHMuejtcbmNvbnN0IG5vZGVzRXF1YWxpdHlGbiA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCBub2RlXSBvZiBhKSB7XG4gICAgICAgIGlmIChub2RlRXF1YWxpdHlGbihub2RlLCBiLmdldChrZXkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IHN0b3JlU2VsZWN0b3IgPSAoc3RhdGUpID0+ICh7XG4gICAgeDogc3RhdGUudHJhbnNmb3JtWzBdLFxuICAgIHk6IHN0YXRlLnRyYW5zZm9ybVsxXSxcbiAgICB6b29tOiBzdGF0ZS50cmFuc2Zvcm1bMl0sXG4gICAgc2VsZWN0ZWROb2Rlc0NvdW50OiBzdGF0ZS5ub2Rlcy5maWx0ZXIoKG5vZGUpID0+IG5vZGUuc2VsZWN0ZWQpLmxlbmd0aCxcbn0pO1xuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBjYW4gcmVuZGVyIGEgdG9vbGJhciBvciB0b29sdGlwIHRvIG9uZSBzaWRlIG9mIGEgY3VzdG9tIG5vZGUuIFRoaXNcbiAqIHRvb2xiYXIgZG9lc24ndCBzY2FsZSB3aXRoIHRoZSB2aWV3cG9ydCBzbyB0aGF0IHRoZSBjb250ZW50IGlzIGFsd2F5cyB2aXNpYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgbWVtbyB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgSGFuZGxlLCBQb3NpdGlvbiwgTm9kZVRvb2xiYXIgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIEN1c3RvbU5vZGUoeyBkYXRhIH0pIHtcbiAqICByZXR1cm4gKFxuICogICAgPD5cbiAqICAgICAgPE5vZGVUb29sYmFyIGlzVmlzaWJsZT17ZGF0YS50b29sYmFyVmlzaWJsZX0gcG9zaXRpb249e2RhdGEudG9vbGJhclBvc2l0aW9ufT5cbiAqICAgICAgICA8YnV0dG9uPmRlbGV0ZTwvYnV0dG9uPlxuICogICAgICAgIDxidXR0b24+Y29weTwvYnV0dG9uPlxuICogICAgICAgIDxidXR0b24+ZXhwYW5kPC9idXR0b24+XG4gKiAgICAgIDwvTm9kZVRvb2xiYXI+XG4gKlxuICogICAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6ICcxMHB4IDIwcHgnIH19PlxuICogICAgICAgIHtkYXRhLmxhYmVsfVxuICogICAgICA8L2Rpdj5cbiAqXG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInRhcmdldFwiIHBvc2l0aW9uPXtQb3NpdGlvbi5MZWZ0fSAvPlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJzb3VyY2VcIiBwb3NpdGlvbj17UG9zaXRpb24uUmlnaHR9IC8+XG4gKiAgICA8Lz5cbiAqICApO1xuICp9O1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgbWVtbyhDdXN0b21Ob2RlKTtcbiAqYGBgXG4gKiBAcmVtYXJrcyBCeSBkZWZhdWx0LCB0aGUgdG9vbGJhciBpcyBvbmx5IHZpc2libGUgd2hlbiBhIG5vZGUgaXMgc2VsZWN0ZWQuIElmIG11bHRpcGxlXG4gKiBub2RlcyBhcmUgc2VsZWN0ZWQgaXQgd2lsbCBub3QgYmUgdmlzaWJsZSB0byBwcmV2ZW50IG92ZXJsYXBwaW5nIHRvb2xiYXJzIG9yXG4gKiBjbHV0dGVyLiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IgYnkgc2V0dGluZyB0aGUgYGlzVmlzaWJsZWAgcHJvcCB0byBgdHJ1ZWAuXG4gKi9cbmZ1bmN0aW9uIE5vZGVUb29sYmFyKHsgbm9kZUlkLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBzdHlsZSwgaXNWaXNpYmxlLCBwb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgb2Zmc2V0ID0gMTAsIGFsaWduID0gJ2NlbnRlcicsIC4uLnJlc3QgfSkge1xuICAgIGNvbnN0IGNvbnRleHROb2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBub2Rlc1NlbGVjdG9yID0gdXNlQ2FsbGJhY2soKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGVJZHMgPSBBcnJheS5pc0FycmF5KG5vZGVJZCkgPyBub2RlSWQgOiBbbm9kZUlkIHx8IGNvbnRleHROb2RlSWQgfHwgJyddO1xuICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGVzID0gbm9kZUlkcy5yZWR1Y2UoKHJlcywgaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzdGF0ZS5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHJlcy5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBuZXcgTWFwKCkpO1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxOb2RlcztcbiAgICB9LCBbbm9kZUlkLCBjb250ZXh0Tm9kZUlkXSk7XG4gICAgY29uc3Qgbm9kZXMgPSB1c2VTdG9yZShub2Rlc1NlbGVjdG9yLCBub2Rlc0VxdWFsaXR5Rm4pO1xuICAgIGNvbnN0IHsgeCwgeSwgem9vbSwgc2VsZWN0ZWROb2Rlc0NvdW50IH0gPSB1c2VTdG9yZShzdG9yZVNlbGVjdG9yLCBzaGFsbG93KTtcbiAgICAvLyBpZiBpc1Zpc2libGUgaXMgbm90IHNldCwgd2Ugc2hvdyB0aGUgdG9vbGJhciBvbmx5IGlmIGl0cyBub2RlIGlzIHNlbGVjdGVkIGFuZCBubyBvdGhlciBub2RlIGlzIHNlbGVjdGVkXG4gICAgY29uc3QgaXNBY3RpdmUgPSB0eXBlb2YgaXNWaXNpYmxlID09PSAnYm9vbGVhbidcbiAgICAgICAgPyBpc1Zpc2libGVcbiAgICAgICAgOiBub2Rlcy5zaXplID09PSAxICYmIG5vZGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZT8uc2VsZWN0ZWQgJiYgc2VsZWN0ZWROb2Rlc0NvdW50ID09PSAxO1xuICAgIGlmICghaXNBY3RpdmUgfHwgIW5vZGVzLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVSZWN0ID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhub2Rlcyk7XG4gICAgY29uc3Qgbm9kZXNBcnJheSA9IEFycmF5LmZyb20obm9kZXMudmFsdWVzKCkpO1xuICAgIGNvbnN0IHpJbmRleCA9IE1hdGgubWF4KC4uLm5vZGVzQXJyYXkubWFwKChub2RlKSA9PiBub2RlLmludGVybmFscy56ICsgMSkpO1xuICAgIGNvbnN0IHdyYXBwZXJTdHlsZSA9IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHRyYW5zZm9ybTogZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0obm9kZVJlY3QsIHsgeCwgeSwgem9vbSB9LCBwb3NpdGlvbiwgb2Zmc2V0LCBhbGlnbiksXG4gICAgICAgIHpJbmRleCxcbiAgICAgICAgLi4uc3R5bGUsXG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChOb2RlVG9vbGJhclBvcnRhbCwgeyBjaGlsZHJlbjoganN4KFwiZGl2XCIsIHsgc3R5bGU6IHdyYXBwZXJTdHlsZSwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX25vZGUtdG9vbGJhcicsIGNsYXNzTmFtZV0pLCAuLi5yZXN0LCBcImRhdGEtaWRcIjogbm9kZXNBcnJheS5yZWR1Y2UoKGFjYywgbm9kZSkgPT4gYCR7YWNjfSR7bm9kZS5pZH0gYCwgJycpLnRyaW0oKSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pIH0pKTtcbn1cblxuZXhwb3J0IHsgQmFja2dyb3VuZCwgQmFja2dyb3VuZFZhcmlhbnQsIEJhc2VFZGdlLCBCZXppZXJFZGdlLCBDb250cm9sQnV0dG9uLCBDb250cm9scywgRWRnZUxhYmVsUmVuZGVyZXIsIEVkZ2VUZXh0LCBIYW5kbGUsIE1pbmlNYXAsIE5vZGVSZXNpemVDb250cm9sLCBOb2RlUmVzaXplciwgTm9kZVRvb2xiYXIsIFBhbmVsLCBpbmRleCBhcyBSZWFjdEZsb3csIFJlYWN0Rmxvd1Byb3ZpZGVyLCBTaW1wbGVCZXppZXJFZGdlLCBTbW9vdGhTdGVwRWRnZSwgU3RlcEVkZ2UsIFN0cmFpZ2h0RWRnZSwgVmlld3BvcnRQb3J0YWwsIGFwcGx5RWRnZUNoYW5nZXMsIGFwcGx5Tm9kZUNoYW5nZXMsIGdldFNpbXBsZUJlemllclBhdGgsIGlzRWRnZSwgaXNOb2RlLCB1c2VDb25uZWN0aW9uLCB1c2VFZGdlcywgdXNlRWRnZXNTdGF0ZSwgdXNlSGFuZGxlQ29ubmVjdGlvbnMsIHVzZUludGVybmFsTm9kZSwgdXNlS2V5UHJlc3MsIHVzZU5vZGVDb25uZWN0aW9ucywgdXNlTm9kZUlkLCB1c2VOb2RlcywgdXNlTm9kZXNEYXRhLCB1c2VOb2Rlc0luaXRpYWxpemVkLCB1c2VOb2Rlc1N0YXRlLCB1c2VPblNlbGVjdGlvbkNoYW5nZSwgdXNlT25WaWV3cG9ydENoYW5nZSwgdXNlUmVhY3RGbG93LCB1c2VTdG9yZSwgdXNlU3RvcmVBcGksIHVzZVVwZGF0ZU5vZGVJbnRlcm5hbHMsIHVzZVZpZXdwb3J0IH07XG4iXSwibmFtZXMiOlsianN4cyIsIkZyYWdtZW50IiwianN4IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VNZW1vIiwiZm9yd2FyZFJlZiIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlQ2FsbGJhY2siLCJtZW1vIiwiY2MiLCJlcnJvck1lc3NhZ2VzIiwiaW5maW5pdGVFeHRlbnQiLCJpc0lucHV0RE9NTm9kZSIsImdldFZpZXdwb3J0Rm9yQm91bmRzIiwicG9pbnRUb1JlbmRlcmVyUG9pbnQiLCJyZW5kZXJlclBvaW50VG9Qb2ludCIsImlzTm9kZUJhc2UiLCJpc0VkZ2VCYXNlIiwiZ2V0RWxlbWVudHNUb1JlbW92ZSIsImlzUmVjdE9iamVjdCIsIm5vZGVUb1JlY3QiLCJnZXRPdmVybGFwcGluZ0FyZWEiLCJnZXROb2Rlc0JvdW5kcyIsIndpdGhSZXNvbHZlcnMiLCJldmFsdWF0ZUFic29sdXRlUG9zaXRpb24iLCJnZXREaW1lbnNpb25zIiwiWFlQYW5ab29tIiwiUGFuT25TY3JvbGxNb2RlIiwiU2VsZWN0aW9uTW9kZSIsImdldEV2ZW50UG9zaXRpb24iLCJnZXROb2Rlc0luc2lkZSIsImFyZVNldHNFcXVhbCIsIlhZRHJhZyIsInNuYXBQb3NpdGlvbiIsImNhbGN1bGF0ZU5vZGVQb3NpdGlvbiIsIlBvc2l0aW9uIiwiQ29ubmVjdGlvbk1vZGUiLCJpc01vdXNlRXZlbnQiLCJYWUhhbmRsZSIsImdldEhvc3RGb3JFbGVtZW50IiwiYWRkRWRnZSIsImdldEludGVybmFsTm9kZXNCb3VuZHMiLCJpc051bWVyaWMiLCJub2RlSGFzRGltZW5zaW9ucyIsImdldE5vZGVEaW1lbnNpb25zIiwiZWxlbWVudFNlbGVjdGlvbktleXMiLCJpc0VkZ2VWaXNpYmxlIiwiTWFya2VyVHlwZSIsImNyZWF0ZU1hcmtlcklkcyIsImdldEJlemllckVkZ2VDZW50ZXIiLCJnZXRTbW9vdGhTdGVwUGF0aCIsImdldFN0cmFpZ2h0UGF0aCIsImdldEJlemllclBhdGgiLCJnZXRFZGdlUG9zaXRpb24iLCJnZXRFbGV2YXRlZEVkZ2VaSW5kZXgiLCJnZXRNYXJrZXJJZCIsImdldENvbm5lY3Rpb25TdGF0dXMiLCJDb25uZWN0aW9uTGluZVR5cGUiLCJ1cGRhdGVDb25uZWN0aW9uTG9va3VwIiwiYWRvcHRVc2VyTm9kZXMiLCJpbml0aWFsQ29ubmVjdGlvbiIsImRldldhcm4iLCJ1cGRhdGVOb2RlSW50ZXJuYWxzIiwidXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMiLCJoYW5kbGVFeHBhbmRQYXJlbnQiLCJwYW5CeSIsImZpdFZpZXdwb3J0IiwiaXNNYWNPcyIsImFyZUNvbm5lY3Rpb25NYXBzRXF1YWwiLCJoYW5kbGVDb25uZWN0aW9uQ2hhbmdlIiwic2hhbGxvd05vZGVEYXRhIiwiWFlNaW5pbWFwIiwiZ2V0Qm91bmRzT2ZSZWN0cyIsIlJlc2l6ZUNvbnRyb2xWYXJpYW50IiwiWFlSZXNpemVyIiwiWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUyIsIlhZX1JFU0laRVJfSEFORExFX1BPU0lUSU9OUyIsImdldE5vZGVUb29sYmFyVHJhbnNmb3JtIiwiZ2V0Q29ubmVjdGVkRWRnZXMiLCJnZXRFZGdlQ2VudGVyIiwiZ2V0SW5jb21lcnMiLCJnZXRPdXRnb2VycyIsInJlY29ubmVjdEVkZ2UiLCJ1c2VTdG9yZVdpdGhFcXVhbGl0eUZuIiwiY3JlYXRlV2l0aEVxdWFsaXR5Rm4iLCJzaGFsbG93IiwiY3JlYXRlUG9ydGFsIiwiU3RvcmVDb250ZXh0IiwiUHJvdmlkZXIkMSIsIlByb3ZpZGVyIiwienVzdGFuZEVycm9yTWVzc2FnZSIsInVzZVN0b3JlIiwic2VsZWN0b3IiLCJlcXVhbGl0eUZuIiwic3RvcmUiLCJFcnJvciIsInVzZVN0b3JlQXBpIiwiZ2V0U3RhdGUiLCJzZXRTdGF0ZSIsInN1YnNjcmliZSIsInN0eWxlIiwiZGlzcGxheSIsImFyaWFMaXZlU3R5bGUiLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwibWFyZ2luIiwiYm9yZGVyIiwicGFkZGluZyIsIm92ZXJmbG93IiwiY2xpcCIsImNsaXBQYXRoIiwiQVJJQV9OT0RFX0RFU0NfS0VZIiwiQVJJQV9FREdFX0RFU0NfS0VZIiwiQVJJQV9MSVZFX01FU1NBR0UiLCJzZWxlY3RvciRvIiwicyIsImFyaWFMaXZlTWVzc2FnZSIsIkFyaWFMaXZlTWVzc2FnZSIsInJmSWQiLCJpZCIsImNoaWxkcmVuIiwiQTExeURlc2NyaXB0aW9ucyIsImRpc2FibGVLZXlib2FyZEExMXkiLCJzZWxlY3RvciRuIiwidXNlclNlbGVjdGlvbkFjdGl2ZSIsIlBhbmVsIiwiY2xhc3NOYW1lIiwicmVzdCIsInJlZiIsInBvaW50ZXJFdmVudHMiLCJwb3NpdGlvbkNsYXNzZXMiLCJzcGxpdCIsImRpc3BsYXlOYW1lIiwiQXR0cmlidXRpb24iLCJwcm9PcHRpb25zIiwiaGlkZUF0dHJpYnV0aW9uIiwiaHJlZiIsInRhcmdldCIsInJlbCIsInNlbGVjdG9yJG0iLCJzZWxlY3RlZE5vZGVzIiwic2VsZWN0ZWRFZGdlcyIsIm5vZGUiLCJub2RlTG9va3VwIiwic2VsZWN0ZWQiLCJwdXNoIiwiaW50ZXJuYWxzIiwidXNlck5vZGUiLCJlZGdlIiwiZWRnZUxvb2t1cCIsInNlbGVjdElkIiwib2JqIiwiYXJlRXF1YWwiLCJhIiwiYiIsIm1hcCIsIlNlbGVjdGlvbkxpc3RlbmVySW5uZXIiLCJvblNlbGVjdGlvbkNoYW5nZSIsInBhcmFtcyIsIm5vZGVzIiwiZWRnZXMiLCJvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzIiwiZm9yRWFjaCIsImZuIiwiY2hhbmdlU2VsZWN0b3IiLCJTZWxlY3Rpb25MaXN0ZW5lciIsInN0b3JlSGFzU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMiLCJkZWZhdWx0Tm9kZU9yaWdpbiIsImRlZmF1bHRWaWV3cG9ydCIsIngiLCJ5Iiwiem9vbSIsInJlYWN0Rmxvd0ZpZWxkc1RvVHJhY2siLCJmaWVsZHNUb1RyYWNrIiwic2VsZWN0b3IkbCIsInNldE5vZGVzIiwic2V0RWRnZXMiLCJzZXRNaW5ab29tIiwic2V0TWF4Wm9vbSIsInNldFRyYW5zbGF0ZUV4dGVudCIsInNldE5vZGVFeHRlbnQiLCJyZXNldCIsInNldERlZmF1bHROb2Rlc0FuZEVkZ2VzIiwic2V0UGFuZUNsaWNrRGlzdGFuY2UiLCJpbml0UHJldlZhbHVlcyIsInRyYW5zbGF0ZUV4dGVudCIsIm5vZGVPcmlnaW4iLCJtaW5ab29tIiwibWF4Wm9vbSIsImVsZW1lbnRzU2VsZWN0YWJsZSIsIm5vUGFuQ2xhc3NOYW1lIiwicGFuZUNsaWNrRGlzdGFuY2UiLCJTdG9yZVVwZGF0ZXIiLCJwcm9wcyIsImRlZmF1bHROb2RlcyIsImRlZmF1bHRFZGdlcyIsInByZXZpb3VzRmllbGRzIiwiY3VycmVudCIsImZpZWxkTmFtZSIsImZpZWxkVmFsdWUiLCJwcmV2aW91c0ZpZWxkVmFsdWUiLCJmaXRWaWV3UXVldWVkIiwiZml0Vmlld09wdGlvbnMiLCJnZXRNZWRpYVF1ZXJ5Iiwid2luZG93IiwibWF0Y2hNZWRpYSIsInVzZUNvbG9yTW9kZUNsYXNzIiwiY29sb3JNb2RlIiwiY29sb3JNb2RlQ2xhc3MiLCJzZXRDb2xvck1vZGVDbGFzcyIsIm1lZGlhUXVlcnkiLCJ1cGRhdGVDb2xvck1vZGVDbGFzcyIsIm1hdGNoZXMiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRlZmF1bHREb2MiLCJkb2N1bWVudCIsInVzZUtleVByZXNzIiwia2V5Q29kZSIsIm9wdGlvbnMiLCJhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllciIsImtleVByZXNzZWQiLCJzZXRLZXlQcmVzc2VkIiwibW9kaWZpZXJQcmVzc2VkIiwicHJlc3NlZEtleXMiLCJTZXQiLCJrZXlDb2RlcyIsImtleXNUb1dhdGNoIiwia2V5Q29kZUFyciIsIkFycmF5IiwiaXNBcnJheSIsImtleXMiLCJmaWx0ZXIiLCJrYyIsInJlcGxhY2UiLCJrZXlzRmxhdCIsInJlZHVjZSIsInJlcyIsIml0ZW0iLCJjb25jYXQiLCJkb3duSGFuZGxlciIsImV2ZW50IiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsInByZXZlbnRBY3Rpb24iLCJrZXlPckNvZGUiLCJ1c2VLZXlPckNvZGUiLCJjb2RlIiwiYWRkIiwiaXNNYXRjaGluZ0tleSIsImNvbXBvc2VkUGF0aCIsImlzSW50ZXJhY3RpdmVFbGVtZW50Iiwibm9kZU5hbWUiLCJwcmV2ZW50RGVmYXVsdCIsInVwSGFuZGxlciIsImNsZWFyIiwiZGVsZXRlIiwia2V5IiwicmVzZXRIYW5kbGVyIiwiaXNVcCIsImxlbmd0aCIsInNpemUiLCJzb21lIiwiZXZlcnkiLCJrIiwiaGFzIiwiZXZlbnRDb2RlIiwiaW5jbHVkZXMiLCJ1c2VWaWV3cG9ydEhlbHBlciIsInpvb21JbiIsInBhblpvb20iLCJzY2FsZUJ5IiwiZHVyYXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInpvb21PdXQiLCJ6b29tVG8iLCJ6b29tTGV2ZWwiLCJzY2FsZVRvIiwiZ2V0Wm9vbSIsInRyYW5zZm9ybSIsInNldFZpZXdwb3J0Iiwidmlld3BvcnQiLCJ0WCIsInRZIiwidFpvb20iLCJnZXRWaWV3cG9ydCIsInNldENlbnRlciIsIm5leHRab29tIiwiY2VudGVyWCIsImNlbnRlclkiLCJmaXRCb3VuZHMiLCJib3VuZHMiLCJzY3JlZW5Ub0Zsb3dQb3NpdGlvbiIsImNsaWVudFBvc2l0aW9uIiwic25hcEdyaWQiLCJzbmFwVG9HcmlkIiwiZG9tTm9kZSIsImRvbVgiLCJkb21ZIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY29ycmVjdGVkUG9zaXRpb24iLCJfc25hcEdyaWQiLCJfc25hcFRvR3JpZCIsImZsb3dUb1NjcmVlblBvc2l0aW9uIiwiZmxvd1Bvc2l0aW9uIiwicmVuZGVyZXJQb3NpdGlvbiIsImFwcGx5Q2hhbmdlcyIsImNoYW5nZXMiLCJlbGVtZW50cyIsInVwZGF0ZWRFbGVtZW50cyIsImNoYW5nZXNNYXAiLCJNYXAiLCJhZGRJdGVtQ2hhbmdlcyIsImNoYW5nZSIsInR5cGUiLCJzZXQiLCJlbGVtZW50Q2hhbmdlcyIsImdldCIsImVsZW1lbnQiLCJ1cGRhdGVkRWxlbWVudCIsImFwcGx5Q2hhbmdlIiwiaW5kZXgiLCJ1bmRlZmluZWQiLCJzcGxpY2UiLCJkcmFnZ2luZyIsImRpbWVuc2lvbnMiLCJtZWFzdXJlZCIsInNldEF0dHJpYnV0ZXMiLCJyZXNpemluZyIsImFwcGx5Tm9kZUNoYW5nZXMiLCJhcHBseUVkZ2VDaGFuZ2VzIiwiY3JlYXRlU2VsZWN0aW9uQ2hhbmdlIiwiZ2V0U2VsZWN0aW9uQ2hhbmdlcyIsIml0ZW1zIiwic2VsZWN0ZWRJZHMiLCJtdXRhdGVJdGVtIiwid2lsbEJlU2VsZWN0ZWQiLCJnZXRFbGVtZW50c0RpZmZDaGFuZ2VzIiwibG9va3VwIiwiaXRlbXNMb29rdXAiLCJlbnRyaWVzIiwibG9va3VwSXRlbSIsInN0b3JlSXRlbSIsIm5leHROb2RlIiwiZWxlbWVudFRvUmVtb3ZlQ2hhbmdlIiwiaXNOb2RlIiwiaXNFZGdlIiwiZml4ZWRGb3J3YXJkUmVmIiwicmVuZGVyIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZVF1ZXVlIiwicnVuUXVldWUiLCJzZXJpYWwiLCJzZXRTZXJpYWwiLCJCaWdJbnQiLCJxdWV1ZSIsImNyZWF0ZVF1ZXVlIiwibiIsInF1ZXVlSXRlbXMiLCJjYiIsIkJhdGNoQ29udGV4dCIsIkJhdGNoUHJvdmlkZXIiLCJub2RlUXVldWVIYW5kbGVyIiwiaGFzRGVmYXVsdE5vZGVzIiwib25Ob2Rlc0NoYW5nZSIsIm5leHQiLCJwYXlsb2FkIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibm9kZVF1ZXVlIiwiZWRnZVF1ZXVlSGFuZGxlciIsImhhc0RlZmF1bHRFZGdlcyIsIm9uRWRnZXNDaGFuZ2UiLCJlZGdlUXVldWUiLCJ2YWx1ZSIsInVzZUJhdGNoQ29udGV4dCIsImJhdGNoQ29udGV4dCIsInNlbGVjdG9yJGsiLCJ1c2VSZWFjdEZsb3ciLCJ2aWV3cG9ydEhlbHBlciIsInZpZXdwb3J0SW5pdGlhbGl6ZWQiLCJnZW5lcmFsSGVscGVyIiwiZ2V0SW50ZXJuYWxOb2RlIiwiZ2V0Tm9kZVJlY3QiLCJub2RlVG9Vc2UiLCJwYXJlbnRJZCIsIm5vZGVXaXRoUG9zaXRpb24iLCJ1cGRhdGVOb2RlIiwibm9kZVVwZGF0ZSIsInByZXZOb2RlcyIsInVwZGF0ZUVkZ2UiLCJlZGdlVXBkYXRlIiwicHJldkVkZ2VzIiwibmV4dEVkZ2UiLCJnZXROb2RlcyIsImdldE5vZGUiLCJnZXRFZGdlcyIsImUiLCJnZXRFZGdlIiwiYWRkTm9kZXMiLCJuZXdOb2RlcyIsImFkZEVkZ2VzIiwibmV3RWRnZXMiLCJ0b09iamVjdCIsImRlbGV0ZUVsZW1lbnRzIiwibm9kZXNUb1JlbW92ZSIsImVkZ2VzVG9SZW1vdmUiLCJvbk5vZGVzRGVsZXRlIiwib25FZGdlc0RlbGV0ZSIsInRyaWdnZXJOb2RlQ2hhbmdlcyIsInRyaWdnZXJFZGdlQ2hhbmdlcyIsIm9uRGVsZXRlIiwib25CZWZvcmVEZWxldGUiLCJtYXRjaGluZ05vZGVzIiwibWF0Y2hpbmdFZGdlcyIsImhhc01hdGNoaW5nRWRnZXMiLCJoYXNNYXRjaGluZ05vZGVzIiwiZWRnZUNoYW5nZXMiLCJub2RlQ2hhbmdlcyIsImRlbGV0ZWROb2RlcyIsImRlbGV0ZWRFZGdlcyIsImdldEludGVyc2VjdGluZ05vZGVzIiwibm9kZU9yUmVjdCIsInBhcnRpYWxseSIsImlzUmVjdCIsIm5vZGVSZWN0IiwiaGFzTm9kZXNPcHRpb24iLCJpbnRlcm5hbE5vZGUiLCJwb3NpdGlvbkFic29sdXRlIiwiY3Vyck5vZGVSZWN0Iiwib3ZlcmxhcHBpbmdBcmVhIiwicGFydGlhbGx5VmlzaWJsZSIsImlzTm9kZUludGVyc2VjdGluZyIsImFyZWEiLCJ1cGRhdGVOb2RlRGF0YSIsImRhdGFVcGRhdGUiLCJuZXh0RGF0YSIsImRhdGEiLCJ1cGRhdGVFZGdlRGF0YSIsImdldEhhbmRsZUNvbm5lY3Rpb25zIiwibm9kZUlkIiwiZnJvbSIsImNvbm5lY3Rpb25Mb29rdXAiLCJ2YWx1ZXMiLCJnZXROb2RlQ29ubmVjdGlvbnMiLCJoYW5kbGVJZCIsImZpdFZpZXciLCJmaXRWaWV3UmVzb2x2ZXIiLCJwcm9taXNlIiwid2luJDEiLCJ1c2VHbG9iYWxLZXlIYW5kbGVyIiwiZGVsZXRlS2V5Q29kZSIsIm11bHRpU2VsZWN0aW9uS2V5Q29kZSIsImRlbGV0ZUtleVByZXNzZWQiLCJtdWx0aVNlbGVjdGlvbktleVByZXNzZWQiLCJub2Rlc1NlbGVjdGlvbkFjdGl2ZSIsIm11bHRpU2VsZWN0aW9uQWN0aXZlIiwidXNlUmVzaXplSGFuZGxlciIsInVwZGF0ZURpbWVuc2lvbnMiLCJvbkVycm9yIiwicmVzaXplT2JzZXJ2ZXIiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJ1bm9ic2VydmUiLCJjb250YWluZXJTdHlsZSIsInRvcCIsImxlZnQiLCJzZWxlY3RvciRqIiwibGliIiwiWm9vbVBhbmUiLCJvblBhbmVDb250ZXh0TWVudSIsInpvb21PblNjcm9sbCIsInpvb21PblBpbmNoIiwicGFuT25TY3JvbGwiLCJwYW5PblNjcm9sbFNwZWVkIiwicGFuT25TY3JvbGxNb2RlIiwiRnJlZSIsInpvb21PbkRvdWJsZUNsaWNrIiwicGFuT25EcmFnIiwiem9vbUFjdGl2YXRpb25LZXlDb2RlIiwicHJldmVudFNjcm9sbGluZyIsIm5vV2hlZWxDbGFzc05hbWUiLCJvblZpZXdwb3J0Q2hhbmdlIiwiaXNDb250cm9sbGVkVmlld3BvcnQiLCJ6b29tUGFuZSIsInpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCIsIm9uVHJhbnNmb3JtQ2hhbmdlIiwib25EcmFnZ2luZ0NoYW5nZSIsInBhbmVEcmFnZ2luZyIsIm9uUGFuWm9vbVN0YXJ0IiwidnAiLCJvblZpZXdwb3J0Q2hhbmdlU3RhcnQiLCJvbk1vdmVTdGFydCIsIm9uUGFuWm9vbSIsIm9uTW92ZSIsIm9uUGFuWm9vbUVuZCIsIm9uVmlld3BvcnRDaGFuZ2VFbmQiLCJvbk1vdmVFbmQiLCJjbG9zZXN0IiwiZGVzdHJveSIsInVwZGF0ZSIsInNlbGVjdG9yJGkiLCJ1c2VyU2VsZWN0aW9uUmVjdCIsIlVzZXJTZWxlY3Rpb24iLCJpc0FjdGl2ZSIsIndyYXBIYW5kbGVyIiwiaGFuZGxlciIsImNvbnRhaW5lclJlZiIsInNlbGVjdG9yJGgiLCJjb25uZWN0aW9uSW5Qcm9ncmVzcyIsImNvbm5lY3Rpb24iLCJpblByb2dyZXNzIiwiUGFuZSIsImlzU2VsZWN0aW5nIiwic2VsZWN0aW9uS2V5UHJlc3NlZCIsInNlbGVjdGlvbk1vZGUiLCJGdWxsIiwic2VsZWN0aW9uT25EcmFnIiwib25TZWxlY3Rpb25TdGFydCIsIm9uU2VsZWN0aW9uRW5kIiwib25QYW5lQ2xpY2siLCJvblBhbmVTY3JvbGwiLCJvblBhbmVNb3VzZUVudGVyIiwib25QYW5lTW91c2VNb3ZlIiwib25QYW5lTW91c2VMZWF2ZSIsImhhc0FjdGl2ZVNlbGVjdGlvbiIsImNvbnRhaW5lciIsImNvbnRhaW5lckJvdW5kcyIsInNlbGVjdGVkTm9kZUlkcyIsInNlbGVjdGVkRWRnZUlkcyIsInNlbGVjdGlvbkluUHJvZ3Jlc3MiLCJzZWxlY3Rpb25TdGFydGVkIiwib25DbGljayIsInJlc2V0U2VsZWN0ZWRFbGVtZW50cyIsIm9uQ29udGV4dE1lbnUiLCJvbldoZWVsIiwib25Qb2ludGVyRG93biIsImJ1dHRvbiIsInNldFBvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwibmF0aXZlRXZlbnQiLCJzdGFydFgiLCJzdGFydFkiLCJvblBvaW50ZXJNb3ZlIiwiZGVmYXVsdEVkZ2VPcHRpb25zIiwibW91c2VYIiwibW91c2VZIiwibmV4dFVzZXJTZWxlY3RSZWN0IiwiTWF0aCIsImFicyIsInByZXZTZWxlY3RlZE5vZGVJZHMiLCJwcmV2U2VsZWN0ZWRFZGdlSWRzIiwiUGFydGlhbCIsImVkZ2VzU2VsZWN0YWJsZSIsInNlbGVjdGFibGUiLCJjb25uZWN0aW9ucyIsImVkZ2VJZCIsIm9uUG9pbnRlclVwIiwicmVsZWFzZVBvaW50ZXJDYXB0dXJlIiwiZHJhZ2dhYmxlIiwic2VsZWN0aW9uIiwib25Qb2ludGVyRW50ZXIiLCJvblBvaW50ZXJMZWF2ZSIsImhhbmRsZU5vZGVDbGljayIsInVuc2VsZWN0Iiwibm9kZVJlZiIsImFkZFNlbGVjdGVkTm9kZXMiLCJ1bnNlbGVjdE5vZGVzQW5kRWRnZXMiLCJibHVyIiwidXNlRHJhZyIsImRpc2FibGVkIiwibm9EcmFnQ2xhc3NOYW1lIiwiaGFuZGxlU2VsZWN0b3IiLCJpc1NlbGVjdGFibGUiLCJub2RlQ2xpY2tEaXN0YW5jZSIsInNldERyYWdnaW5nIiwieHlEcmFnIiwiZ2V0U3RvcmVJdGVtcyIsIm9uTm9kZU1vdXNlRG93biIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnU3RvcCIsInNlbGVjdGVkQW5kRHJhZ2dhYmxlIiwibm9kZXNEcmFnZ2FibGUiLCJ1c2VNb3ZlU2VsZWN0ZWROb2RlcyIsIm1vdmVTZWxlY3RlZE5vZGVzIiwibm9kZUV4dGVudCIsInVwZGF0ZU5vZGVQb3NpdGlvbnMiLCJub2RlVXBkYXRlcyIsImlzU2VsZWN0ZWQiLCJ4VmVsbyIsInlWZWxvIiwieERpZmYiLCJkaXJlY3Rpb24iLCJmYWN0b3IiLCJ5RGlmZiIsIm5leHRQb3NpdGlvbiIsIk5vZGVJZENvbnRleHQiLCJDb25zdW1lciIsInVzZU5vZGVJZCIsInNlbGVjdG9yJGciLCJjb25uZWN0T25DbGljayIsImNvbm5lY3RpbmdTZWxlY3RvciIsInN0YXRlIiwiY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUiLCJjbGlja0hhbmRsZSIsImNvbm5lY3Rpb25Nb2RlIiwiZnJvbUhhbmRsZSIsInRvSGFuZGxlIiwiaXNWYWxpZCIsImNvbm5lY3RpbmdUbyIsImNvbm5lY3RpbmdGcm9tIiwiY2xpY2tDb25uZWN0aW5nIiwiaXNQb3NzaWJsZUVuZEhhbmRsZSIsIlN0cmljdCIsImNvbm5lY3Rpb25JblByb2Nlc3MiLCJjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3MiLCJ2YWxpZCIsIkhhbmRsZUNvbXBvbmVudCIsIlRvcCIsImlzVmFsaWRDb25uZWN0aW9uIiwiaXNDb25uZWN0YWJsZSIsImlzQ29ubmVjdGFibGVTdGFydCIsImlzQ29ubmVjdGFibGVFbmQiLCJvbkNvbm5lY3QiLCJvbk1vdXNlRG93biIsIm9uVG91Y2hTdGFydCIsImlzVGFyZ2V0Iiwib25Db25uZWN0RXh0ZW5kZWQiLCJvbkNvbm5lY3RBY3Rpb24iLCJlZGdlUGFyYW1zIiwiaXNNb3VzZVRyaWdnZXJlZCIsImN1cnJlbnRTdG9yZSIsImF1dG9QYW5PbkNvbm5lY3QiLCJjb25uZWN0aW9uUmFkaXVzIiwiZmxvd0lkIiwiY2FuY2VsQ29ubmVjdGlvbiIsIm9uQ29ubmVjdFN0YXJ0Iiwib25Db25uZWN0RW5kIiwidXBkYXRlQ29ubmVjdGlvbiIsImdldFRyYW5zZm9ybSIsImdldEZyb21IYW5kbGUiLCJhdXRvUGFuU3BlZWQiLCJvbkNsaWNrQ29ubmVjdFN0YXJ0Iiwib25DbGlja0Nvbm5lY3RFbmQiLCJpc1ZhbGlkQ29ubmVjdGlvblN0b3JlIiwiY29ubmVjdGlvblN0YXRlIiwiaGFuZGxlVHlwZSIsImRvYyIsImlzVmFsaWRDb25uZWN0aW9uSGFuZGxlciIsImhhbmRsZSIsImZyb21Ob2RlSWQiLCJmcm9tSGFuZGxlSWQiLCJmcm9tVHlwZSIsImNvbm5lY3Rpb25DbG9uZSIsInN0cnVjdHVyZWRDbG9uZSIsInRvUG9zaXRpb24iLCJzb3VyY2UiLCJjb25uZWN0YWJsZSIsImNvbm5lY3RhYmxlc3RhcnQiLCJjb25uZWN0YWJsZWVuZCIsImNsaWNrY29ubmVjdGluZyIsImNvbm5lY3Rpbmdmcm9tIiwiY29ubmVjdGluZ3RvIiwiY29ubmVjdGlvbmluZGljYXRvciIsIkhhbmRsZSIsIklucHV0Tm9kZSIsInNvdXJjZVBvc2l0aW9uIiwiQm90dG9tIiwibGFiZWwiLCJEZWZhdWx0Tm9kZSIsInRhcmdldFBvc2l0aW9uIiwiR3JvdXBOb2RlIiwiT3V0cHV0Tm9kZSIsImFycm93S2V5RGlmZnMiLCJBcnJvd1VwIiwiQXJyb3dEb3duIiwiQXJyb3dMZWZ0IiwiQXJyb3dSaWdodCIsImJ1aWx0aW5Ob2RlVHlwZXMiLCJpbnB1dCIsImRlZmF1bHQiLCJvdXRwdXQiLCJncm91cCIsImdldE5vZGVJbmxpbmVTdHlsZURpbWVuc2lvbnMiLCJoYW5kbGVCb3VuZHMiLCJpbml0aWFsV2lkdGgiLCJpbml0aWFsSGVpZ2h0Iiwic2VsZWN0b3IkZiIsInRyYW5zZm9ybVN0cmluZyIsIk5vZGVzU2VsZWN0aW9uIiwib25TZWxlY3Rpb25Db250ZXh0TWVudSIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsIm9uS2V5RG93biIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInRhYkluZGV4Iiwid2luIiwic2VsZWN0b3IkZSIsIkZsb3dSZW5kZXJlckNvbXBvbmVudCIsInNlbGVjdGlvbktleUNvZGUiLCJwYW5BY3RpdmF0aW9uS2V5Q29kZSIsIl9wYW5PblNjcm9sbCIsIl9wYW5PbkRyYWciLCJwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCIsIl9zZWxlY3Rpb25PbkRyYWciLCJGbG93UmVuZGVyZXIiLCJzZWxlY3RvciRkIiwib25seVJlbmRlclZpc2libGUiLCJ1c2VWaXNpYmxlTm9kZUlkcyIsIm5vZGVJZHMiLCJzZWxlY3RvciRjIiwidXNlUmVzaXplT2JzZXJ2ZXIiLCJ1cGRhdGVzIiwiZW50cnkiLCJnZXRBdHRyaWJ1dGUiLCJub2RlRWxlbWVudCIsImZvcmNlIiwiZGlzY29ubmVjdCIsInVzZU5vZGVPYnNlcnZlciIsIm5vZGVUeXBlIiwiaGFzRGltZW5zaW9ucyIsIm9ic2VydmVkTm9kZSIsInByZXZTb3VyY2VQb3NpdGlvbiIsInByZXZUYXJnZXRQb3NpdGlvbiIsInByZXZUeXBlIiwiaXNJbml0aWFsaXplZCIsImhpZGRlbiIsInR5cGVDaGFuZ2VkIiwic291cmNlUG9zQ2hhbmdlZCIsInRhcmdldFBvc0NoYW5nZWQiLCJOb2RlV3JhcHBlciIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZUxlYXZlIiwib25Eb3VibGVDbGljayIsIm5vZGVzQ29ubmVjdGFibGUiLCJub2Rlc0ZvY3VzYWJsZSIsIm5vZGVUeXBlcyIsImlzUGFyZW50IiwicGFyZW50TG9va3VwIiwiTm9kZUNvbXBvbmVudCIsImlzRHJhZ2dhYmxlIiwiaXNGb2N1c2FibGUiLCJmb2N1c2FibGUiLCJkcmFnSGFuZGxlIiwibm9kZURpbWVuc2lvbnMiLCJpbmxpbmVEaW1lbnNpb25zIiwiaGFzUG9pbnRlckV2ZW50cyIsIm9uTW91c2VFbnRlckhhbmRsZXIiLCJvbk1vdXNlTW92ZUhhbmRsZXIiLCJvbk1vdXNlTGVhdmVIYW5kbGVyIiwib25Db250ZXh0TWVudUhhbmRsZXIiLCJvbkRvdWJsZUNsaWNrSGFuZGxlciIsIm9uU2VsZWN0Tm9kZUhhbmRsZXIiLCJzZWxlY3ROb2Rlc09uRHJhZyIsIm5vZGVEcmFnVGhyZXNob2xkIiwidG9Mb3dlckNhc2UiLCJwYXJlbnQiLCJ6SW5kZXgiLCJ6IiwidmlzaWJpbGl0eSIsInJvbGUiLCJhcmlhTGFiZWwiLCJwb3NpdGlvbkFic29sdXRlWCIsInBvc2l0aW9uQWJzb2x1dGVZIiwiZGVsZXRhYmxlIiwic2VsZWN0b3IkYiIsIk5vZGVSZW5kZXJlckNvbXBvbmVudCIsIm9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMiLCJvbk5vZGVDbGljayIsIm9uTm9kZU1vdXNlRW50ZXIiLCJvbk5vZGVNb3VzZU1vdmUiLCJvbk5vZGVNb3VzZUxlYXZlIiwib25Ob2RlQ29udGV4dE1lbnUiLCJvbk5vZGVEb3VibGVDbGljayIsIk5vZGVSZW5kZXJlciIsInVzZVZpc2libGVFZGdlSWRzIiwiZWRnZUlkcyIsInZpc2libGVFZGdlSWRzIiwic291cmNlTm9kZSIsInRhcmdldE5vZGUiLCJBcnJvd1N5bWJvbCIsImNvbG9yIiwic3Ryb2tlV2lkdGgiLCJzdHJva2UiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iLCJmaWxsIiwicG9pbnRzIiwiQXJyb3dDbG9zZWRTeW1ib2wiLCJNYXJrZXJTeW1ib2xzIiwiQXJyb3ciLCJBcnJvd0Nsb3NlZCIsInVzZU1hcmtlclN5bWJvbCIsInN5bWJvbCIsInN5bWJvbEV4aXN0cyIsIk1hcmtlciIsIm1hcmtlclVuaXRzIiwib3JpZW50IiwiU3ltYm9sIiwibWFya2VyV2lkdGgiLCJtYXJrZXJIZWlnaHQiLCJ2aWV3Qm94IiwicmVmWCIsInJlZlkiLCJNYXJrZXJEZWZpbml0aW9ucyIsImRlZmF1bHRDb2xvciIsIm1hcmtlcnMiLCJkZWZhdWx0TWFya2VyU3RhcnQiLCJtYXJrZXJTdGFydCIsImRlZmF1bHRNYXJrZXJFbmQiLCJtYXJrZXJFbmQiLCJtYXJrZXIiLCJNYXJrZXJEZWZpbml0aW9ucyQxIiwiRWRnZVRleHRDb21wb25lbnQiLCJsYWJlbFN0eWxlIiwibGFiZWxTaG93QmciLCJsYWJlbEJnU3R5bGUiLCJsYWJlbEJnUGFkZGluZyIsImxhYmVsQmdCb3JkZXJSYWRpdXMiLCJlZGdlVGV4dEJib3giLCJzZXRFZGdlVGV4dEJib3giLCJlZGdlVGV4dENsYXNzZXMiLCJlZGdlVGV4dFJlZiIsInRleHRCYm94IiwiZ2V0QkJveCIsInJ4IiwicnkiLCJkeSIsIkVkZ2VUZXh0IiwiQmFzZUVkZ2UiLCJwYXRoIiwibGFiZWxYIiwibGFiZWxZIiwiaW50ZXJhY3Rpb25XaWR0aCIsImQiLCJzdHJva2VPcGFjaXR5IiwiZ2V0Q29udHJvbCIsInBvcyIsIngxIiwieTEiLCJ4MiIsInkyIiwiTGVmdCIsIlJpZ2h0IiwiZ2V0U2ltcGxlQmV6aWVyUGF0aCIsInNvdXJjZVgiLCJzb3VyY2VZIiwidGFyZ2V0WCIsInRhcmdldFkiLCJzb3VyY2VDb250cm9sWCIsInNvdXJjZUNvbnRyb2xZIiwidGFyZ2V0Q29udHJvbFgiLCJ0YXJnZXRDb250cm9sWSIsIm9mZnNldFgiLCJvZmZzZXRZIiwiY3JlYXRlU2ltcGxlQmV6aWVyRWRnZSIsIl9pZCIsImlzSW50ZXJuYWwiLCJTaW1wbGVCZXppZXJFZGdlIiwiU2ltcGxlQmV6aWVyRWRnZUludGVybmFsIiwiY3JlYXRlU21vb3RoU3RlcEVkZ2UiLCJwYXRoT3B0aW9ucyIsImJvcmRlclJhZGl1cyIsIm9mZnNldCIsIlNtb290aFN0ZXBFZGdlIiwiU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCIsImNyZWF0ZVN0ZXBFZGdlIiwiU3RlcEVkZ2UiLCJTdGVwRWRnZUludGVybmFsIiwiY3JlYXRlU3RyYWlnaHRFZGdlIiwiU3RyYWlnaHRFZGdlIiwiU3RyYWlnaHRFZGdlSW50ZXJuYWwiLCJjcmVhdGVCZXppZXJFZGdlIiwiY3VydmF0dXJlIiwiQmV6aWVyRWRnZSIsIkJlemllckVkZ2VJbnRlcm5hbCIsImJ1aWx0aW5FZGdlVHlwZXMiLCJzdHJhaWdodCIsInN0ZXAiLCJzbW9vdGhzdGVwIiwic2ltcGxlYmV6aWVyIiwibnVsbFBvc2l0aW9uIiwic2hpZnRYIiwic2hpZnQiLCJzaGlmdFkiLCJFZGdlVXBkYXRlckNsYXNzTmFtZSIsIkVkZ2VBbmNob3IiLCJyYWRpdXMiLCJvbk1vdXNlT3V0IiwiY3giLCJjeSIsInIiLCJFZGdlVXBkYXRlQW5jaG9ycyIsImlzUmVjb25uZWN0YWJsZSIsInJlY29ubmVjdFJhZGl1cyIsIm9uUmVjb25uZWN0Iiwib25SZWNvbm5lY3RTdGFydCIsIm9uUmVjb25uZWN0RW5kIiwic2V0UmVjb25uZWN0aW5nIiwic2V0VXBkYXRlSG92ZXIiLCJoYW5kbGVFZGdlVXBkYXRlciIsIm9wcG9zaXRlSGFuZGxlIiwiX29uUmVjb25uZWN0RW5kIiwiZXZ0Iiwib25Db25uZWN0RWRnZSIsImVkZ2VVcGRhdGVyVHlwZSIsIm9uUmVjb25uZWN0U291cmNlTW91c2VEb3duIiwidGFyZ2V0SGFuZGxlIiwib25SZWNvbm5lY3RUYXJnZXRNb3VzZURvd24iLCJzb3VyY2VIYW5kbGUiLCJvblJlY29ubmVjdE1vdXNlRW50ZXIiLCJvblJlY29ubmVjdE1vdXNlT3V0IiwiRWRnZVdyYXBwZXIiLCJlZGdlc0ZvY3VzYWJsZSIsImVkZ2VzUmVjb25uZWN0YWJsZSIsImVkZ2VUeXBlcyIsImVkZ2VUeXBlIiwiRWRnZUNvbXBvbmVudCIsInJlY29ubmVjdGFibGUiLCJlZGdlUmVmIiwidXBkYXRlSG92ZXIiLCJyZWNvbm5lY3RpbmciLCJlZGdlUG9zaXRpb24iLCJlbGV2YXRlT25TZWxlY3QiLCJlbGV2YXRlRWRnZXNPblNlbGVjdCIsIm1hcmtlclN0YXJ0VXJsIiwibWFya2VyRW5kVXJsIiwib25FZGdlQ2xpY2siLCJhZGRTZWxlY3RlZEVkZ2VzIiwib25FZGdlRG91YmxlQ2xpY2siLCJvbkVkZ2VDb250ZXh0TWVudSIsIm9uRWRnZU1vdXNlRW50ZXIiLCJvbkVkZ2VNb3VzZU1vdmUiLCJvbkVkZ2VNb3VzZUxlYXZlIiwiYW5pbWF0ZWQiLCJpbmFjdGl2ZSIsInVwZGF0aW5nIiwic291cmNlSGFuZGxlSWQiLCJ0YXJnZXRIYW5kbGVJZCIsInNlbGVjdG9yJGEiLCJFZGdlUmVuZGVyZXJDb21wb25lbnQiLCJkZWZhdWx0TWFya2VyQ29sb3IiLCJFZGdlUmVuZGVyZXIiLCJzZWxlY3RvciQ5IiwiVmlld3BvcnQiLCJ1c2VPbkluaXRIYW5kbGVyIiwib25Jbml0IiwicmZJbnN0YW5jZSIsInNldFRpbWVvdXQiLCJzZWxlY3RvciQ4Iiwic3luY1ZpZXdwb3J0IiwidXNlVmlld3BvcnRTeW5jIiwic3RvcmVTZWxlY3RvciQxIiwidG8iLCJnZXRTZWxlY3RvciIsImNvbm5lY3Rpb25TZWxlY3RvciIsImNvbWJpbmVkU2VsZWN0b3IiLCJ1c2VDb25uZWN0aW9uIiwic2VsZWN0b3IkNyIsIkNvbm5lY3Rpb25MaW5lV3JhcHBlciIsImNvbXBvbmVudCIsInJlbmRlckNvbm5lY3Rpb24iLCJDb25uZWN0aW9uTGluZSIsIkN1c3RvbUNvbXBvbmVudCIsIkJlemllciIsImZyb21Ob2RlIiwiZnJvbVBvc2l0aW9uIiwidG9Ob2RlIiwiY29ubmVjdGlvbkxpbmVUeXBlIiwiY29ubmVjdGlvbkxpbmVTdHlsZSIsImZyb21YIiwiZnJvbVkiLCJ0b1giLCJ0b1kiLCJjb25uZWN0aW9uU3RhdHVzIiwicGF0aFBhcmFtcyIsIlNpbXBsZUJlemllciIsIlN0ZXAiLCJTbW9vdGhTdGVwIiwiZW1wdHlUeXBlcyIsInVzZU5vZGVPckVkZ2VUeXBlc1dhcm5pbmciLCJub2RlT3JFZGdlVHlwZXMiLCJ0eXBlc1JlZiIsInByb2Nlc3MiLCJ1c2VkS2V5cyIsInVzZVN0eWxlc0xvYWRlZFdhcm5pbmciLCJjaGVja2VkIiwicGFuZSIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRDb21wdXRlZFN0eWxlIiwiR3JhcGhWaWV3Q29tcG9uZW50IiwiY29ubmVjdGlvbkxpbmVDb21wb25lbnQiLCJjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlIiwiR3JhcGhWaWV3IiwiZ2V0SW5pdGlhbFN0YXRlIiwic3RvcmVFZGdlcyIsInN0b3JlTm9kZXMiLCJzdG9yZU5vZGVPcmlnaW4iLCJzdG9yZU5vZGVFeHRlbnQiLCJub2Rlc0luaXRpYWxpemVkIiwiZWxldmF0ZU5vZGVzT25TZWxlY3QiLCJhdXRvUGFuT25Ob2RlRHJhZyIsImRlYnVnIiwiY3JlYXRlU3RvcmUiLCJyZXNvbHZlRml0VmlldyIsImNoZWNrRXF1YWxpdHkiLCJ1cGRhdGVkSW50ZXJuYWxzIiwiY29uc29sZSIsImxvZyIsIm5vZGVEcmFnSXRlbXMiLCJwYXJlbnRFeHBhbmRDaGlsZHJlbiIsImRyYWdJdGVtIiwiZXhwYW5kUGFyZW50IiwibWF4IiwicmVjdCIsInBhcmVudEV4cGFuZENoYW5nZXMiLCJ1cGRhdGVkTm9kZXMiLCJ1cGRhdGVkRWRnZXMiLCJjaGFuZ2VkRWRnZXMiLCJub2Rlc1RvVW5zZWxlY3QiLCJlZGdlc1RvVW5zZWxlY3QiLCJzZXRTY2FsZUV4dGVudCIsImNsaWNrRGlzdGFuY2UiLCJzZXRDbGlja0Rpc3RhbmNlIiwibmV4dE5vZGVFeHRlbnQiLCJkZWx0YSIsImlzIiwiUmVhY3RGbG93UHJvdmlkZXIiLCJpbml0aWFsTm9kZXMiLCJpbml0aWFsRWRnZXMiLCJpbml0aWFsTWluWm9vbSIsImluaXRpYWxNYXhab29tIiwiaW5pdGlhbEZpdFZpZXdPcHRpb25zIiwiV3JhcHBlciIsImlzV3JhcHBlZCIsIndyYXBwZXJTdHlsZSIsIlJlYWN0RmxvdyIsIm9uTm9kZURyYWdTdGFydCIsIm9uTm9kZURyYWciLCJvbk5vZGVEcmFnU3RvcCIsIm9uU2VsZWN0aW9uRHJhZ1N0YXJ0Iiwib25TZWxlY3Rpb25EcmFnIiwib25TZWxlY3Rpb25EcmFnU3RvcCIsImRlZmF1bHRWaWV3cG9ydCQxIiwiYXR0cmlidXRpb25Qb3NpdGlvbiIsIm9uU2Nyb2xsIiwiY29sb3JNb2RlQ2xhc3NOYW1lIiwid3JhcHBlck9uU2Nyb2xsIiwiY3VycmVudFRhcmdldCIsInNjcm9sbFRvIiwiYmVoYXZpb3IiLCJzZWxlY3RvciQ2IiwiRWRnZUxhYmVsUmVuZGVyZXIiLCJlZGdlTGFiZWxSZW5kZXJlciIsInNlbGVjdG9yJDUiLCJWaWV3cG9ydFBvcnRhbCIsInZpZXdQb3J0YWxEaXYiLCJ1c2VVcGRhdGVOb2RlSW50ZXJuYWxzIiwidXBkYXRlSWRzIiwidXBkYXRlSWQiLCJ0cmlnZ2VyRml0VmlldyIsIm5vZGVzU2VsZWN0b3IiLCJ1c2VOb2RlcyIsImVkZ2VzU2VsZWN0b3IiLCJ1c2VFZGdlcyIsInZpZXdwb3J0U2VsZWN0b3IiLCJ1c2VWaWV3cG9ydCIsInVzZU5vZGVzU3RhdGUiLCJuZHMiLCJ1c2VFZGdlc1N0YXRlIiwiZWRzIiwidXNlT25WaWV3cG9ydENoYW5nZSIsIm9uU3RhcnQiLCJvbkNoYW5nZSIsIm9uRW5kIiwidXNlT25TZWxlY3Rpb25DaGFuZ2UiLCJuZXh0T25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyIsIm5leHRIYW5kbGVycyIsInNlbGVjdG9yJDQiLCJpbmNsdWRlSGlkZGVuTm9kZXMiLCJ1c2VOb2Rlc0luaXRpYWxpemVkIiwiaW5pdGlhbGl6ZWQiLCJ1c2VIYW5kbGVDb25uZWN0aW9ucyIsIm9uRGlzY29ubmVjdCIsIndhcm4iLCJfbm9kZUlkIiwiY3VycmVudE5vZGVJZCIsInByZXZDb25uZWN0aW9ucyIsIl9jb25uZWN0aW9ucyIsImVycm9yMDE0IiwidXNlTm9kZUNvbm5lY3Rpb25zIiwidXNlTm9kZXNEYXRhIiwibm9kZXNEYXRhIiwiaXNBcnJheU9mSWRzIiwiX25vZGVJZHMiLCJ1c2VJbnRlcm5hbE5vZGUiLCJMaW5lUGF0dGVybiIsImxpbmVXaWR0aCIsInZhcmlhbnQiLCJEb3RQYXR0ZXJuIiwiQmFja2dyb3VuZFZhcmlhbnQiLCJkZWZhdWx0U2l6ZSIsIkRvdHMiLCJMaW5lcyIsIkNyb3NzIiwic2VsZWN0b3IkMyIsInBhdHRlcm5JZCIsIkJhY2tncm91bmRDb21wb25lbnQiLCJnYXAiLCJiZ0NvbG9yIiwicGF0dGVybkNsYXNzTmFtZSIsInBhdHRlcm5TaXplIiwiaXNEb3RzIiwiaXNDcm9zcyIsImdhcFhZIiwic2NhbGVkR2FwIiwic2NhbGVkU2l6ZSIsIm9mZnNldFhZIiwicGF0dGVybkRpbWVuc2lvbnMiLCJzY2FsZWRPZmZzZXQiLCJfcGF0dGVybklkIiwicGF0dGVyblVuaXRzIiwicGF0dGVyblRyYW5zZm9ybSIsIkJhY2tncm91bmQiLCJQbHVzSWNvbiIsInhtbG5zIiwiTWludXNJY29uIiwiRml0Vmlld0ljb24iLCJMb2NrSWNvbiIsIlVubG9ja0ljb24iLCJDb250cm9sQnV0dG9uIiwic2VsZWN0b3IkMiIsImlzSW50ZXJhY3RpdmUiLCJtaW5ab29tUmVhY2hlZCIsIm1heFpvb21SZWFjaGVkIiwiQ29udHJvbHNDb21wb25lbnQiLCJzaG93Wm9vbSIsInNob3dGaXRWaWV3Iiwic2hvd0ludGVyYWN0aXZlIiwib25ab29tSW4iLCJvblpvb21PdXQiLCJvbkZpdFZpZXciLCJvbkludGVyYWN0aXZlQ2hhbmdlIiwib3JpZW50YXRpb24iLCJvblpvb21JbkhhbmRsZXIiLCJvblpvb21PdXRIYW5kbGVyIiwib25GaXRWaWV3SGFuZGxlciIsIm9uVG9nZ2xlSW50ZXJhY3Rpdml0eSIsIm9yaWVudGF0aW9uQ2xhc3MiLCJ0aXRsZSIsIkNvbnRyb2xzIiwiTWluaU1hcE5vZGVDb21wb25lbnQiLCJzdHJva2VDb2xvciIsInNoYXBlUmVuZGVyaW5nIiwiYmFja2dyb3VuZCIsImJhY2tncm91bmRDb2xvciIsIk1pbmlNYXBOb2RlIiwic2VsZWN0b3JOb2RlSWRzIiwiZ2V0QXR0ckZ1bmN0aW9uIiwiZnVuYyIsIkZ1bmN0aW9uIiwiTWluaU1hcE5vZGVzIiwibm9kZVN0cm9rZUNvbG9yIiwibm9kZUNvbG9yIiwibm9kZUNsYXNzTmFtZSIsIm5vZGVCb3JkZXJSYWRpdXMiLCJub2RlU3Ryb2tlV2lkdGgiLCJub2RlQ29tcG9uZW50Iiwibm9kZUNvbG9yRnVuYyIsIm5vZGVTdHJva2VDb2xvckZ1bmMiLCJub2RlQ2xhc3NOYW1lRnVuYyIsImNocm9tZSIsIk5vZGVDb21wb25lbnRXcmFwcGVyIiwiTm9kZUNvbXBvbmVudFdyYXBwZXJJbm5lciIsIk1pbmlNYXBOb2RlcyQxIiwiZGVmYXVsdFdpZHRoIiwiZGVmYXVsdEhlaWdodCIsImZpbHRlckhpZGRlbiIsInNlbGVjdG9yJDEiLCJ2aWV3QkIiLCJib3VuZGluZ1JlY3QiLCJmbG93V2lkdGgiLCJmbG93SGVpZ2h0IiwiQVJJQV9MQUJFTF9LRVkiLCJNaW5pTWFwQ29tcG9uZW50IiwibWFza0NvbG9yIiwibWFza1N0cm9rZUNvbG9yIiwibWFza1N0cm9rZVdpZHRoIiwicGFubmFibGUiLCJ6b29tYWJsZSIsImludmVyc2VQYW4iLCJ6b29tU3RlcCIsIm9mZnNldFNjYWxlIiwic3ZnIiwiZWxlbWVudFdpZHRoIiwiZWxlbWVudEhlaWdodCIsInNjYWxlZFdpZHRoIiwic2NhbGVkSGVpZ2h0Iiwidmlld1NjYWxlIiwidmlld1dpZHRoIiwidmlld0hlaWdodCIsImxhYmVsbGVkQnkiLCJ2aWV3U2NhbGVSZWYiLCJtaW5pbWFwSW5zdGFuY2UiLCJnZXRWaWV3U2NhbGUiLCJvblN2Z0NsaWNrIiwicG9pbnRlciIsIm9uU3ZnTm9kZUNsaWNrIiwiZmlsbFJ1bGUiLCJNaW5pTWFwIiwiUmVzaXplQ29udHJvbCIsIm1pbldpZHRoIiwibWluSGVpZ2h0IiwibWF4V2lkdGgiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJtYXhIZWlnaHQiLCJrZWVwQXNwZWN0UmF0aW8iLCJyZXNpemVEaXJlY3Rpb24iLCJzaG91bGRSZXNpemUiLCJvblJlc2l6ZVN0YXJ0Iiwib25SZXNpemUiLCJvblJlc2l6ZUVuZCIsImNvbnRleHROb2RlSWQiLCJyZXNpemVDb250cm9sUmVmIiwiZGVmYXVsdFBvc2l0aW9uIiwiTGluZSIsImNvbnRyb2xQb3NpdGlvbiIsInJlc2l6ZXIiLCJwYW5lRG9tTm9kZSIsImNoaWxkQ2hhbmdlcyIsIm9yaWdpbiIsImNoaWxkIiwicG9zaXRpb25DaGFuZ2UiLCJkaW1lbnNpb25DaGFuZ2UiLCJjaGlsZENoYW5nZSIsImJvdW5kYXJpZXMiLCJwb3NpdGlvbkNsYXNzTmFtZXMiLCJjb2xvclN0eWxlUHJvcCIsImNvbnRyb2xTdHlsZSIsIk5vZGVSZXNpemVDb250cm9sIiwiTm9kZVJlc2l6ZXIiLCJpc1Zpc2libGUiLCJoYW5kbGVDbGFzc05hbWUiLCJoYW5kbGVTdHlsZSIsImxpbmVDbGFzc05hbWUiLCJsaW5lU3R5bGUiLCJOb2RlVG9vbGJhclBvcnRhbCIsIndyYXBwZXJSZWYiLCJub2RlRXF1YWxpdHlGbiIsIm5vZGVzRXF1YWxpdHlGbiIsInN0b3JlU2VsZWN0b3IiLCJzZWxlY3RlZE5vZGVzQ291bnQiLCJOb2RlVG9vbGJhciIsImFsaWduIiwiaW50ZXJuYWxOb2RlcyIsIm5vZGVzQXJyYXkiLCJhY2MiLCJ0cmltIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/system/dist/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@xyflow/system/dist/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionLineType: () => (/* binding */ ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* binding */ ConnectionMode),\n/* harmony export */   MarkerType: () => (/* binding */ MarkerType),\n/* harmony export */   PanOnScrollMode: () => (/* binding */ PanOnScrollMode),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   ResizeControlVariant: () => (/* binding */ ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* binding */ SelectionMode),\n/* harmony export */   XYDrag: () => (/* binding */ XYDrag),\n/* harmony export */   XYHandle: () => (/* binding */ XYHandle),\n/* harmony export */   XYMinimap: () => (/* binding */ XYMinimap),\n/* harmony export */   XYPanZoom: () => (/* binding */ XYPanZoom),\n/* harmony export */   XYResizer: () => (/* binding */ XYResizer),\n/* harmony export */   XY_RESIZER_HANDLE_POSITIONS: () => (/* binding */ XY_RESIZER_HANDLE_POSITIONS),\n/* harmony export */   XY_RESIZER_LINE_POSITIONS: () => (/* binding */ XY_RESIZER_LINE_POSITIONS),\n/* harmony export */   addEdge: () => (/* binding */ addEdge),\n/* harmony export */   adoptUserNodes: () => (/* binding */ adoptUserNodes),\n/* harmony export */   areConnectionMapsEqual: () => (/* binding */ areConnectionMapsEqual),\n/* harmony export */   areSetsEqual: () => (/* binding */ areSetsEqual),\n/* harmony export */   boxToRect: () => (/* binding */ boxToRect),\n/* harmony export */   calcAutoPan: () => (/* binding */ calcAutoPan),\n/* harmony export */   calculateNodePosition: () => (/* binding */ calculateNodePosition),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   clampPosition: () => (/* binding */ clampPosition),\n/* harmony export */   clampPositionToParent: () => (/* binding */ clampPositionToParent),\n/* harmony export */   createMarkerIds: () => (/* binding */ createMarkerIds),\n/* harmony export */   devWarn: () => (/* binding */ devWarn),\n/* harmony export */   elementSelectionKeys: () => (/* binding */ elementSelectionKeys),\n/* harmony export */   errorMessages: () => (/* binding */ errorMessages),\n/* harmony export */   evaluateAbsolutePosition: () => (/* binding */ evaluateAbsolutePosition),\n/* harmony export */   fitViewport: () => (/* binding */ fitViewport),\n/* harmony export */   getBezierEdgeCenter: () => (/* binding */ getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* binding */ getBezierPath),\n/* harmony export */   getBoundsOfBoxes: () => (/* binding */ getBoundsOfBoxes),\n/* harmony export */   getBoundsOfRects: () => (/* binding */ getBoundsOfRects),\n/* harmony export */   getConnectedEdges: () => (/* binding */ getConnectedEdges),\n/* harmony export */   getConnectionStatus: () => (/* binding */ getConnectionStatus),\n/* harmony export */   getDimensions: () => (/* binding */ getDimensions),\n/* harmony export */   getEdgeCenter: () => (/* binding */ getEdgeCenter),\n/* harmony export */   getEdgePosition: () => (/* binding */ getEdgePosition),\n/* harmony export */   getElementsToRemove: () => (/* binding */ getElementsToRemove),\n/* harmony export */   getElevatedEdgeZIndex: () => (/* binding */ getElevatedEdgeZIndex),\n/* harmony export */   getEventPosition: () => (/* binding */ getEventPosition),\n/* harmony export */   getHandleBounds: () => (/* binding */ getHandleBounds),\n/* harmony export */   getHandlePosition: () => (/* binding */ getHandlePosition),\n/* harmony export */   getHostForElement: () => (/* binding */ getHostForElement),\n/* harmony export */   getIncomers: () => (/* binding */ getIncomers),\n/* harmony export */   getInternalNodesBounds: () => (/* binding */ getInternalNodesBounds),\n/* harmony export */   getMarkerId: () => (/* binding */ getMarkerId),\n/* harmony export */   getNodeDimensions: () => (/* binding */ getNodeDimensions),\n/* harmony export */   getNodePositionWithOrigin: () => (/* binding */ getNodePositionWithOrigin),\n/* harmony export */   getNodeToolbarTransform: () => (/* binding */ getNodeToolbarTransform),\n/* harmony export */   getNodesBounds: () => (/* binding */ getNodesBounds),\n/* harmony export */   getNodesInside: () => (/* binding */ getNodesInside),\n/* harmony export */   getOutgoers: () => (/* binding */ getOutgoers),\n/* harmony export */   getOverlappingArea: () => (/* binding */ getOverlappingArea),\n/* harmony export */   getPointerPosition: () => (/* binding */ getPointerPosition),\n/* harmony export */   getSmoothStepPath: () => (/* binding */ getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* binding */ getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* binding */ getViewportForBounds),\n/* harmony export */   handleConnectionChange: () => (/* binding */ handleConnectionChange),\n/* harmony export */   handleExpandParent: () => (/* binding */ handleExpandParent),\n/* harmony export */   infiniteExtent: () => (/* binding */ infiniteExtent),\n/* harmony export */   initialConnection: () => (/* binding */ initialConnection),\n/* harmony export */   isCoordinateExtent: () => (/* binding */ isCoordinateExtent),\n/* harmony export */   isEdgeBase: () => (/* binding */ isEdgeBase),\n/* harmony export */   isEdgeVisible: () => (/* binding */ isEdgeVisible),\n/* harmony export */   isInputDOMNode: () => (/* binding */ isInputDOMNode),\n/* harmony export */   isInternalNodeBase: () => (/* binding */ isInternalNodeBase),\n/* harmony export */   isMacOs: () => (/* binding */ isMacOs),\n/* harmony export */   isMouseEvent: () => (/* binding */ isMouseEvent),\n/* harmony export */   isNodeBase: () => (/* binding */ isNodeBase),\n/* harmony export */   isNumeric: () => (/* binding */ isNumeric),\n/* harmony export */   isRectObject: () => (/* binding */ isRectObject),\n/* harmony export */   nodeHasDimensions: () => (/* binding */ nodeHasDimensions),\n/* harmony export */   nodeToBox: () => (/* binding */ nodeToBox),\n/* harmony export */   nodeToRect: () => (/* binding */ nodeToRect),\n/* harmony export */   oppositePosition: () => (/* binding */ oppositePosition),\n/* harmony export */   panBy: () => (/* binding */ panBy),\n/* harmony export */   pointToRendererPoint: () => (/* binding */ pointToRendererPoint),\n/* harmony export */   reconnectEdge: () => (/* binding */ reconnectEdge),\n/* harmony export */   rectToBox: () => (/* binding */ rectToBox),\n/* harmony export */   rendererPointToPoint: () => (/* binding */ rendererPointToPoint),\n/* harmony export */   shallowNodeData: () => (/* binding */ shallowNodeData),\n/* harmony export */   snapPosition: () => (/* binding */ snapPosition),\n/* harmony export */   updateAbsolutePositions: () => (/* binding */ updateAbsolutePositions),\n/* harmony export */   updateConnectionLookup: () => (/* binding */ updateConnectionLookup),\n/* harmony export */   updateNodeInternals: () => (/* binding */ updateNodeInternals),\n/* harmony export */   withResolvers: () => (/* binding */ withResolvers)\n/* harmony export */ });\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-drag */ \"(ssr)/./node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/./node_modules/d3-zoom/src/index.js\");\n\n\n\n\nconst errorMessages = {\n    error001: () => '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',\n    error002: () => \"It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.\",\n    error003: (nodeType) => `Node type \"${nodeType}\" not found. Using fallback type \"default\".`,\n    error004: () => 'The React Flow parent container needs a width and a height to render the graph.',\n    error005: () => 'Only child nodes can use a parent extent.',\n    error006: () => \"Can't create edge. An edge needs a source and a target.\",\n    error007: (id) => `The old edge with id=${id} does not exist.`,\n    error009: (type) => `Marker type \"${type}\" doesn't exist.`,\n    error008: (handleType, { id, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: \"${handleType === 'source' ? sourceHandle : targetHandle}\", edge id: ${id}.`,\n    error010: () => 'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',\n    error011: (edgeType) => `Edge type \"${edgeType}\" not found. Using fallback type \"default\".`,\n    error012: (id) => `Node with id \"${id}\" does not exist, it may have been removed. This can happen when a node is deleted before the \"onNodeClick\" handler is called.`,\n    error013: (lib = 'react') => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`,\n    error014: () => 'useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.',\n    error015: () => 'It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs.',\n};\nconst infiniteExtent = [\n    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\n    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\n];\nconst elementSelectionKeys = ['Enter', ' ', 'Escape'];\n\n/**\n * The `ConnectionMode` is used to set the mode of connection between nodes.\n * The `Strict` mode is the default one and only allows source to target edges.\n * `Loose` mode allows source to source and target to target edges as well.\n *\n * @public\n */\nvar ConnectionMode;\n(function (ConnectionMode) {\n    ConnectionMode[\"Strict\"] = \"strict\";\n    ConnectionMode[\"Loose\"] = \"loose\";\n})(ConnectionMode || (ConnectionMode = {}));\n/**\n * This enum is used to set the different modes of panning the viewport when the\n * user scrolls. The `Free` mode allows the user to pan in any direction by scrolling\n * with a device like a trackpad. The `Vertical` and `Horizontal` modes restrict\n * scroll panning to only the vertical or horizontal axis, respectively.\n *\n * @public\n */\nvar PanOnScrollMode;\n(function (PanOnScrollMode) {\n    PanOnScrollMode[\"Free\"] = \"free\";\n    PanOnScrollMode[\"Vertical\"] = \"vertical\";\n    PanOnScrollMode[\"Horizontal\"] = \"horizontal\";\n})(PanOnScrollMode || (PanOnScrollMode = {}));\nvar SelectionMode;\n(function (SelectionMode) {\n    SelectionMode[\"Partial\"] = \"partial\";\n    SelectionMode[\"Full\"] = \"full\";\n})(SelectionMode || (SelectionMode = {}));\nconst initialConnection = {\n    inProgress: false,\n    isValid: null,\n    from: null,\n    fromHandle: null,\n    fromPosition: null,\n    fromNode: null,\n    to: null,\n    toHandle: null,\n    toPosition: null,\n    toNode: null,\n};\n\n/**\n * If you set the `connectionLineType` prop on your [`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineType)\n *component, it will dictate the style of connection line rendered when creating\n *new edges.\n *\n * @public\n *\n * @remarks If you choose to render a custom connection line component, this value will be\n *passed to your component as part of its [`ConnectionLineComponentProps`](/api-reference/types/connection-line-component-props).\n */\nvar ConnectionLineType;\n(function (ConnectionLineType) {\n    ConnectionLineType[\"Bezier\"] = \"default\";\n    ConnectionLineType[\"Straight\"] = \"straight\";\n    ConnectionLineType[\"Step\"] = \"step\";\n    ConnectionLineType[\"SmoothStep\"] = \"smoothstep\";\n    ConnectionLineType[\"SimpleBezier\"] = \"simplebezier\";\n})(ConnectionLineType || (ConnectionLineType = {}));\n/**\n * Edges may optionally have a marker on either end. The MarkerType type enumerates\n * the options available to you when configuring a given marker.\n *\n * @public\n */\nvar MarkerType;\n(function (MarkerType) {\n    MarkerType[\"Arrow\"] = \"arrow\";\n    MarkerType[\"ArrowClosed\"] = \"arrowclosed\";\n})(MarkerType || (MarkerType = {}));\n\n/**\n * While [`PanelPosition`](/api-reference/types/panel-position) can be used to place a\n * component in the corners of a container, the `Position` enum is less precise and used\n * primarily in relation to edges and handles.\n *\n * @public\n */\nvar Position;\n(function (Position) {\n    Position[\"Left\"] = \"left\";\n    Position[\"Top\"] = \"top\";\n    Position[\"Right\"] = \"right\";\n    Position[\"Bottom\"] = \"bottom\";\n})(Position || (Position = {}));\nconst oppositePosition = {\n    [Position.Left]: Position.Right,\n    [Position.Right]: Position.Left,\n    [Position.Top]: Position.Bottom,\n    [Position.Bottom]: Position.Top,\n};\n\n/**\n * @internal\n */\nfunction areConnectionMapsEqual(a, b) {\n    if (!a && !b) {\n        return true;\n    }\n    if (!a || !b || a.size !== b.size) {\n        return false;\n    }\n    if (!a.size && !b.size) {\n        return true;\n    }\n    for (const key of a.keys()) {\n        if (!b.has(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * We call the callback for all connections in a that are not in b\n *\n * @internal\n */\nfunction handleConnectionChange(a, b, cb) {\n    if (!cb) {\n        return;\n    }\n    const diff = [];\n    a.forEach((connection, key) => {\n        if (!b?.has(key)) {\n            diff.push(connection);\n        }\n    });\n    if (diff.length) {\n        cb(diff);\n    }\n}\nfunction getConnectionStatus(isValid) {\n    return isValid === null ? null : isValid ? 'valid' : 'invalid';\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Test whether an object is usable as an Edge\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Edge\n */\nconst isEdgeBase = (element) => 'id' in element && 'source' in element && 'target' in element;\n/**\n * Test whether an object is usable as a Node\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Node\n */\nconst isNodeBase = (element) => 'id' in element && 'position' in element && !('source' in element) && !('target' in element);\nconst isInternalNodeBase = (element) => 'id' in element && 'internals' in element && !('source' in element) && !('target' in element);\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _target_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the source is the given node.\n *\n * @example\n * ```ts\n *import { getOutgoers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const outgoers = getOutgoers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getOutgoers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const outgoerIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.source === node.id) {\n            outgoerIds.add(edge.target);\n        }\n    });\n    return nodes.filter((n) => outgoerIds.has(n.id));\n};\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _source_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the target is the given node.\n *\n * @example\n * ```ts\n *import { getIncomers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const incomers = getIncomers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getIncomers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const incomersIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.target === node.id) {\n            incomersIds.add(edge.source);\n        }\n    });\n    return nodes.filter((n) => incomersIds.has(n.id));\n};\nconst getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {\n    const { width, height } = getNodeDimensions(node);\n    const origin = node.origin ?? nodeOrigin;\n    const offsetX = width * origin[0];\n    const offsetY = height * origin[1];\n    return {\n        x: node.position.x - offsetX,\n        y: node.position.y - offsetY,\n    };\n};\n/**\n * Returns the bounding box that contains all the given nodes in an array. This can\n * be useful when combined with [`getViewportForBounds`](/api-reference/utils/get-viewport-for-bounds)\n * to calculate the correct transform to fit the given nodes in a viewport.\n * @public\n * @remarks Useful when combined with {@link getViewportForBounds} to calculate the correct transform to fit the given nodes in a viewport.\n * @param nodes - Nodes to calculate the bounds for.\n * @returns Bounding box enclosing all nodes.\n *\n * @remarks This function was previously called `getRectOfNodes`\n *\n * @example\n * ```js\n *import { getNodesBounds } from '@xyflow/react';\n *\n *const nodes = [\n *  {\n *    id: 'a',\n *    position: { x: 0, y: 0 },\n *    data: { label: 'a' },\n *    width: 50,\n *    height: 25,\n *  },\n *  {\n *    id: 'b',\n *    position: { x: 100, y: 100 },\n *    data: { label: 'b' },\n *    width: 50,\n *    height: 25,\n *  },\n *];\n *\n *const bounds = getNodesBounds(nodes);\n *```\n */\nconst getNodesBounds = (nodes, params = { nodeOrigin: [0, 0] }) => {\n    if ( true && !params.nodeLookup) {\n        console.warn('Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows.');\n    }\n    if (nodes.length === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    const box = nodes.reduce((currBox, nodeOrId) => {\n        const isId = typeof nodeOrId === 'string';\n        let currentNode = !params.nodeLookup && !isId ? nodeOrId : undefined;\n        if (params.nodeLookup) {\n            currentNode = isId\n                ? params.nodeLookup.get(nodeOrId)\n                : !isInternalNodeBase(nodeOrId)\n                    ? params.nodeLookup.get(nodeOrId.id)\n                    : nodeOrId;\n        }\n        const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };\n        return getBoundsOfBoxes(currBox, nodeBox);\n    }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });\n    return boxToRect(box);\n};\n/**\n * Determines a bounding box that contains all given nodes in an array\n * @internal\n */\nconst getInternalNodesBounds = (nodeLookup, params = {}) => {\n    if (nodeLookup.size === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    let box = { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity };\n    nodeLookup.forEach((node) => {\n        if (params.filter === undefined || params.filter(node)) {\n            const nodeBox = nodeToBox(node);\n            box = getBoundsOfBoxes(box, nodeBox);\n        }\n    });\n    return boxToRect(box);\n};\nconst getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, \n// set excludeNonSelectableNodes if you want to pay attention to the nodes \"selectable\" attribute\nexcludeNonSelectableNodes = false) => {\n    const paneRect = {\n        ...pointToRendererPoint(rect, [tx, ty, tScale]),\n        width: rect.width / tScale,\n        height: rect.height / tScale,\n    };\n    const visibleNodes = [];\n    for (const node of nodes.values()) {\n        const { measured, selectable = true, hidden = false } = node;\n        if ((excludeNonSelectableNodes && !selectable) || hidden) {\n            continue;\n        }\n        const width = measured.width ?? node.width ?? node.initialWidth ?? null;\n        const height = measured.height ?? node.height ?? node.initialHeight ?? null;\n        const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));\n        const area = (width ?? 0) * (height ?? 0);\n        const partiallyVisible = partially && overlappingArea > 0;\n        const forceInitialRender = !node.internals.handleBounds;\n        const isVisible = forceInitialRender || partiallyVisible || overlappingArea >= area;\n        if (isVisible || node.dragging) {\n            visibleNodes.push(node);\n        }\n    }\n    return visibleNodes;\n};\n/**\n * This utility filters an array of edges, keeping only those where either the source or target\n * node is present in the given array of nodes.\n * @public\n * @param nodes - Nodes you want to get the connected edges for.\n * @param edges - All edges.\n * @returns Array of edges that connect any of the given nodes with each other.\n *\n * @example\n * ```js\n *import { getConnectedEdges } from '@xyflow/react';\n *\n *const nodes = [\n *  { id: 'a', position: { x: 0, y: 0 } },\n *  { id: 'b', position: { x: 100, y: 0 } },\n *];\n *\n *const edges = [\n *  { id: 'a->c', source: 'a', target: 'c' },\n *  { id: 'c->d', source: 'c', target: 'd' },\n *];\n *\n *const connectedEdges = getConnectedEdges(nodes, edges);\n * // => [{ id: 'a->c', source: 'a', target: 'c' }]\n *```\n */\nconst getConnectedEdges = (nodes, edges) => {\n    const nodeIds = new Set();\n    nodes.forEach((node) => {\n        nodeIds.add(node.id);\n    });\n    return edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));\n};\nfunction getFitViewNodes(nodeLookup, options) {\n    const fitViewNodes = new Map();\n    const optionNodeIds = options?.nodes ? new Set(options.nodes.map((node) => node.id)) : null;\n    nodeLookup.forEach((n) => {\n        const isVisible = n.measured.width && n.measured.height && (options?.includeHiddenNodes || !n.hidden);\n        if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {\n            fitViewNodes.set(n.id, n);\n        }\n    });\n    return fitViewNodes;\n}\nasync function fitViewport({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {\n    if (nodes.size === 0) {\n        return Promise.resolve(true);\n    }\n    const nodesToFit = getFitViewNodes(nodes, options);\n    const bounds = getInternalNodesBounds(nodesToFit);\n    const viewport = getViewportForBounds(bounds, width, height, options?.minZoom ?? minZoom, options?.maxZoom ?? maxZoom, options?.padding ?? 0.1);\n    await panZoom.setViewport(viewport, { duration: options?.duration });\n    return Promise.resolve(true);\n}\n/**\n * This function calculates the next position of a node, taking into account the node's extent, parent node, and origin.\n *\n * @internal\n * @returns position, positionAbsolute\n */\nfunction calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError, }) {\n    const node = nodeLookup.get(nodeId);\n    const parentNode = node.parentId ? nodeLookup.get(node.parentId) : undefined;\n    const { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 };\n    const origin = node.origin ?? nodeOrigin;\n    let extent = nodeExtent;\n    if (node.extent === 'parent' && !node.expandParent) {\n        if (!parentNode) {\n            onError?.('005', errorMessages['error005']());\n        }\n        else {\n            const parentWidth = parentNode.measured.width;\n            const parentHeight = parentNode.measured.height;\n            if (parentWidth && parentHeight) {\n                extent = [\n                    [parentX, parentY],\n                    [parentX + parentWidth, parentY + parentHeight],\n                ];\n            }\n        }\n    }\n    else if (parentNode && isCoordinateExtent(node.extent)) {\n        extent = [\n            [node.extent[0][0] + parentX, node.extent[0][1] + parentY],\n            [node.extent[1][0] + parentX, node.extent[1][1] + parentY],\n        ];\n    }\n    const positionAbsolute = isCoordinateExtent(extent)\n        ? clampPosition(nextPosition, extent, node.measured)\n        : nextPosition;\n    if (node.measured.width === undefined || node.measured.height === undefined) {\n        onError?.('015', errorMessages['error015']());\n    }\n    return {\n        position: {\n            x: positionAbsolute.x - parentX + (node.measured.width ?? 0) * origin[0],\n            y: positionAbsolute.y - parentY + (node.measured.height ?? 0) * origin[1],\n        },\n        positionAbsolute,\n    };\n}\n/**\n * Pass in nodes & edges to delete, get arrays of nodes and edges that actually can be deleted\n * @internal\n * @param param.nodesToRemove - The nodes to remove\n * @param param.edgesToRemove - The edges to remove\n * @param param.nodes - All nodes\n * @param param.edges - All edges\n * @param param.onBeforeDelete - Callback to check which nodes and edges can be deleted\n * @returns nodes: nodes that can be deleted, edges: edges that can be deleted\n */\nasync function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete, }) {\n    const nodeIds = new Set(nodesToRemove.map((node) => node.id));\n    const matchingNodes = [];\n    for (const node of nodes) {\n        if (node.deletable === false) {\n            continue;\n        }\n        const isIncluded = nodeIds.has(node.id);\n        const parentHit = !isIncluded && node.parentId && matchingNodes.find((n) => n.id === node.parentId);\n        if (isIncluded || parentHit) {\n            matchingNodes.push(node);\n        }\n    }\n    const edgeIds = new Set(edgesToRemove.map((edge) => edge.id));\n    const deletableEdges = edges.filter((edge) => edge.deletable !== false);\n    const connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);\n    const matchingEdges = connectedEdges;\n    for (const edge of deletableEdges) {\n        const isIncluded = edgeIds.has(edge.id);\n        if (isIncluded && !matchingEdges.find((e) => e.id === edge.id)) {\n            matchingEdges.push(edge);\n        }\n    }\n    if (!onBeforeDelete) {\n        return {\n            edges: matchingEdges,\n            nodes: matchingNodes,\n        };\n    }\n    const onBeforeDeleteResult = await onBeforeDelete({\n        nodes: matchingNodes,\n        edges: matchingEdges,\n    });\n    if (typeof onBeforeDeleteResult === 'boolean') {\n        return onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] };\n    }\n    return onBeforeDeleteResult;\n}\n\nconst clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);\nconst clampPosition = (position = { x: 0, y: 0 }, extent, dimensions) => ({\n    x: clamp(position.x, extent[0][0], extent[1][0] - (dimensions?.width ?? 0)),\n    y: clamp(position.y, extent[0][1], extent[1][1] - (dimensions?.height ?? 0)),\n});\nfunction clampPositionToParent(childPosition, childDimensions, parent) {\n    const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent);\n    const { x: parentX, y: parentY } = parent.internals.positionAbsolute;\n    return clampPosition(childPosition, [\n        [parentX, parentY],\n        [parentX + parentWidth, parentY + parentHeight],\n    ], childDimensions);\n}\n/**\n * Calculates the velocity of panning when the mouse is close to the edge of the canvas\n * @internal\n * @param value - One dimensional poition of the mouse (x or y)\n * @param min - Minimal position on canvas before panning starts\n * @param max - Maximal position on canvas before panning starts\n * @returns - A number between 0 and 1 that represents the velocity of panning\n */\nconst calcAutoPanVelocity = (value, min, max) => {\n    if (value < min) {\n        return clamp(Math.abs(value - min), 1, min) / min;\n    }\n    else if (value > max) {\n        return -clamp(Math.abs(value - max), 1, min) / min;\n    }\n    return 0;\n};\nconst calcAutoPan = (pos, bounds, speed = 15, distance = 40) => {\n    const xMovement = calcAutoPanVelocity(pos.x, distance, bounds.width - distance) * speed;\n    const yMovement = calcAutoPanVelocity(pos.y, distance, bounds.height - distance) * speed;\n    return [xMovement, yMovement];\n};\nconst getBoundsOfBoxes = (box1, box2) => ({\n    x: Math.min(box1.x, box2.x),\n    y: Math.min(box1.y, box2.y),\n    x2: Math.max(box1.x2, box2.x2),\n    y2: Math.max(box1.y2, box2.y2),\n});\nconst rectToBox = ({ x, y, width, height }) => ({\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n});\nconst boxToRect = ({ x, y, x2, y2 }) => ({\n    x,\n    y,\n    width: x2 - x,\n    height: y2 - y,\n});\nconst nodeToRect = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n};\nconst nodeToBox = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        x2: x + (node.measured?.width ?? node.width ?? node.initialWidth ?? 0),\n        y2: y + (node.measured?.height ?? node.height ?? node.initialHeight ?? 0),\n    };\n};\nconst getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));\nconst getOverlappingArea = (rectA, rectB) => {\n    const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n    const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n    return Math.ceil(xOverlap * yOverlap);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nconst isNumeric = (n) => !isNaN(n) && isFinite(n);\n// used for a11y key board controls for nodes and edges\nconst devWarn = (id, message) => {\n    if (true) {\n        console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id}`);\n    }\n};\nconst snapPosition = (position, snapGrid = [1, 1]) => {\n    return {\n        x: snapGrid[0] * Math.round(position.x / snapGrid[0]),\n        y: snapGrid[1] * Math.round(position.y / snapGrid[1]),\n    };\n};\nconst pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid = false, snapGrid = [1, 1]) => {\n    const position = {\n        x: (x - tx) / tScale,\n        y: (y - ty) / tScale,\n    };\n    return snapToGrid ? snapPosition(position, snapGrid) : position;\n};\nconst rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {\n    return {\n        x: x * tScale + tx,\n        y: y * tScale + ty,\n    };\n};\n/**\n * Parses a single padding value to a number\n * @internal\n * @param padding - Padding to parse\n * @param viewport - Width or height of the viewport\n * @returns The padding in pixels\n */\nfunction parsePadding(padding, viewport) {\n    if (typeof padding === 'number') {\n        return Math.floor((viewport - viewport / (1 + padding)) * 0.5);\n    }\n    if (typeof padding === 'string' && padding.endsWith('px')) {\n        const paddingValue = parseFloat(padding);\n        if (!Number.isNaN(paddingValue)) {\n            return Math.floor(paddingValue);\n        }\n    }\n    if (typeof padding === 'string' && padding.endsWith('%')) {\n        const paddingValue = parseFloat(padding);\n        if (!Number.isNaN(paddingValue)) {\n            return Math.floor(viewport * paddingValue * 0.01);\n        }\n    }\n    console.error(`[React Flow] The padding value \"${padding}\" is invalid. Please provide a number or a string with a valid unit (px or %).`);\n    return 0;\n}\n/**\n * Parses the paddings to an object with top, right, bottom, left, x and y paddings\n * @internal\n * @param padding - Padding to parse\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the paddings in pixels\n */\nfunction parsePaddings(padding, width, height) {\n    if (typeof padding === 'string' || typeof padding === 'number') {\n        const paddingY = parsePadding(padding, height);\n        const paddingX = parsePadding(padding, width);\n        return {\n            top: paddingY,\n            right: paddingX,\n            bottom: paddingY,\n            left: paddingX,\n            x: paddingX * 2,\n            y: paddingY * 2,\n        };\n    }\n    if (typeof padding === 'object') {\n        const top = parsePadding(padding.top ?? padding.y ?? 0, height);\n        const bottom = parsePadding(padding.bottom ?? padding.y ?? 0, height);\n        const left = parsePadding(padding.left ?? padding.x ?? 0, width);\n        const right = parsePadding(padding.right ?? padding.x ?? 0, width);\n        return { top, right, bottom, left, x: left + right, y: top + bottom };\n    }\n    return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };\n}\n/**\n * Calculates the resulting paddings if the new viewport is applied\n * @internal\n * @param bounds - Bounds to fit inside viewport\n * @param x - X position of the viewport\n * @param y - Y position of the viewport\n * @param zoom - Zoom level of the viewport\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the minimum padding required to fit the bounds inside the viewport\n */\nfunction calculateAppliedPaddings(bounds, x, y, zoom, width, height) {\n    const { x: left, y: top } = rendererPointToPoint(bounds, [x, y, zoom]);\n    const { x: boundRight, y: boundBottom } = rendererPointToPoint({ x: bounds.x + bounds.width, y: bounds.y + bounds.height }, [x, y, zoom]);\n    const right = width - boundRight;\n    const bottom = height - boundBottom;\n    return {\n        left: Math.floor(left),\n        top: Math.floor(top),\n        right: Math.floor(right),\n        bottom: Math.floor(bottom),\n    };\n}\n/**\n * Returns a viewport that encloses the given bounds with padding.\n * @public\n * @remarks You can determine bounds of nodes with {@link getNodesBounds} and {@link getBoundsOfRects}\n * @param bounds - Bounds to fit inside viewport.\n * @param width - Width of the viewport.\n * @param height  - Height of the viewport.\n * @param minZoom - Minimum zoom level of the resulting viewport.\n * @param maxZoom - Maximum zoom level of the resulting viewport.\n * @param padding - Padding around the bounds.\n * @returns A transformed {@link Viewport} that encloses the given bounds which you can pass to e.g. {@link setViewport}.\n * @example\n * const { x, y, zoom } = getViewportForBounds(\n * { x: 0, y: 0, width: 100, height: 100},\n * 1200, 800, 0.5, 2);\n */\nconst getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {\n    // First we resolve all the paddings to actual pixel values\n    const p = parsePaddings(padding, width, height);\n    const xZoom = (width - p.x) / bounds.width;\n    const yZoom = (height - p.y) / bounds.height;\n    // We calculate the new x, y, zoom for a centered view\n    const zoom = Math.min(xZoom, yZoom);\n    const clampedZoom = clamp(zoom, minZoom, maxZoom);\n    const boundsCenterX = bounds.x + bounds.width / 2;\n    const boundsCenterY = bounds.y + bounds.height / 2;\n    const x = width / 2 - boundsCenterX * clampedZoom;\n    const y = height / 2 - boundsCenterY * clampedZoom;\n    // Then we calculate the minimum padding, to respect asymmetric paddings\n    const newPadding = calculateAppliedPaddings(bounds, x, y, clampedZoom, width, height);\n    // We only want to have an offset if the newPadding is smaller than the required padding\n    const offset = {\n        left: Math.min(newPadding.left - p.left, 0),\n        top: Math.min(newPadding.top - p.top, 0),\n        right: Math.min(newPadding.right - p.right, 0),\n        bottom: Math.min(newPadding.bottom - p.bottom, 0),\n    };\n    return {\n        x: x - offset.left + offset.right,\n        y: y - offset.top + offset.bottom,\n        zoom: clampedZoom,\n    };\n};\nconst isMacOs = () => typeof navigator !== 'undefined' && navigator?.userAgent?.indexOf('Mac') >= 0;\nfunction isCoordinateExtent(extent) {\n    return extent !== undefined && extent !== 'parent';\n}\nfunction getNodeDimensions(node) {\n    return {\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n}\nfunction nodeHasDimensions(node) {\n    return ((node.measured?.width ?? node.width ?? node.initialWidth) !== undefined &&\n        (node.measured?.height ?? node.height ?? node.initialHeight) !== undefined);\n}\n/**\n * Convert child position to aboslute position\n *\n * @internal\n * @param position\n * @param parentId\n * @param nodeLookup\n * @param nodeOrigin\n * @returns an internal node with an absolute position\n */\nfunction evaluateAbsolutePosition(position, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {\n    const positionAbsolute = { ...position };\n    const parent = nodeLookup.get(parentId);\n    if (parent) {\n        const origin = parent.origin || nodeOrigin;\n        positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0];\n        positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];\n    }\n    return positionAbsolute;\n}\nfunction areSetsEqual(a, b) {\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a) {\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Polyfill for Promise.withResolvers until we can use it in all browsers\n * @internal\n */\nfunction withResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\n\nfunction getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = false, transform, containerBounds }) {\n    const { x, y } = getEventPosition(event);\n    const pointerPos = pointToRendererPoint({ x: x - (containerBounds?.left ?? 0), y: y - (containerBounds?.top ?? 0) }, transform);\n    const { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;\n    // we need the snapped position in order to be able to skip unnecessary drag events\n    return {\n        xSnapped,\n        ySnapped,\n        ...pointerPos,\n    };\n}\nconst getDimensions = (node) => ({\n    width: node.offsetWidth,\n    height: node.offsetHeight,\n});\nconst getHostForElement = (element) => element?.getRootNode?.() || window?.document;\nconst inputTags = ['INPUT', 'SELECT', 'TEXTAREA'];\nfunction isInputDOMNode(event) {\n    // using composed path for handling shadow dom\n    const target = (event.composedPath?.()?.[0] || event.target);\n    if (target?.nodeType !== 1 /* Node.ELEMENT_NODE */)\n        return false;\n    const isInput = inputTags.includes(target.nodeName) || target.hasAttribute('contenteditable');\n    // when an input field is focused we don't want to trigger deletion or movement of nodes\n    return isInput || !!target.closest('.nokey');\n}\nconst isMouseEvent = (event) => 'clientX' in event;\nconst getEventPosition = (event, bounds) => {\n    const isMouse = isMouseEvent(event);\n    const evtX = isMouse ? event.clientX : event.touches?.[0].clientX;\n    const evtY = isMouse ? event.clientY : event.touches?.[0].clientY;\n    return {\n        x: evtX - (bounds?.left ?? 0),\n        y: evtY - (bounds?.top ?? 0),\n    };\n};\n/*\n * The handle bounds are calculated relative to the node element.\n * We store them in the internals object of the node in order to avoid\n * unnecessary recalculations.\n */\nconst getHandleBounds = (type, nodeElement, nodeBounds, zoom, nodeId) => {\n    const handles = nodeElement.querySelectorAll(`.${type}`);\n    if (!handles || !handles.length) {\n        return null;\n    }\n    return Array.from(handles).map((handle) => {\n        const handleBounds = handle.getBoundingClientRect();\n        return {\n            id: handle.getAttribute('data-handleid'),\n            type,\n            nodeId,\n            position: handle.getAttribute('data-handlepos'),\n            x: (handleBounds.left - nodeBounds.left) / zoom,\n            y: (handleBounds.top - nodeBounds.top) / zoom,\n            ...getDimensions(handle),\n        };\n    });\n};\n\nfunction getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY, }) {\n    /*\n     * cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate\n     * https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve\n     */\n    const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;\n    const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;\n    const offsetX = Math.abs(centerX - sourceX);\n    const offsetY = Math.abs(centerY - sourceY);\n    return [centerX, centerY, offsetX, offsetY];\n}\nfunction calculateControlOffset(distance, curvature) {\n    if (distance >= 0) {\n        return 0.5 * distance;\n    }\n    return curvature * 25 * Math.sqrt(-distance);\n}\nfunction getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {\n    switch (pos) {\n        case Position.Left:\n            return [x1 - calculateControlOffset(x1 - x2, c), y1];\n        case Position.Right:\n            return [x1 + calculateControlOffset(x2 - x1, c), y1];\n        case Position.Top:\n            return [x1, y1 - calculateControlOffset(y1 - y2, c)];\n        case Position.Bottom:\n            return [x1, y1 + calculateControlOffset(y2 - y1, c)];\n    }\n}\n/**\n * The `getBezierPath` util returns everything you need to render a bezier edge\n *between two nodes.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getBezierPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *});\n *```\n *\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to\n *work with multiple edge paths at once.\n */\nfunction getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25, }) {\n    const [sourceControlX, sourceControlY] = getControlWithCurvature({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY,\n        c: curvature,\n    });\n    const [targetControlX, targetControlY] = getControlWithCurvature({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY,\n        c: curvature,\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY,\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY,\n    ];\n}\n\n// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)\nfunction getEdgeCenter({ sourceX, sourceY, targetX, targetY, }) {\n    const xOffset = Math.abs(targetX - sourceX) / 2;\n    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;\n    const yOffset = Math.abs(targetY - sourceY) / 2;\n    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;\n    return [centerX, centerY, xOffset, yOffset];\n}\nfunction getElevatedEdgeZIndex({ sourceNode, targetNode, selected = false, zIndex = 0, elevateOnSelect = false, }) {\n    if (!elevateOnSelect) {\n        return zIndex;\n    }\n    const edgeOrConnectedNodeSelected = selected || targetNode.selected || sourceNode.selected;\n    const selectedZIndex = Math.max(sourceNode.internals.z || 0, targetNode.internals.z || 0, 1000);\n    return zIndex + (edgeOrConnectedNodeSelected ? selectedZIndex : 0);\n}\nfunction isEdgeVisible({ sourceNode, targetNode, width, height, transform }) {\n    const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));\n    if (edgeBox.x === edgeBox.x2) {\n        edgeBox.x2 += 1;\n    }\n    if (edgeBox.y === edgeBox.y2) {\n        edgeBox.y2 += 1;\n    }\n    const viewRect = {\n        x: -transform[0] / transform[2],\n        y: -transform[1] / transform[2],\n        width: width / transform[2],\n        height: height / transform[2],\n    };\n    return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;\n}\nconst getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ''}-${target}${targetHandle || ''}`;\nconst connectionExists = (edge, edges) => {\n    return edges.some((el) => el.source === edge.source &&\n        el.target === edge.target &&\n        (el.sourceHandle === edge.sourceHandle || (!el.sourceHandle && !edge.sourceHandle)) &&\n        (el.targetHandle === edge.targetHandle || (!el.targetHandle && !edge.targetHandle)));\n};\n/**\n * This util is a convenience function to add a new Edge to an array of edges. It also performs some validation to make sure you don't add an invalid edge or duplicate an existing one.\n * @public\n * @param edgeParams - Either an `Edge` or a `Connection` you want to add.\n * @param edges - The array of all current edges.\n * @returns A new array of edges with the new edge added.\n *\n * @remarks If an edge with the same `target` and `source` already exists (and the same\n *`targetHandle` and `sourceHandle` if those are set), then this util won't add\n *a new edge even if the `id` property is different.\n *\n */\nconst addEdge = (edgeParams, edges) => {\n    if (!edgeParams.source || !edgeParams.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    let edge;\n    if (isEdgeBase(edgeParams)) {\n        edge = { ...edgeParams };\n    }\n    else {\n        edge = {\n            ...edgeParams,\n            id: getEdgeId(edgeParams),\n        };\n    }\n    if (connectionExists(edge, edges)) {\n        return edges;\n    }\n    if (edge.sourceHandle === null) {\n        delete edge.sourceHandle;\n    }\n    if (edge.targetHandle === null) {\n        delete edge.targetHandle;\n    }\n    return edges.concat(edge);\n};\n/**\n * A handy utility to update an existing [`Edge`](/api-reference/types/edge) with new properties.\n *This searches your edge array for an edge with a matching `id` and updates its\n *properties with the connection you provide.\n * @public\n * @param oldEdge - The edge you want to update.\n * @param newConnection - The new connection you want to update the edge with.\n * @param edges - The array of all current edges.\n * @returns The updated edges array.\n *\n * @example\n * ```js\n *const onReconnect = useCallback(\n *  (oldEdge: Edge, newConnection: Connection) => setEdges((els) => reconnectEdge(oldEdge, newConnection, els)),[]);\n *```\n */\nconst reconnectEdge = (oldEdge, newConnection, edges, options = { shouldReplaceId: true }) => {\n    const { id: oldEdgeId, ...rest } = oldEdge;\n    if (!newConnection.source || !newConnection.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    const foundEdge = edges.find((e) => e.id === oldEdge.id);\n    if (!foundEdge) {\n        devWarn('007', errorMessages['error007'](oldEdgeId));\n        return edges;\n    }\n    // Remove old edge and create the new edge with parameters of old edge.\n    const edge = {\n        ...rest,\n        id: options.shouldReplaceId ? getEdgeId(newConnection) : oldEdgeId,\n        source: newConnection.source,\n        target: newConnection.target,\n        sourceHandle: newConnection.sourceHandle,\n        targetHandle: newConnection.targetHandle,\n    };\n    return edges.filter((e) => e.id !== oldEdgeId).concat(edge);\n};\n\n/**\n * Calculates the straight line path between two points.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getStraightPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getStraightPath({ sourceX, sourceY, targetX, targetY, }) {\n    const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n    });\n    return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];\n}\n\nconst handleDirections = {\n    [Position.Left]: { x: -1, y: 0 },\n    [Position.Right]: { x: 1, y: 0 },\n    [Position.Top]: { x: 0, y: -1 },\n    [Position.Bottom]: { x: 0, y: 1 },\n};\nconst getDirection = ({ source, sourcePosition = Position.Bottom, target, }) => {\n    if (sourcePosition === Position.Left || sourcePosition === Position.Right) {\n        return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };\n    }\n    return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };\n};\nconst distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n/*\n * With this function we try to mimic an orthogonal edge routing behaviour\n * It's not as good as a real orthogonal edge routing, but it's faster and good enough as a default for step and smooth step edges\n */\nfunction getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset, }) {\n    const sourceDir = handleDirections[sourcePosition];\n    const targetDir = handleDirections[targetPosition];\n    const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };\n    const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };\n    const dir = getDirection({\n        source: sourceGapped,\n        sourcePosition,\n        target: targetGapped,\n    });\n    const dirAccessor = dir.x !== 0 ? 'x' : 'y';\n    const currDir = dir[dirAccessor];\n    let points = [];\n    let centerX, centerY;\n    const sourceGapOffset = { x: 0, y: 0 };\n    const targetGapOffset = { x: 0, y: 0 };\n    const [defaultCenterX, defaultCenterY, defaultOffsetX, defaultOffsetY] = getEdgeCenter({\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n    });\n    // opposite handle positions, default case\n    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {\n        centerX = center.x ?? defaultCenterX;\n        centerY = center.y ?? defaultCenterY;\n        /*\n         *    --->\n         *    |\n         * >---\n         */\n        const verticalSplit = [\n            { x: centerX, y: sourceGapped.y },\n            { x: centerX, y: targetGapped.y },\n        ];\n        /*\n         *    |\n         *  ---\n         *  |\n         */\n        const horizontalSplit = [\n            { x: sourceGapped.x, y: centerY },\n            { x: targetGapped.x, y: centerY },\n        ];\n        if (sourceDir[dirAccessor] === currDir) {\n            points = dirAccessor === 'x' ? verticalSplit : horizontalSplit;\n        }\n        else {\n            points = dirAccessor === 'x' ? horizontalSplit : verticalSplit;\n        }\n    }\n    else {\n        // sourceTarget means we take x from source and y from target, targetSource is the opposite\n        const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];\n        const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];\n        // this handles edges with same handle positions\n        if (dirAccessor === 'x') {\n            points = sourceDir.x === currDir ? targetSource : sourceTarget;\n        }\n        else {\n            points = sourceDir.y === currDir ? sourceTarget : targetSource;\n        }\n        if (sourcePosition === targetPosition) {\n            const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);\n            // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target\n            if (diff <= offset) {\n                const gapOffset = Math.min(offset - 1, offset - diff);\n                if (sourceDir[dirAccessor] === currDir) {\n                    sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n                else {\n                    targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n            }\n        }\n        // these are conditions for handling mixed handle positions like Right -> Bottom for example\n        if (sourcePosition !== targetPosition) {\n            const dirAccessorOpposite = dirAccessor === 'x' ? 'y' : 'x';\n            const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];\n            const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];\n            const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];\n            const flipSourceTarget = (sourceDir[dirAccessor] === 1 && ((!isSameDir && sourceGtTargetOppo) || (isSameDir && sourceLtTargetOppo))) ||\n                (sourceDir[dirAccessor] !== 1 && ((!isSameDir && sourceLtTargetOppo) || (isSameDir && sourceGtTargetOppo)));\n            if (flipSourceTarget) {\n                points = dirAccessor === 'x' ? sourceTarget : targetSource;\n            }\n        }\n        const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };\n        const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };\n        const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));\n        const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));\n        // we want to place the label on the longest segment of the edge\n        if (maxXDistance >= maxYDistance) {\n            centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;\n            centerY = points[0].y;\n        }\n        else {\n            centerX = points[0].x;\n            centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;\n        }\n    }\n    const pathPoints = [\n        source,\n        { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },\n        ...points,\n        { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },\n        target,\n    ];\n    return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];\n}\nfunction getBend(a, b, c, size) {\n    const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);\n    const { x, y } = b;\n    // no bend\n    if ((a.x === x && x === c.x) || (a.y === y && y === c.y)) {\n        return `L${x} ${y}`;\n    }\n    // first segment is horizontal\n    if (a.y === y) {\n        const xDir = a.x < c.x ? -1 : 1;\n        const yDir = a.y < c.y ? 1 : -1;\n        return `L ${x + bendSize * xDir},${y}Q ${x},${y} ${x},${y + bendSize * yDir}`;\n    }\n    const xDir = a.x < c.x ? 1 : -1;\n    const yDir = a.y < c.y ? -1 : 1;\n    return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;\n}\n/**\n * The `getSmoothStepPath` util returns everything you need to render a stepped path\n * between two nodes. The `borderRadius` property can be used to choose how rounded\n * the corners of those steps are.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20, }) {\n    const [points, labelX, labelY, offsetX, offsetY] = getPoints({\n        source: { x: sourceX, y: sourceY },\n        sourcePosition,\n        target: { x: targetX, y: targetY },\n        targetPosition,\n        center: { x: centerX, y: centerY },\n        offset,\n    });\n    const path = points.reduce((res, p, i) => {\n        let segment = '';\n        if (i > 0 && i < points.length - 1) {\n            segment = getBend(points[i - 1], p, points[i + 1], borderRadius);\n        }\n        else {\n            segment = `${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`;\n        }\n        res += segment;\n        return res;\n    }, '');\n    return [path, labelX, labelY, offsetX, offsetY];\n}\n\nfunction isNodeInitialized(node) {\n    return (node &&\n        !!(node.internals.handleBounds || node.handles?.length) &&\n        !!(node.measured.width || node.width || node.initialWidth));\n}\nfunction getEdgePosition(params) {\n    const { sourceNode, targetNode } = params;\n    if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {\n        return null;\n    }\n    const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);\n    const targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);\n    const sourceHandle = getHandle$1(sourceHandleBounds?.source ?? [], params.sourceHandle);\n    const targetHandle = getHandle$1(\n    // when connection type is loose we can define all handles as sources and connect source -> source\n    params.connectionMode === ConnectionMode.Strict\n        ? targetHandleBounds?.target ?? []\n        : (targetHandleBounds?.target ?? []).concat(targetHandleBounds?.source ?? []), params.targetHandle);\n    if (!sourceHandle || !targetHandle) {\n        params.onError?.('008', errorMessages['error008'](!sourceHandle ? 'source' : 'target', {\n            id: params.id,\n            sourceHandle: params.sourceHandle,\n            targetHandle: params.targetHandle,\n        }));\n        return null;\n    }\n    const sourcePosition = sourceHandle?.position || Position.Bottom;\n    const targetPosition = targetHandle?.position || Position.Top;\n    const source = getHandlePosition(sourceNode, sourceHandle, sourcePosition);\n    const target = getHandlePosition(targetNode, targetHandle, targetPosition);\n    return {\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n        sourcePosition,\n        targetPosition,\n    };\n}\nfunction toHandleBounds(handles) {\n    if (!handles) {\n        return null;\n    }\n    const source = [];\n    const target = [];\n    for (const handle of handles) {\n        handle.width = handle.width ?? 1;\n        handle.height = handle.height ?? 1;\n        if (handle.type === 'source') {\n            source.push(handle);\n        }\n        else if (handle.type === 'target') {\n            target.push(handle);\n        }\n    }\n    return {\n        source,\n        target,\n    };\n}\nfunction getHandlePosition(node, handle, fallbackPosition = Position.Left, center = false) {\n    const x = (handle?.x ?? 0) + node.internals.positionAbsolute.x;\n    const y = (handle?.y ?? 0) + node.internals.positionAbsolute.y;\n    const { width, height } = handle ?? getNodeDimensions(node);\n    if (center) {\n        return { x: x + width / 2, y: y + height / 2 };\n    }\n    const position = handle?.position ?? fallbackPosition;\n    switch (position) {\n        case Position.Top:\n            return { x: x + width / 2, y };\n        case Position.Right:\n            return { x: x + width, y: y + height / 2 };\n        case Position.Bottom:\n            return { x: x + width / 2, y: y + height };\n        case Position.Left:\n            return { x, y: y + height / 2 };\n    }\n}\nfunction getHandle$1(bounds, handleId) {\n    if (!bounds) {\n        return null;\n    }\n    // if no handleId is given, we use the first handle, otherwise we check for the id\n    return (!handleId ? bounds[0] : bounds.find((d) => d.id === handleId)) || null;\n}\n\nfunction getMarkerId(marker, id) {\n    if (!marker) {\n        return '';\n    }\n    if (typeof marker === 'string') {\n        return marker;\n    }\n    const idPrefix = id ? `${id}__` : '';\n    return `${idPrefix}${Object.keys(marker)\n        .sort()\n        .map((key) => `${key}=${marker[key]}`)\n        .join('&')}`;\n}\nfunction createMarkerIds(edges, { id, defaultColor, defaultMarkerStart, defaultMarkerEnd, }) {\n    const ids = new Set();\n    return edges\n        .reduce((markers, edge) => {\n        [edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {\n            if (marker && typeof marker === 'object') {\n                const markerId = getMarkerId(marker, id);\n                if (!ids.has(markerId)) {\n                    markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });\n                    ids.add(markerId);\n                }\n            }\n        });\n        return markers;\n    }, [])\n        .sort((a, b) => a.id.localeCompare(b.id));\n}\n\nfunction getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {\n    let alignmentOffset = 0.5;\n    if (align === 'start') {\n        alignmentOffset = 0;\n    }\n    else if (align === 'end') {\n        alignmentOffset = 1;\n    }\n    /*\n     * position === Position.Top\n     * we set the x any y position of the toolbar based on the nodes position\n     */\n    let pos = [\n        (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,\n        nodeRect.y * viewport.zoom + viewport.y - offset,\n    ];\n    // and than shift it based on the alignment. The shift values are in %.\n    let shift = [-100 * alignmentOffset, -100];\n    switch (position) {\n        case Position.Right:\n            pos = [\n                (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [0, -100 * alignmentOffset];\n            break;\n        case Position.Bottom:\n            pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;\n            shift[1] = 0;\n            break;\n        case Position.Left:\n            pos = [\n                nodeRect.x * viewport.zoom + viewport.x - offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [-100, -100 * alignmentOffset];\n            break;\n    }\n    return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;\n}\n\nconst defaultOptions = {\n    nodeOrigin: [0, 0],\n    nodeExtent: infiniteExtent,\n    elevateNodesOnSelect: true,\n    defaults: {},\n};\nconst adoptUserNodesDefaultOptions = {\n    ...defaultOptions,\n    checkEquality: true,\n};\nfunction mergeObjects(base, incoming) {\n    const result = { ...base };\n    for (const key in incoming) {\n        if (incoming[key] !== undefined) {\n            // typecast is safe here, because we check for undefined\n            result[key] = incoming[key];\n        }\n    }\n    return result;\n}\nfunction updateAbsolutePositions(nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(defaultOptions, options);\n    for (const node of nodeLookup.values()) {\n        if (node.parentId) {\n            updateChildNode(node, nodeLookup, parentLookup, _options);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(node, _options.nodeOrigin);\n            const extent = isCoordinateExtent(node.extent) ? node.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node));\n            node.internals.positionAbsolute = clampedPosition;\n        }\n    }\n}\nfunction adoptUserNodes(nodes, nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(adoptUserNodesDefaultOptions, options);\n    let nodesInitialized = nodes.length > 0;\n    const tmpLookup = new Map(nodeLookup);\n    const selectedNodeZ = _options?.elevateNodesOnSelect ? 1000 : 0;\n    nodeLookup.clear();\n    parentLookup.clear();\n    for (const userNode of nodes) {\n        let internalNode = tmpLookup.get(userNode.id);\n        if (_options.checkEquality && userNode === internalNode?.internals.userNode) {\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin);\n            const extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));\n            internalNode = {\n                ..._options.defaults,\n                ...userNode,\n                measured: {\n                    width: userNode.measured?.width,\n                    height: userNode.measured?.height,\n                },\n                internals: {\n                    positionAbsolute: clampedPosition,\n                    // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured\n                    handleBounds: !userNode.measured ? undefined : internalNode?.internals.handleBounds,\n                    z: calculateZ(userNode, selectedNodeZ),\n                    userNode,\n                },\n            };\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        if ((internalNode.measured === undefined ||\n            internalNode.measured.width === undefined ||\n            internalNode.measured.height === undefined) &&\n            !internalNode.hidden) {\n            nodesInitialized = false;\n        }\n        if (userNode.parentId) {\n            updateChildNode(internalNode, nodeLookup, parentLookup, options);\n        }\n    }\n    return nodesInitialized;\n}\nfunction updateParentLookup(node, parentLookup) {\n    if (!node.parentId) {\n        return;\n    }\n    const childNodes = parentLookup.get(node.parentId);\n    if (childNodes) {\n        childNodes.set(node.id, node);\n    }\n    else {\n        parentLookup.set(node.parentId, new Map([[node.id, node]]));\n    }\n}\n/**\n * Updates positionAbsolute and zIndex of a child node and the parentLookup.\n */\nfunction updateChildNode(node, nodeLookup, parentLookup, options) {\n    const { elevateNodesOnSelect, nodeOrigin, nodeExtent } = mergeObjects(defaultOptions, options);\n    const parentId = node.parentId;\n    const parentNode = nodeLookup.get(parentId);\n    if (!parentNode) {\n        console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);\n        return;\n    }\n    updateParentLookup(node, parentLookup);\n    const selectedNodeZ = elevateNodesOnSelect ? 1000 : 0;\n    const { x, y, z } = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ);\n    const { positionAbsolute } = node.internals;\n    const positionChanged = x !== positionAbsolute.x || y !== positionAbsolute.y;\n    if (positionChanged || z !== node.internals.z) {\n        // we create a new object to mark the node as updated\n        nodeLookup.set(node.id, {\n            ...node,\n            internals: {\n                ...node.internals,\n                positionAbsolute: positionChanged ? { x, y } : positionAbsolute,\n                z,\n            },\n        });\n    }\n}\nfunction calculateZ(node, selectedNodeZ) {\n    return (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);\n}\nfunction calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ) {\n    const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute;\n    const childDimensions = getNodeDimensions(childNode);\n    const positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin);\n    const clampedPosition = isCoordinateExtent(childNode.extent)\n        ? clampPosition(positionWithOrigin, childNode.extent, childDimensions)\n        : positionWithOrigin;\n    let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);\n    if (childNode.extent === 'parent') {\n        absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode);\n    }\n    const childZ = calculateZ(childNode, selectedNodeZ);\n    const parentZ = parentNode.internals.z ?? 0;\n    return {\n        x: absolutePosition.x,\n        y: absolutePosition.y,\n        z: parentZ > childZ ? parentZ : childZ,\n    };\n}\nfunction handleExpandParent(children, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {\n    const changes = [];\n    const parentExpansions = new Map();\n    // determine the expanded rectangle the child nodes would take for each parent\n    for (const child of children) {\n        const parent = nodeLookup.get(child.parentId);\n        if (!parent) {\n            continue;\n        }\n        const parentRect = parentExpansions.get(child.parentId)?.expandedRect ?? nodeToRect(parent);\n        const expandedRect = getBoundsOfRects(parentRect, child.rect);\n        parentExpansions.set(child.parentId, { expandedRect, parent });\n    }\n    if (parentExpansions.size > 0) {\n        parentExpansions.forEach(({ expandedRect, parent }, parentId) => {\n            // determine the position & dimensions of the parent\n            const positionAbsolute = parent.internals.positionAbsolute;\n            const dimensions = getNodeDimensions(parent);\n            const origin = parent.origin ?? nodeOrigin;\n            // determine how much the parent expands in width and position\n            const xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;\n            const yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;\n            const newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));\n            const newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));\n            const widthChange = (newWidth - dimensions.width) * origin[0];\n            const heightChange = (newHeight - dimensions.height) * origin[1];\n            // We need to correct the position of the parent node if the origin is not [0,0]\n            if (xChange > 0 || yChange > 0 || widthChange || heightChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'position',\n                    position: {\n                        x: parent.position.x - xChange + widthChange,\n                        y: parent.position.y - yChange + heightChange,\n                    },\n                });\n                /*\n                 * We move all child nodes in the oppsite direction\n                 * so the x,y changes of the parent do not move the children\n                 */\n                parentLookup.get(parentId)?.forEach((childNode) => {\n                    if (!children.some((child) => child.id === childNode.id)) {\n                        changes.push({\n                            id: childNode.id,\n                            type: 'position',\n                            position: {\n                                x: childNode.position.x + xChange,\n                                y: childNode.position.y + yChange,\n                            },\n                        });\n                    }\n                });\n            }\n            // We need to correct the dimensions of the parent node if the origin is not [0,0]\n            if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'dimensions',\n                    setAttributes: true,\n                    dimensions: {\n                        width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),\n                        height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0),\n                    },\n                });\n            }\n        });\n    }\n    return changes;\n}\nfunction updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent) {\n    const viewportNode = domNode?.querySelector('.xyflow__viewport');\n    let updatedInternals = false;\n    if (!viewportNode) {\n        return { changes: [], updatedInternals };\n    }\n    const changes = [];\n    const style = window.getComputedStyle(viewportNode);\n    const { m22: zoom } = new window.DOMMatrixReadOnly(style.transform);\n    // in this array we collect nodes, that might trigger changes (like expanding parent)\n    const parentExpandChildren = [];\n    for (const update of updates.values()) {\n        const node = nodeLookup.get(update.id);\n        if (!node) {\n            continue;\n        }\n        if (node.hidden) {\n            nodeLookup.set(node.id, {\n                ...node,\n                internals: {\n                    ...node.internals,\n                    handleBounds: undefined,\n                },\n            });\n            updatedInternals = true;\n            continue;\n        }\n        const dimensions = getDimensions(update.nodeElement);\n        const dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;\n        const doUpdate = !!(dimensions.width &&\n            dimensions.height &&\n            (dimensionChanged || !node.internals.handleBounds || update.force));\n        if (doUpdate) {\n            const nodeBounds = update.nodeElement.getBoundingClientRect();\n            const extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;\n            let { positionAbsolute } = node.internals;\n            if (node.parentId && node.extent === 'parent') {\n                positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId));\n            }\n            else if (extent) {\n                positionAbsolute = clampPosition(positionAbsolute, extent, dimensions);\n            }\n            const newNode = {\n                ...node,\n                measured: dimensions,\n                internals: {\n                    ...node.internals,\n                    positionAbsolute,\n                    handleBounds: {\n                        source: getHandleBounds('source', update.nodeElement, nodeBounds, zoom, node.id),\n                        target: getHandleBounds('target', update.nodeElement, nodeBounds, zoom, node.id),\n                    },\n                },\n            };\n            nodeLookup.set(node.id, newNode);\n            if (node.parentId) {\n                updateChildNode(newNode, nodeLookup, parentLookup, { nodeOrigin });\n            }\n            updatedInternals = true;\n            if (dimensionChanged) {\n                changes.push({\n                    id: node.id,\n                    type: 'dimensions',\n                    dimensions,\n                });\n                if (node.expandParent && node.parentId) {\n                    parentExpandChildren.push({\n                        id: node.id,\n                        parentId: node.parentId,\n                        rect: nodeToRect(newNode, nodeOrigin),\n                    });\n                }\n            }\n        }\n    }\n    if (parentExpandChildren.length > 0) {\n        const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n        changes.push(...parentExpandChanges);\n    }\n    return { changes, updatedInternals };\n}\nasync function panBy({ delta, panZoom, transform, translateExtent, width, height, }) {\n    if (!panZoom || (!delta.x && !delta.y)) {\n        return Promise.resolve(false);\n    }\n    const nextViewport = await panZoom.setViewportConstrained({\n        x: transform[0] + delta.x,\n        y: transform[1] + delta.y,\n        zoom: transform[2],\n    }, [\n        [0, 0],\n        [width, height],\n    ], translateExtent);\n    const transformChanged = !!nextViewport &&\n        (nextViewport.x !== transform[0] || nextViewport.y !== transform[1] || nextViewport.k !== transform[2]);\n    return Promise.resolve(transformChanged);\n}\n/**\n * this function adds the connection to the connectionLookup\n * at the following keys: nodeId-type-handleId, nodeId-type and nodeId\n * @param type type of the connection\n * @param connection connection that should be added to the lookup\n * @param connectionKey at which key the connection should be added\n * @param connectionLookup reference to the connection lookup\n * @param nodeId nodeId of the connection\n * @param handleId handleId of the conneciton\n */\nfunction addConnectionToLookup(type, connection, connectionKey, connectionLookup, nodeId, handleId) {\n    /*\n     * We add the connection to the connectionLookup at the following keys\n     * 1. nodeId, 2. nodeId-type, 3. nodeId-type-handleId\n     * If the key already exists, we add the connection to the existing map\n     */\n    let key = nodeId;\n    const nodeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, nodeMap.set(connectionKey, connection));\n    key = `${nodeId}-${type}`;\n    const typeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, typeMap.set(connectionKey, connection));\n    if (handleId) {\n        key = `${nodeId}-${type}-${handleId}`;\n        const handleMap = connectionLookup.get(key) || new Map();\n        connectionLookup.set(key, handleMap.set(connectionKey, connection));\n    }\n}\nfunction updateConnectionLookup(connectionLookup, edgeLookup, edges) {\n    connectionLookup.clear();\n    edgeLookup.clear();\n    for (const edge of edges) {\n        const { source: sourceNode, target: targetNode, sourceHandle = null, targetHandle = null } = edge;\n        const connection = { edgeId: edge.id, source: sourceNode, target: targetNode, sourceHandle, targetHandle };\n        const sourceKey = `${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`;\n        const targetKey = `${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`;\n        addConnectionToLookup('source', connection, targetKey, connectionLookup, sourceNode, sourceHandle);\n        addConnectionToLookup('target', connection, sourceKey, connectionLookup, targetNode, targetHandle);\n        edgeLookup.set(edge.id, edge);\n    }\n}\n\nfunction shallowNodeData(a, b) {\n    if (a === null || b === null) {\n        return false;\n    }\n    const _a = Array.isArray(a) ? a : [a];\n    const _b = Array.isArray(b) ? b : [b];\n    if (_a.length !== _b.length) {\n        return false;\n    }\n    for (let i = 0; i < _a.length; i++) {\n        if (_a[i].id !== _b[i].id || _a[i].type !== _b[i].type || !Object.is(_a[i].data, _b[i].data)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isParentSelected(node, nodeLookup) {\n    if (!node.parentId) {\n        return false;\n    }\n    const parentNode = nodeLookup.get(node.parentId);\n    if (!parentNode) {\n        return false;\n    }\n    if (parentNode.selected) {\n        return true;\n    }\n    return isParentSelected(parentNode, nodeLookup);\n}\nfunction hasSelector(target, selector, domNode) {\n    let current = target;\n    do {\n        if (current?.matches?.(selector))\n            return true;\n        if (current === domNode)\n            return false;\n        current = current?.parentElement;\n    } while (current);\n    return false;\n}\n// looks for all selected nodes and created a NodeDragItem for each of them\nfunction getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {\n    const dragItems = new Map();\n    for (const [id, node] of nodeLookup) {\n        if ((node.selected || node.id === nodeId) &&\n            (!node.parentId || !isParentSelected(node, nodeLookup)) &&\n            (node.draggable || (nodesDraggable && typeof node.draggable === 'undefined'))) {\n            const internalNode = nodeLookup.get(id);\n            if (internalNode) {\n                dragItems.set(id, {\n                    id,\n                    position: internalNode.position || { x: 0, y: 0 },\n                    distance: {\n                        x: mousePos.x - internalNode.internals.positionAbsolute.x,\n                        y: mousePos.y - internalNode.internals.positionAbsolute.y,\n                    },\n                    extent: internalNode.extent,\n                    parentId: internalNode.parentId,\n                    origin: internalNode.origin,\n                    expandParent: internalNode.expandParent,\n                    internals: {\n                        positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 },\n                    },\n                    measured: {\n                        width: internalNode.measured.width ?? 0,\n                        height: internalNode.measured.height ?? 0,\n                    },\n                });\n            }\n        }\n    }\n    return dragItems;\n}\n/*\n * returns two params:\n * 1. the dragged node (or the first of the list, if we are dragging a node selection)\n * 2. array of selected nodes (for multi selections)\n */\nfunction getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = true, }) {\n    const nodesFromDragItems = [];\n    for (const [id, dragItem] of dragItems) {\n        const node = nodeLookup.get(id)?.internals.userNode;\n        if (node) {\n            nodesFromDragItems.push({\n                ...node,\n                position: dragItem.position,\n                dragging,\n            });\n        }\n    }\n    if (!nodeId) {\n        return [nodesFromDragItems[0], nodesFromDragItems];\n    }\n    const node = nodeLookup.get(nodeId)?.internals.userNode;\n    return [\n        !node\n            ? nodesFromDragItems[0]\n            : {\n                ...node,\n                position: dragItems.get(nodeId)?.position || node.position,\n                dragging,\n            },\n        nodesFromDragItems,\n    ];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop, }) {\n    let lastPos = { x: null, y: null };\n    let autoPanId = 0;\n    let dragItems = new Map();\n    let autoPanStarted = false;\n    let mousePosition = { x: 0, y: 0 };\n    let containerBounds = null;\n    let dragStarted = false;\n    let d3Selection = null;\n    let abortDrag = false; // prevents unintentional dragging on multitouch\n    // public functions\n    function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0, }) {\n        d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n        function updateNodes({ x, y }, dragEvent) {\n            const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions, } = getStoreItems();\n            lastPos = { x, y };\n            let hasChange = false;\n            let nodesBox = { x: 0, y: 0, x2: 0, y2: 0 };\n            if (dragItems.size > 1 && nodeExtent) {\n                const rect = getInternalNodesBounds(dragItems);\n                nodesBox = rectToBox(rect);\n            }\n            for (const [id, dragItem] of dragItems) {\n                if (!nodeLookup.has(id)) {\n                    /*\n                     * if the node is not in the nodeLookup anymore, it was probably deleted while dragging\n                     * and we don't need to update it anymore\n                     */\n                    continue;\n                }\n                let nextPosition = { x: x - dragItem.distance.x, y: y - dragItem.distance.y };\n                if (snapToGrid) {\n                    nextPosition = snapPosition(nextPosition, snapGrid);\n                }\n                /*\n                 * if there is selection with multiple nodes and a node extent is set, we need to adjust the node extent for each node\n                 * based on its position so that the node stays at it's position relative to the selection.\n                 */\n                let adjustedNodeExtent = [\n                    [nodeExtent[0][0], nodeExtent[0][1]],\n                    [nodeExtent[1][0], nodeExtent[1][1]],\n                ];\n                if (dragItems.size > 1 && nodeExtent && !dragItem.extent) {\n                    const { positionAbsolute } = dragItem.internals;\n                    const x1 = positionAbsolute.x - nodesBox.x + nodeExtent[0][0];\n                    const x2 = positionAbsolute.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];\n                    const y1 = positionAbsolute.y - nodesBox.y + nodeExtent[0][1];\n                    const y2 = positionAbsolute.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];\n                    adjustedNodeExtent = [\n                        [x1, y1],\n                        [x2, y2],\n                    ];\n                }\n                const { position, positionAbsolute } = calculateNodePosition({\n                    nodeId: id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent: adjustedNodeExtent,\n                    nodeOrigin,\n                    onError,\n                });\n                // we want to make sure that we only fire a change event when there is a change\n                hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;\n                dragItem.position = position;\n                dragItem.internals.positionAbsolute = positionAbsolute;\n            }\n            if (!hasChange) {\n                return;\n            }\n            updateNodePositions(dragItems, true);\n            if (dragEvent && (onDrag || onNodeDrag || (!nodeId && onSelectionDrag))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDrag?.(dragEvent, dragItems, currentNode, currentNodes);\n                onNodeDrag?.(dragEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDrag?.(dragEvent, currentNodes);\n                }\n            }\n        }\n        async function autoPan() {\n            if (!containerBounds) {\n                return;\n            }\n            const { transform, panBy, autoPanSpeed, autoPanOnNodeDrag } = getStoreItems();\n            if (!autoPanOnNodeDrag) {\n                autoPanStarted = false;\n                cancelAnimationFrame(autoPanId);\n                return;\n            }\n            const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);\n            if (xMovement !== 0 || yMovement !== 0) {\n                lastPos.x = (lastPos.x ?? 0) - xMovement / transform[2];\n                lastPos.y = (lastPos.y ?? 0) - yMovement / transform[2];\n                if (await panBy({ x: xMovement, y: yMovement })) {\n                    updateNodes(lastPos, null);\n                }\n            }\n            autoPanId = requestAnimationFrame(autoPan);\n        }\n        function startDrag(event) {\n            const { nodeLookup, multiSelectionActive, nodesDraggable, transform, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges, } = getStoreItems();\n            dragStarted = true;\n            if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {\n                if (!nodeLookup.get(nodeId)?.selected) {\n                    // we need to reset selected nodes when selectNodesOnDrag=false\n                    unselectNodesAndEdges();\n                }\n            }\n            if (isSelectable && selectNodesOnDrag && nodeId) {\n                onNodeMouseDown?.(nodeId);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);\n            if (dragItems.size > 0 && (onDragStart || onNodeDragStart || (!nodeId && onSelectionDragStart))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDragStart?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                onNodeDragStart?.(event.sourceEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDragStart?.(event.sourceEvent, currentNodes);\n                }\n            }\n        }\n        const d3DragInstance = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .clickDistance(nodeClickDistance)\n            .on('start', (event) => {\n            const { domNode, nodeDragThreshold, transform, snapGrid, snapToGrid } = getStoreItems();\n            containerBounds = domNode?.getBoundingClientRect() || null;\n            abortDrag = false;\n            if (nodeDragThreshold === 0) {\n                startDrag(event);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n        })\n            .on('drag', (event) => {\n            const { autoPanOnNodeDrag, transform, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems();\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            if ((event.sourceEvent.type === 'touchmove' && event.sourceEvent.touches.length > 1) ||\n                // if user deletes a node while dragging, we need to abort the drag to prevent errors\n                (nodeId && !nodeLookup.has(nodeId))) {\n                abortDrag = true;\n            }\n            if (abortDrag) {\n                return;\n            }\n            if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {\n                autoPanStarted = true;\n                autoPan();\n            }\n            if (!dragStarted) {\n                const x = pointerPos.xSnapped - (lastPos.x ?? 0);\n                const y = pointerPos.ySnapped - (lastPos.y ?? 0);\n                const distance = Math.sqrt(x * x + y * y);\n                if (distance > nodeDragThreshold) {\n                    startDrag(event);\n                }\n            }\n            // skip events without movement\n            if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {\n                // dragEvent = event.sourceEvent as MouseEvent;\n                mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n                updateNodes(pointerPos, event.sourceEvent);\n            }\n        })\n            .on('end', (event) => {\n            if (!dragStarted || abortDrag) {\n                return;\n            }\n            autoPanStarted = false;\n            dragStarted = false;\n            cancelAnimationFrame(autoPanId);\n            if (dragItems.size > 0) {\n                const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();\n                updateNodePositions(dragItems, false);\n                if (onDragStop || onNodeDragStop || (!nodeId && onSelectionDragStop)) {\n                    const [currentNode, currentNodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems,\n                        nodeLookup,\n                        dragging: false,\n                    });\n                    onDragStop?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                    onNodeDragStop?.(event.sourceEvent, currentNode, currentNodes);\n                    if (!nodeId) {\n                        onSelectionDragStop?.(event.sourceEvent, currentNodes);\n                    }\n                }\n            }\n        })\n            .filter((event) => {\n            const target = event.target;\n            const isDraggable = !event.button &&\n                (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) &&\n                (!handleSelector || hasSelector(target, handleSelector, domNode));\n            return isDraggable;\n        });\n        d3Selection.call(d3DragInstance);\n    }\n    function destroy() {\n        d3Selection?.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\nfunction getNodesWithinDistance(position, nodeLookup, distance) {\n    const nodes = [];\n    const rect = {\n        x: position.x - distance,\n        y: position.y - distance,\n        width: distance * 2,\n        height: distance * 2,\n    };\n    for (const node of nodeLookup.values()) {\n        if (getOverlappingArea(rect, nodeToRect(node)) > 0) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n/*\n * this distance is used for the area around the user pointer\n * while doing a connection for finding the closest nodes\n */\nconst ADDITIONAL_DISTANCE = 250;\nfunction getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {\n    let closestHandles = [];\n    let minDistance = Infinity;\n    const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);\n    for (const node of closeNodes) {\n        const allHandles = [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n        for (const handle of allHandles) {\n            // if the handle is the same as the fromHandle we skip it\n            if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id) {\n                continue;\n            }\n            // determine absolute position of the handle\n            const { x, y } = getHandlePosition(node, handle, handle.position, true);\n            const distance = Math.sqrt(Math.pow(x - position.x, 2) + Math.pow(y - position.y, 2));\n            if (distance > connectionRadius) {\n                continue;\n            }\n            if (distance < minDistance) {\n                closestHandles = [{ ...handle, x, y }];\n                minDistance = distance;\n            }\n            else if (distance === minDistance) {\n                // when multiple handles are on the same distance we collect all of them\n                closestHandles.push({ ...handle, x, y });\n            }\n        }\n    }\n    if (!closestHandles.length) {\n        return null;\n    }\n    // when multiple handles overlay each other we prefer the opposite handle\n    if (closestHandles.length > 1) {\n        const oppositeHandleType = fromHandle.type === 'source' ? 'target' : 'source';\n        return closestHandles.find((handle) => handle.type === oppositeHandleType) ?? closestHandles[0];\n    }\n    return closestHandles[0];\n}\nfunction getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = false) {\n    const node = nodeLookup.get(nodeId);\n    if (!node) {\n        return null;\n    }\n    const handles = connectionMode === 'strict'\n        ? node.internals.handleBounds?.[handleType]\n        : [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n    const handle = (handleId ? handles?.find((h) => h.id === handleId) : handles?.[0]) ?? null;\n    return handle && withAbsolutePosition\n        ? { ...handle, ...getHandlePosition(node, handle, handle.position, true) }\n        : handle;\n}\nfunction getHandleType(edgeUpdaterType, handleDomNode) {\n    if (edgeUpdaterType) {\n        return edgeUpdaterType;\n    }\n    else if (handleDomNode?.classList.contains('target')) {\n        return 'target';\n    }\n    else if (handleDomNode?.classList.contains('source')) {\n        return 'source';\n    }\n    return null;\n}\nfunction isConnectionValid(isInsideConnectionRadius, isHandleValid) {\n    let isValid = null;\n    if (isHandleValid) {\n        isValid = true;\n    }\n    else if (isInsideConnectionRadius && !isHandleValid) {\n        isValid = false;\n    }\n    return isValid;\n}\n\nconst alwaysValid = () => true;\nfunction onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib, autoPanOnConnect, flowId, panBy, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed, }) {\n    // when xyflow is used inside a shadow root we can't use document\n    const doc = getHostForElement(event.target);\n    let autoPanId = 0;\n    let closestHandle;\n    const { x, y } = getEventPosition(event);\n    const clickedHandle = doc?.elementFromPoint(x, y);\n    const handleType = getHandleType(edgeUpdaterType, clickedHandle);\n    const containerBounds = domNode?.getBoundingClientRect();\n    if (!containerBounds || !handleType) {\n        return;\n    }\n    const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);\n    if (!fromHandleInternal) {\n        return;\n    }\n    let position = getEventPosition(event, containerBounds);\n    let autoPanStarted = false;\n    let connection = null;\n    let isValid = false;\n    let handleDomNode = null;\n    // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas\n    function autoPan() {\n        if (!autoPanOnConnect || !containerBounds) {\n            return;\n        }\n        const [x, y] = calcAutoPan(position, containerBounds, autoPanSpeed);\n        panBy({ x, y });\n        autoPanId = requestAnimationFrame(autoPan);\n    }\n    // Stays the same for all consecutive pointermove events\n    const fromHandle = {\n        ...fromHandleInternal,\n        nodeId,\n        type: handleType,\n        position: fromHandleInternal.position,\n    };\n    const fromNodeInternal = nodeLookup.get(nodeId);\n    const from = getHandlePosition(fromNodeInternal, fromHandle, Position.Left, true);\n    const newConnection = {\n        inProgress: true,\n        isValid: null,\n        from,\n        fromHandle,\n        fromPosition: fromHandle.position,\n        fromNode: fromNodeInternal,\n        to: position,\n        toHandle: null,\n        toPosition: oppositePosition[fromHandle.position],\n        toNode: null,\n    };\n    updateConnection(newConnection);\n    let previousConnection = newConnection;\n    onConnectStart?.(event, { nodeId, handleId, handleType });\n    function onPointerMove(event) {\n        if (!getFromHandle() || !fromHandle) {\n            onPointerUp(event);\n            return;\n        }\n        const transform = getTransform();\n        position = getEventPosition(event, containerBounds);\n        closestHandle = getClosestHandle(pointToRendererPoint(position, transform, false, [1, 1]), connectionRadius, nodeLookup, fromHandle);\n        if (!autoPanStarted) {\n            autoPan();\n            autoPanStarted = true;\n        }\n        const result = isValidHandle(event, {\n            handle: closestHandle,\n            connectionMode,\n            fromNodeId: nodeId,\n            fromHandleId: handleId,\n            fromType: isTarget ? 'target' : 'source',\n            isValidConnection,\n            doc,\n            lib,\n            flowId,\n            nodeLookup,\n        });\n        handleDomNode = result.handleDomNode;\n        connection = result.connection;\n        isValid = isConnectionValid(!!closestHandle, result.isValid);\n        const newConnection = {\n            // from stays the same\n            ...previousConnection,\n            isValid,\n            to: result.toHandle && isValid\n                ? rendererPointToPoint({ x: result.toHandle.x, y: result.toHandle.y }, transform)\n                : position,\n            toHandle: result.toHandle,\n            toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],\n            toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null,\n        };\n        /*\n         * we don't want to trigger an update when the connection\n         * is snapped to the same handle as before\n         */\n        if (isValid &&\n            closestHandle &&\n            previousConnection.toHandle &&\n            newConnection.toHandle &&\n            previousConnection.toHandle.type === newConnection.toHandle.type &&\n            previousConnection.toHandle.nodeId === newConnection.toHandle.nodeId &&\n            previousConnection.toHandle.id === newConnection.toHandle.id &&\n            previousConnection.to.x === newConnection.to.x &&\n            previousConnection.to.y === newConnection.to.y) {\n            return;\n        }\n        updateConnection(newConnection);\n        previousConnection = newConnection;\n    }\n    function onPointerUp(event) {\n        if ((closestHandle || handleDomNode) && connection && isValid) {\n            onConnect?.(connection);\n        }\n        /*\n         * it's important to get a fresh reference from the store here\n         * in order to get the latest state of onConnectEnd\n         */\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { inProgress, ...connectionState } = previousConnection;\n        const finalConnectionState = {\n            ...connectionState,\n            toPosition: previousConnection.toHandle ? previousConnection.toPosition : null,\n        };\n        onConnectEnd?.(event, finalConnectionState);\n        if (edgeUpdaterType) {\n            onReconnectEnd?.(event, finalConnectionState);\n        }\n        cancelConnection();\n        cancelAnimationFrame(autoPanId);\n        autoPanStarted = false;\n        isValid = false;\n        connection = null;\n        handleDomNode = null;\n        doc.removeEventListener('mousemove', onPointerMove);\n        doc.removeEventListener('mouseup', onPointerUp);\n        doc.removeEventListener('touchmove', onPointerMove);\n        doc.removeEventListener('touchend', onPointerUp);\n    }\n    doc.addEventListener('mousemove', onPointerMove);\n    doc.addEventListener('mouseup', onPointerUp);\n    doc.addEventListener('touchmove', onPointerMove);\n    doc.addEventListener('touchend', onPointerUp);\n}\n// checks if  and returns connection in fom of an object { source: 123, target: 312 }\nfunction isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib, flowId, isValidConnection = alwaysValid, nodeLookup, }) {\n    const isTarget = fromType === 'target';\n    const handleDomNode = handle\n        ? doc.querySelector(`.${lib}-flow__handle[data-id=\"${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}\"]`)\n        : null;\n    const { x, y } = getEventPosition(event);\n    const handleBelow = doc.elementFromPoint(x, y);\n    /*\n     * we always want to prioritize the handle below the mouse cursor over the closest distance handle,\n     * because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor\n     */\n    const handleToCheck = handleBelow?.classList.contains(`${lib}-flow__handle`) ? handleBelow : handleDomNode;\n    const result = {\n        handleDomNode: handleToCheck,\n        isValid: false,\n        connection: null,\n        toHandle: null,\n    };\n    if (handleToCheck) {\n        const handleType = getHandleType(undefined, handleToCheck);\n        const handleNodeId = handleToCheck.getAttribute('data-nodeid');\n        const handleId = handleToCheck.getAttribute('data-handleid');\n        const connectable = handleToCheck.classList.contains('connectable');\n        const connectableEnd = handleToCheck.classList.contains('connectableend');\n        if (!handleNodeId || !handleType) {\n            return result;\n        }\n        const connection = {\n            source: isTarget ? handleNodeId : fromNodeId,\n            sourceHandle: isTarget ? handleId : fromHandleId,\n            target: isTarget ? fromNodeId : handleNodeId,\n            targetHandle: isTarget ? fromHandleId : handleId,\n        };\n        result.connection = connection;\n        const isConnectable = connectable && connectableEnd;\n        // in strict mode we don't allow target to target or source to source connections\n        const isValid = isConnectable &&\n            (connectionMode === ConnectionMode.Strict\n                ? (isTarget && handleType === 'source') || (!isTarget && handleType === 'target')\n                : handleNodeId !== fromNodeId || handleId !== fromHandleId);\n        result.isValid = isValid && isValidConnection(connection);\n        result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, true);\n    }\n    return result;\n}\nconst XYHandle = {\n    onPointerDown,\n    isValid: isValidHandle,\n};\n\nfunction XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ translateExtent, width, height, zoomStep = 10, pannable = true, zoomable = true, inversePan = false, }) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const zoomHandler = (event) => {\n            const transform = getTransform();\n            if (event.sourceEvent.type !== 'wheel' || !panZoom) {\n                return;\n            }\n            const pinchDelta = -event.sourceEvent.deltaY *\n                (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) *\n                zoomStep;\n            const nextZoom = transform[2] * Math.pow(2, pinchDelta);\n            panZoom.scaleTo(nextZoom);\n        };\n        let panStart = [0, 0];\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panStartHandler = (event) => {\n            if (event.sourceEvent.type === 'mousedown' || event.sourceEvent.type === 'touchstart') {\n                panStart = [\n                    event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                    event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n                ];\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panHandler = (event) => {\n            const transform = getTransform();\n            if ((event.sourceEvent.type !== 'mousemove' && event.sourceEvent.type !== 'touchmove') || !panZoom) {\n                return;\n            }\n            const panCurrent = [\n                event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n            ];\n            const panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];\n            panStart = panCurrent;\n            const moveScale = getViewScale() * Math.max(transform[2], Math.log(transform[2])) * (inversePan ? -1 : 1);\n            const position = {\n                x: transform[0] - panDelta[0] * moveScale,\n                y: transform[1] - panDelta[1] * moveScale,\n            };\n            const extent = [\n                [0, 0],\n                [width, height],\n            ];\n            panZoom.setViewportConstrained({\n                x: position.x,\n                y: position.y,\n                zoom: transform[2],\n            }, extent, translateExtent);\n        };\n        const zoomAndPanHandler = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()\n            .on('start', panStartHandler)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom', pannable ? panHandler : null)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom.wheel', zoomable ? zoomHandler : null);\n        selection.call(zoomAndPanHandler, {});\n    }\n    function destroy() {\n        selection.on('zoom', null);\n    }\n    return {\n        update,\n        destroy,\n        pointer: d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst viewChanged = (prevViewport, eventViewport) => prevViewport.x !== eventViewport.x || prevViewport.y !== eventViewport.y || prevViewport.zoom !== eventViewport.k;\nconst transformToViewport = (transform) => ({\n    x: transform.x,\n    y: transform.y,\n    zoom: transform.k,\n});\nconst viewportToTransform = ({ x, y, zoom }) => d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity.translate(x, y).scale(zoom);\nconst isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);\nconst isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);\nconst getD3Transition = (selection, duration = 0, onEnd = () => { }) => {\n    const hasDuration = typeof duration === 'number' && duration > 0;\n    if (!hasDuration) {\n        onEnd();\n    }\n    return hasDuration ? selection.transition().duration(duration).on('end', onEnd) : selection;\n};\nconst wheelDelta = (event) => {\n    const factor = event.ctrlKey && isMacOs() ? 10 : 1;\n    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;\n};\n\nfunction createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd, }) {\n    return (event) => {\n        if (isWrappedWithClass(event, noWheelClassName)) {\n            return false;\n        }\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        const currentZoom = d3Selection.property('__zoom').k || 1;\n        // macos sets ctrlKey=true for pinch gesture on a trackpad\n        if (event.ctrlKey && zoomOnPinch) {\n            const point = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(event);\n            const pinchDelta = wheelDelta(event);\n            const zoom = currentZoom * Math.pow(2, pinchDelta);\n            // @ts-ignore\n            d3Zoom.scaleTo(d3Selection, zoom, point, event);\n            return;\n        }\n        /*\n         * increase scroll speed in firefox\n         * firefox: deltaMode === 1; chrome: deltaMode === 0\n         */\n        const deltaNormalize = event.deltaMode === 1 ? 20 : 1;\n        let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;\n        let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;\n        // this enables vertical scrolling with shift + scroll on windows\n        if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {\n            deltaX = event.deltaY * deltaNormalize;\n            deltaY = 0;\n        }\n        d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed, \n        // @ts-ignore\n        { internal: true });\n        const nextViewport = transformToViewport(d3Selection.property('__zoom'));\n        clearTimeout(zoomPanValues.panScrollTimeout);\n        /*\n         * for pan on scroll we need to handle the event calls on our own\n         * we can't use the start, zoom and end events from d3-zoom\n         * because start and move gets called on every scroll event and not once at the beginning\n         */\n        if (!zoomPanValues.isPanScrolling) {\n            zoomPanValues.isPanScrolling = true;\n            onPanZoomStart?.(event, nextViewport);\n        }\n        if (zoomPanValues.isPanScrolling) {\n            onPanZoom?.(event, nextViewport);\n            zoomPanValues.panScrollTimeout = setTimeout(() => {\n                onPanZoomEnd?.(event, nextViewport);\n                zoomPanValues.isPanScrolling = false;\n            }, 150);\n        }\n    };\n}\nfunction createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {\n    return function (event, d) {\n        const isWheel = event.type === 'wheel';\n        // we still want to enable pinch zooming even if preventScrolling is set to false\n        const preventZoom = !preventScrolling && isWheel && !event.ctrlKey;\n        const hasNoWheelClass = isWrappedWithClass(event, noWheelClassName);\n        // if user is pinch zooming above a nowheel element, we don't want the browser to zoom\n        if (event.ctrlKey && isWheel && hasNoWheelClass) {\n            event.preventDefault();\n        }\n        if (preventZoom || hasNoWheelClass) {\n            return null;\n        }\n        event.preventDefault();\n        d3ZoomHandler.call(this, event, d);\n    };\n}\nfunction createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        const viewport = transformToViewport(event.transform);\n        // we need to remember it here, because it's always 0 in the \"zoom\" event\n        zoomPanValues.mouseButton = event.sourceEvent?.button || 0;\n        zoomPanValues.isZoomingOrPanning = true;\n        zoomPanValues.prevViewport = viewport;\n        if (event.sourceEvent?.type === 'mousedown') {\n            onDraggingChange(true);\n        }\n        if (onPanZoomStart) {\n            onPanZoomStart?.(event.sourceEvent, viewport);\n        }\n    };\n}\nfunction createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom, }) {\n    return (event) => {\n        zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0));\n        if (!event.sourceEvent?.sync) {\n            onTransformChange([event.transform.x, event.transform.y, event.transform.k]);\n        }\n        if (onPanZoom && !event.sourceEvent?.internal) {\n            onPanZoom?.(event.sourceEvent, transformToViewport(event.transform));\n        }\n    };\n}\nfunction createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu, }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        zoomPanValues.isZoomingOrPanning = false;\n        if (onPaneContextMenu &&\n            isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) &&\n            !zoomPanValues.usedRightMouseButton &&\n            event.sourceEvent) {\n            onPaneContextMenu(event.sourceEvent);\n        }\n        zoomPanValues.usedRightMouseButton = false;\n        onDraggingChange(false);\n        if (onPanZoomEnd && viewChanged(zoomPanValues.prevViewport, event.transform)) {\n            const viewport = transformToViewport(event.transform);\n            zoomPanValues.prevViewport = viewport;\n            clearTimeout(zoomPanValues.timerId);\n            zoomPanValues.timerId = setTimeout(() => {\n                onPanZoomEnd?.(event.sourceEvent, viewport);\n            }, \n            // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll\n            panOnScroll ? 150 : 0);\n        }\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib, }) {\n    return (event) => {\n        const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;\n        const pinchZoom = zoomOnPinch && event.ctrlKey;\n        if (event.button === 1 &&\n            event.type === 'mousedown' &&\n            (isWrappedWithClass(event, `${lib}-flow__node`) || isWrappedWithClass(event, `${lib}-flow__edge`))) {\n            return true;\n        }\n        // if all interactions are disabled, we prevent all zoom events\n        if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {\n            return false;\n        }\n        // during a selection we prevent all other interactions\n        if (userSelectionActive) {\n            return false;\n        }\n        // if the target element is inside an element with the nowheel class, we prevent zooming\n        if (isWrappedWithClass(event, noWheelClassName) && event.type === 'wheel') {\n            return false;\n        }\n        // if the target element is inside an element with the nopan class, we prevent panning\n        if (isWrappedWithClass(event, noPanClassName) &&\n            (event.type !== 'wheel' || (panOnScroll && event.type === 'wheel' && !zoomActivationKeyPressed))) {\n            return false;\n        }\n        if (!zoomOnPinch && event.ctrlKey && event.type === 'wheel') {\n            return false;\n        }\n        if (!zoomOnPinch && event.type === 'touchstart' && event.touches?.length > 1) {\n            event.preventDefault(); // if you manage to start with 2 touches, we prevent native zoom\n            return false;\n        }\n        // when there is no scroll handling enabled, we prevent all wheel events\n        if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === 'wheel') {\n            return false;\n        }\n        // if the pane is not movable, we prevent dragging it with mousestart or touchstart\n        if (!panOnDrag && (event.type === 'mousedown' || event.type === 'touchstart')) {\n            return false;\n        }\n        // if the pane is only movable using allowed clicks\n        if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === 'mousedown') {\n            return false;\n        }\n        // We only allow right clicks if pan on drag is set to right click\n        const buttonAllowed = (Array.isArray(panOnDrag) && panOnDrag.includes(event.button)) || !event.button || event.button <= 1;\n        // default filter for d3-zoom\n        return (!event.ctrlKey || event.type === 'wheel') && buttonAllowed;\n    };\n}\n\nfunction XYPanZoom({ domNode, minZoom, maxZoom, paneClickDistance, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange, }) {\n    const zoomPanValues = {\n        isZoomingOrPanning: false,\n        usedRightMouseButton: false,\n        prevViewport: { x: 0, y: 0, zoom: 0 },\n        mouseButton: 0,\n        timerId: undefined,\n        panScrollTimeout: undefined,\n        isPanScrolling: false,\n    };\n    const bbox = domNode.getBoundingClientRect();\n    const d3ZoomInstance = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()\n        .clickDistance(!isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance)\n        .scaleExtent([minZoom, maxZoom])\n        .translateExtent(translateExtent);\n    const d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode).call(d3ZoomInstance);\n    setViewportConstrained({\n        x: viewport.x,\n        y: viewport.y,\n        zoom: clamp(viewport.zoom, minZoom, maxZoom),\n    }, [\n        [0, 0],\n        [bbox.width, bbox.height],\n    ], translateExtent);\n    const d3ZoomHandler = d3Selection.on('wheel.zoom');\n    const d3DblClickZoomHandler = d3Selection.on('dblclick.zoom');\n    d3ZoomInstance.wheelDelta(wheelDelta);\n    function setTransform(transform, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.transform(getD3Transition(d3Selection, options?.duration, () => resolve(true)), transform);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    // public functions\n    function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib, onTransformChange, }) {\n        if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {\n            destroy();\n        }\n        const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;\n        const wheelHandler = isPanOnScroll\n            ? createPanOnScrollHandler({\n                zoomPanValues,\n                noWheelClassName,\n                d3Selection,\n                d3Zoom: d3ZoomInstance,\n                panOnScrollMode,\n                panOnScrollSpeed,\n                zoomOnPinch,\n                onPanZoomStart,\n                onPanZoom,\n                onPanZoomEnd,\n            })\n            : createZoomOnScrollHandler({\n                noWheelClassName,\n                preventScrolling,\n                d3ZoomHandler,\n            });\n        d3Selection.on('wheel.zoom', wheelHandler, { passive: false });\n        if (!userSelectionActive) {\n            // pan zoom start\n            const startHandler = createPanZoomStartHandler({\n                zoomPanValues,\n                onDraggingChange,\n                onPanZoomStart,\n            });\n            d3ZoomInstance.on('start', startHandler);\n            // pan zoom\n            const panZoomHandler = createPanZoomHandler({\n                zoomPanValues,\n                panOnDrag,\n                onPaneContextMenu: !!onPaneContextMenu,\n                onPanZoom,\n                onTransformChange,\n            });\n            d3ZoomInstance.on('zoom', panZoomHandler);\n            // pan zoom end\n            const panZoomEndHandler = createPanZoomEndHandler({\n                zoomPanValues,\n                panOnDrag,\n                panOnScroll,\n                onPaneContextMenu,\n                onPanZoomEnd,\n                onDraggingChange,\n            });\n            d3ZoomInstance.on('end', panZoomEndHandler);\n        }\n        const filter = createFilter({\n            zoomActivationKeyPressed,\n            panOnDrag,\n            zoomOnScroll,\n            panOnScroll,\n            zoomOnDoubleClick,\n            zoomOnPinch,\n            userSelectionActive,\n            noPanClassName,\n            noWheelClassName,\n            lib,\n        });\n        d3ZoomInstance.filter(filter);\n        /*\n         * We cannot add zoomOnDoubleClick to the filter above because\n         * double tapping on touch screens circumvents the filter and\n         * dblclick.zoom is fired on the selection directly\n         */\n        if (zoomOnDoubleClick) {\n            d3Selection.on('dblclick.zoom', d3DblClickZoomHandler);\n        }\n        else {\n            d3Selection.on('dblclick.zoom', null);\n        }\n    }\n    function destroy() {\n        d3ZoomInstance.on('zoom', null);\n    }\n    async function setViewportConstrained(viewport, extent, translateExtent) {\n        const nextTransform = viewportToTransform(viewport);\n        const contrainedTransform = d3ZoomInstance?.constrain()(nextTransform, extent, translateExtent);\n        if (contrainedTransform) {\n            await setTransform(contrainedTransform);\n        }\n        return new Promise((resolve) => resolve(contrainedTransform));\n    }\n    async function setViewport(viewport, options) {\n        const nextTransform = viewportToTransform(viewport);\n        await setTransform(nextTransform, options);\n        return new Promise((resolve) => resolve(nextTransform));\n    }\n    function syncViewport(viewport) {\n        if (d3Selection) {\n            const nextTransform = viewportToTransform(viewport);\n            const currentTransform = d3Selection.property('__zoom');\n            if (currentTransform.k !== viewport.zoom ||\n                currentTransform.x !== viewport.x ||\n                currentTransform.y !== viewport.y) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                d3ZoomInstance?.transform(d3Selection, nextTransform, null, { sync: true });\n            }\n        }\n    }\n    function getViewport() {\n        const transform = d3Selection ? (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(d3Selection.node()) : { x: 0, y: 0, k: 1 };\n        return { x: transform.x, y: transform.y, zoom: transform.k };\n    }\n    function scaleTo(zoom, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.scaleTo(getD3Transition(d3Selection, options?.duration, () => resolve(true)), zoom);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function scaleBy(factor, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.scaleBy(getD3Transition(d3Selection, options?.duration, () => resolve(true)), factor);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function setScaleExtent(scaleExtent) {\n        d3ZoomInstance?.scaleExtent(scaleExtent);\n    }\n    function setTranslateExtent(translateExtent) {\n        d3ZoomInstance?.translateExtent(translateExtent);\n    }\n    function setClickDistance(distance) {\n        const validDistance = !isNumeric(distance) || distance < 0 ? 0 : distance;\n        d3ZoomInstance?.clickDistance(validDistance);\n    }\n    return {\n        update,\n        destroy,\n        setViewport,\n        setViewportConstrained,\n        getViewport,\n        scaleTo,\n        scaleBy,\n        setScaleExtent,\n        setTranslateExtent,\n        syncViewport,\n        setClickDistance,\n    };\n}\n\n/**\n * Used to determine the variant of the resize control\n *\n * @public\n */\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n    ResizeControlVariant[\"Line\"] = \"line\";\n    ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\nconst XY_RESIZER_HANDLE_POSITIONS = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst XY_RESIZER_LINE_POSITIONS = ['top', 'right', 'bottom', 'left'];\n\n/**\n * Get all connecting edges for a given set of nodes\n * @param width - new width of the node\n * @param prevWidth - previous width of the node\n * @param height - new height of the node\n * @param prevHeight - previous height of the node\n * @param affectsX - whether to invert the resize direction for the x axis\n * @param affectsY - whether to invert the resize direction for the y axis\n * @returns array of two numbers representing the direction of the resize for each axis, 0 = no change, 1 = increase, -1 = decrease\n */\nfunction getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY, }) {\n    const deltaWidth = width - prevWidth;\n    const deltaHeight = height - prevHeight;\n    const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n    if (deltaWidth && affectsX) {\n        direction[0] = direction[0] * -1;\n    }\n    if (deltaHeight && affectsY) {\n        direction[1] = direction[1] * -1;\n    }\n    return direction;\n}\n/**\n * Parses the control position that is being dragged to dimensions that are being resized\n * @param controlPosition - position of the control that is being dragged\n * @returns isHorizontal, isVertical, affectsX, affectsY,\n */\nfunction getControlDirection(controlPosition) {\n    const isHorizontal = controlPosition.includes('right') || controlPosition.includes('left');\n    const isVertical = controlPosition.includes('bottom') || controlPosition.includes('top');\n    const affectsX = controlPosition.includes('left');\n    const affectsY = controlPosition.includes('top');\n    return {\n        isHorizontal,\n        isVertical,\n        affectsX,\n        affectsY,\n    };\n}\nfunction getLowerExtentClamp(lowerExtent, lowerBound) {\n    return Math.max(0, lowerBound - lowerExtent);\n}\nfunction getUpperExtentClamp(upperExtent, upperBound) {\n    return Math.max(0, upperExtent - upperBound);\n}\nfunction getSizeClamp(size, minSize, maxSize) {\n    return Math.max(0, minSize - size, size - maxSize);\n}\nfunction xor(a, b) {\n    return a ? !b : b;\n}\n/**\n * Calculates new width & height and x & y of node after resize based on pointer position\n * @description - Buckle up, this is a chunky one... If you want to determine the new dimensions of a node after a resize,\n * you have to account for all possible restrictions: min/max width/height of the node, the maximum extent the node is allowed\n * to move in (in this case: resize into) determined by the parent node, the minimal extent determined by child nodes\n * with expandParent or extent: 'parent' set and oh yeah, these things also have to work with keepAspectRatio!\n * The way this is done is by determining how much each of these restricting actually restricts the resize and then applying the\n * strongest restriction. Because the resize affects x, y and width, height and width, height of a opposing side with keepAspectRatio,\n * the resize amount is always kept in distX & distY amount (the distance in mouse movement)\n * Instead of clamping each value, we first calculate the biggest 'clamp' (for the lack of a better name) and then apply it to all values.\n * To complicate things nodeOrigin has to be taken into account as well. This is done by offsetting the nodes as if their origin is [0, 0],\n * then calculating the restrictions as usual\n * @param startValues - starting values of resize\n * @param controlDirection - dimensions affected by the resize\n * @param pointerPosition - the current pointer position corrected for snapping\n * @param boundaries - minimum and maximum dimensions of the node\n * @param keepAspectRatio - prevent changes of asprect ratio\n * @returns x, y, width and height of the node after resize\n */\nfunction getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {\n    let { affectsX, affectsY } = controlDirection;\n    const { isHorizontal, isVertical } = controlDirection;\n    const isDiagonal = isHorizontal && isVertical;\n    const { xSnapped, ySnapped } = pointerPosition;\n    const { minWidth, maxWidth, minHeight, maxHeight } = boundaries;\n    const { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio } = startValues;\n    let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);\n    let distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);\n    const newWidth = startWidth + (affectsX ? -distX : distX);\n    const newHeight = startHeight + (affectsY ? -distY : distY);\n    const originOffsetX = -nodeOrigin[0] * startWidth;\n    const originOffsetY = -nodeOrigin[1] * startHeight;\n    // Check if maxWidth, minWWidth, maxHeight, minHeight are restricting the resize\n    let clampX = getSizeClamp(newWidth, minWidth, maxWidth);\n    let clampY = getSizeClamp(newHeight, minHeight, maxHeight);\n    // Check if extent is restricting the resize\n    if (extent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);\n        }\n        else if (!affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);\n        }\n        if (affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);\n        }\n        else if (!affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the child extent is restricting the resize\n    if (childExtent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);\n        }\n        else if (!affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);\n        }\n        if (affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);\n        }\n        else if (!affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the aspect ratio resizing of the other side is restricting the resize\n    if (keepAspectRatio) {\n        if (isHorizontal) {\n            // Check if the max dimensions might be restricting the resize\n            const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;\n            clampX = Math.max(clampX, aspectHeightClamp);\n            // Check if the extent is restricting the resize\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) *\n                            aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n            // Check if the child extent is restricting the resize\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n        }\n        // Do the same thing for vertical resizing\n        if (isVertical) {\n            const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;\n            clampY = Math.max(clampY, aspectWidthClamp);\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) /\n                            aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n        }\n    }\n    distY = distY + (distY < 0 ? clampY : -clampY);\n    distX = distX + (distX < 0 ? clampX : -clampX);\n    if (keepAspectRatio) {\n        if (isDiagonal) {\n            if (newWidth > newHeight * aspectRatio) {\n                distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;\n            }\n            else {\n                distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;\n            }\n        }\n        else {\n            if (isHorizontal) {\n                distY = distX / aspectRatio;\n                affectsY = affectsX;\n            }\n            else {\n                distX = distY * aspectRatio;\n                affectsX = affectsY;\n            }\n        }\n    }\n    const x = affectsX ? startX + distX : startX;\n    const y = affectsY ? startY + distY : startY;\n    return {\n        width: startWidth + (affectsX ? -distX : distX),\n        height: startHeight + (affectsY ? -distY : distY),\n        x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,\n        y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y,\n    };\n}\n\nconst initPrevValues = { width: 0, height: 0, x: 0, y: 0 };\nconst initStartValues = {\n    ...initPrevValues,\n    pointerX: 0,\n    pointerY: 0,\n    aspectRatio: 1,\n};\nfunction nodeToParentExtent(node) {\n    return [\n        [0, 0],\n        [node.measured.width, node.measured.height],\n    ];\n}\nfunction nodeToChildExtent(child, parent, nodeOrigin) {\n    const x = parent.position.x + child.position.x;\n    const y = parent.position.y + child.position.y;\n    const width = child.measured.width ?? 0;\n    const height = child.measured.height ?? 0;\n    const originOffsetX = nodeOrigin[0] * width;\n    const originOffsetY = nodeOrigin[1] * height;\n    return [\n        [x - originOffsetX, y - originOffsetY],\n        [x + width - originOffsetX, y + height - originOffsetY],\n    ];\n}\nfunction XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ controlPosition, boundaries, keepAspectRatio, resizeDirection, onResizeStart, onResize, onResizeEnd, shouldResize, }) {\n        let prevValues = { ...initPrevValues };\n        let startValues = { ...initStartValues };\n        const controlDirection = getControlDirection(controlPosition);\n        let node = undefined;\n        let containerBounds = null;\n        let childNodes = [];\n        let parentNode = undefined; // Needed to fix expandParent\n        let parentExtent = undefined;\n        let childExtent = undefined;\n        const dragHandler = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .on('start', (event) => {\n            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, paneDomNode } = getStoreItems();\n            node = nodeLookup.get(nodeId);\n            if (!node) {\n                return;\n            }\n            containerBounds = paneDomNode?.getBoundingClientRect() ?? null;\n            const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            prevValues = {\n                width: node.measured.width ?? 0,\n                height: node.measured.height ?? 0,\n                x: node.position.x ?? 0,\n                y: node.position.y ?? 0,\n            };\n            startValues = {\n                ...prevValues,\n                pointerX: xSnapped,\n                pointerY: ySnapped,\n                aspectRatio: prevValues.width / prevValues.height,\n            };\n            parentNode = undefined;\n            if (node.parentId && (node.extent === 'parent' || node.expandParent)) {\n                parentNode = nodeLookup.get(node.parentId);\n                parentExtent = parentNode && node.extent === 'parent' ? nodeToParentExtent(parentNode) : undefined;\n            }\n            /*\n             * Collect all child nodes to correct their relative positions when top/left changes\n             * Determine largest minimal extent the parent node is allowed to resize to\n             */\n            childNodes = [];\n            childExtent = undefined;\n            for (const [childId, child] of nodeLookup) {\n                if (child.parentId === nodeId) {\n                    childNodes.push({\n                        id: childId,\n                        position: { ...child.position },\n                        extent: child.extent,\n                    });\n                    if (child.extent === 'parent' || child.expandParent) {\n                        const extent = nodeToChildExtent(child, node, child.origin ?? nodeOrigin);\n                        if (childExtent) {\n                            childExtent = [\n                                [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],\n                                [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])],\n                            ];\n                        }\n                        else {\n                            childExtent = extent;\n                        }\n                    }\n                }\n            }\n            onResizeStart?.(event, { ...prevValues });\n        })\n            .on('drag', (event) => {\n            const { transform, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems();\n            const pointerPosition = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            const childChanges = [];\n            if (!node) {\n                return;\n            }\n            const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues;\n            const change = {};\n            const nodeOrigin = node.origin ?? storeNodeOrigin;\n            const { width, height, x, y } = getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, parentExtent, childExtent);\n            const isWidthChange = width !== prevWidth;\n            const isHeightChange = height !== prevHeight;\n            const isXPosChange = x !== prevX && isWidthChange;\n            const isYPosChange = y !== prevY && isHeightChange;\n            if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {\n                return;\n            }\n            if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {\n                change.x = isXPosChange ? x : prevValues.x;\n                change.y = isYPosChange ? y : prevValues.y;\n                prevValues.x = change.x;\n                prevValues.y = change.y;\n                /*\n                 * when top/left changes, correct the relative positions of child nodes\n                 * so that they stay in the same position\n                 */\n                if (childNodes.length > 0) {\n                    const xChange = x - prevX;\n                    const yChange = y - prevY;\n                    for (const childNode of childNodes) {\n                        childNode.position = {\n                            x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),\n                            y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight),\n                        };\n                        childChanges.push(childNode);\n                    }\n                }\n            }\n            if (isWidthChange || isHeightChange) {\n                change.width =\n                    isWidthChange && (!resizeDirection || resizeDirection === 'horizontal') ? width : prevValues.width;\n                change.height =\n                    isHeightChange && (!resizeDirection || resizeDirection === 'vertical') ? height : prevValues.height;\n                prevValues.width = change.width;\n                prevValues.height = change.height;\n            }\n            // Fix expandParent when resizing from top/left\n            if (parentNode && node.expandParent) {\n                const xLimit = nodeOrigin[0] * (change.width ?? 0);\n                if (change.x && change.x < xLimit) {\n                    prevValues.x = xLimit;\n                    startValues.x = startValues.x - (change.x - xLimit);\n                }\n                const yLimit = nodeOrigin[1] * (change.height ?? 0);\n                if (change.y && change.y < yLimit) {\n                    prevValues.y = yLimit;\n                    startValues.y = startValues.y - (change.y - yLimit);\n                }\n            }\n            const direction = getResizeDirection({\n                width: prevValues.width,\n                prevWidth,\n                height: prevValues.height,\n                prevHeight,\n                affectsX: controlDirection.affectsX,\n                affectsY: controlDirection.affectsY,\n            });\n            const nextValues = { ...prevValues, direction };\n            const callResize = shouldResize?.(event, nextValues);\n            if (callResize === false) {\n                return;\n            }\n            onResize?.(event, nextValues);\n            onChange(change, childChanges);\n        })\n            .on('end', (event) => {\n            onResizeEnd?.(event, { ...prevValues });\n            onEnd?.({ ...prevValues });\n        });\n        selection.call(dragHandler);\n    }\n    function destroy() {\n        selection.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9zeXN0ZW0vZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDZ0I7QUFDYTs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQsd0NBQXdDLEtBQUs7QUFDN0MsNkJBQTZCLGdDQUFnQyxpQ0FBaUMsWUFBWSxjQUFjLHNEQUFzRCxjQUFjLEdBQUc7QUFDL0w7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRCx1Q0FBdUMsR0FBRztBQUMxQyx3R0FBd0csSUFBSTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQkFBcUI7QUFDL0IsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLDJDQUEyQztBQUN2RCxZQUFZLDRFQUE0RTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpREFBaUQ7QUFDdEUsc0JBQXNCLHdEQUFNO0FBQzVCLHNCQUFzQixvSEFBb0g7QUFDMUksMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsNEJBQTRCLG1EQUFJO0FBQ2hDO0FBQ0Esb0JBQW9CLHVFQUF1RTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZUFBZTtBQUNwRCxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsK0RBQStEO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQTJEO0FBQy9FO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xELHNCQUFzQixlQUFlO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNjlDIiwic291cmNlcyI6WyIvVXNlcnMvdXNlci9ub3Rlc29udW5pdmVyc2Uvbm9kZV9tb2R1bGVzL0B4eWZsb3cvc3lzdGVtL2Rpc3QvZXNtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRyYWcgfSBmcm9tICdkMy1kcmFnJztcbmltcG9ydCB7IHNlbGVjdCwgcG9pbnRlciB9IGZyb20gJ2QzLXNlbGVjdGlvbic7XG5pbXBvcnQgeyB6b29tLCB6b29tSWRlbnRpdHksIHpvb21UcmFuc2Zvcm0gfSBmcm9tICdkMy16b29tJztcblxuY29uc3QgZXJyb3JNZXNzYWdlcyA9IHtcbiAgICBlcnJvcjAwMTogKCkgPT4gJ1tSZWFjdCBGbG93XTogU2VlbXMgbGlrZSB5b3UgaGF2ZSBub3QgdXNlZCB6dXN0YW5kIHByb3ZpZGVyIGFzIGFuIGFuY2VzdG9yLiBIZWxwOiBodHRwczovL3JlYWN0Zmxvdy5kZXYvZXJyb3IjMDAxJyxcbiAgICBlcnJvcjAwMjogKCkgPT4gXCJJdCBsb29rcyBsaWtlIHlvdSd2ZSBjcmVhdGVkIGEgbmV3IG5vZGVUeXBlcyBvciBlZGdlVHlwZXMgb2JqZWN0LiBJZiB0aGlzIHdhc24ndCBvbiBwdXJwb3NlIHBsZWFzZSBkZWZpbmUgdGhlIG5vZGVUeXBlcy9lZGdlVHlwZXMgb3V0c2lkZSBvZiB0aGUgY29tcG9uZW50IG9yIG1lbW9pemUgdGhlbS5cIixcbiAgICBlcnJvcjAwMzogKG5vZGVUeXBlKSA9PiBgTm9kZSB0eXBlIFwiJHtub2RlVHlwZX1cIiBub3QgZm91bmQuIFVzaW5nIGZhbGxiYWNrIHR5cGUgXCJkZWZhdWx0XCIuYCxcbiAgICBlcnJvcjAwNDogKCkgPT4gJ1RoZSBSZWFjdCBGbG93IHBhcmVudCBjb250YWluZXIgbmVlZHMgYSB3aWR0aCBhbmQgYSBoZWlnaHQgdG8gcmVuZGVyIHRoZSBncmFwaC4nLFxuICAgIGVycm9yMDA1OiAoKSA9PiAnT25seSBjaGlsZCBub2RlcyBjYW4gdXNlIGEgcGFyZW50IGV4dGVudC4nLFxuICAgIGVycm9yMDA2OiAoKSA9PiBcIkNhbid0IGNyZWF0ZSBlZGdlLiBBbiBlZGdlIG5lZWRzIGEgc291cmNlIGFuZCBhIHRhcmdldC5cIixcbiAgICBlcnJvcjAwNzogKGlkKSA9PiBgVGhlIG9sZCBlZGdlIHdpdGggaWQ9JHtpZH0gZG9lcyBub3QgZXhpc3QuYCxcbiAgICBlcnJvcjAwOTogKHR5cGUpID0+IGBNYXJrZXIgdHlwZSBcIiR7dHlwZX1cIiBkb2Vzbid0IGV4aXN0LmAsXG4gICAgZXJyb3IwMDg6IChoYW5kbGVUeXBlLCB7IGlkLCBzb3VyY2VIYW5kbGUsIHRhcmdldEhhbmRsZSB9KSA9PiBgQ291bGRuJ3QgY3JlYXRlIGVkZ2UgZm9yICR7aGFuZGxlVHlwZX0gaGFuZGxlIGlkOiBcIiR7aGFuZGxlVHlwZSA9PT0gJ3NvdXJjZScgPyBzb3VyY2VIYW5kbGUgOiB0YXJnZXRIYW5kbGV9XCIsIGVkZ2UgaWQ6ICR7aWR9LmAsXG4gICAgZXJyb3IwMTA6ICgpID0+ICdIYW5kbGU6IE5vIG5vZGUgaWQgZm91bmQuIE1ha2Ugc3VyZSB0byBvbmx5IHVzZSBhIEhhbmRsZSBpbnNpZGUgYSBjdXN0b20gTm9kZS4nLFxuICAgIGVycm9yMDExOiAoZWRnZVR5cGUpID0+IGBFZGdlIHR5cGUgXCIke2VkZ2VUeXBlfVwiIG5vdCBmb3VuZC4gVXNpbmcgZmFsbGJhY2sgdHlwZSBcImRlZmF1bHRcIi5gLFxuICAgIGVycm9yMDEyOiAoaWQpID0+IGBOb2RlIHdpdGggaWQgXCIke2lkfVwiIGRvZXMgbm90IGV4aXN0LCBpdCBtYXkgaGF2ZSBiZWVuIHJlbW92ZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgbm9kZSBpcyBkZWxldGVkIGJlZm9yZSB0aGUgXCJvbk5vZGVDbGlja1wiIGhhbmRsZXIgaXMgY2FsbGVkLmAsXG4gICAgZXJyb3IwMTM6IChsaWIgPSAncmVhY3QnKSA9PiBgSXQgc2VlbXMgdGhhdCB5b3UgaGF2ZW4ndCBsb2FkZWQgdGhlIHN0eWxlcy4gUGxlYXNlIGltcG9ydCAnQHh5Zmxvdy8ke2xpYn0vZGlzdC9zdHlsZS5jc3MnIG9yIGJhc2UuY3NzIHRvIG1ha2Ugc3VyZSBldmVyeXRoaW5nIGlzIHdvcmtpbmcgcHJvcGVybHkuYCxcbiAgICBlcnJvcjAxNDogKCkgPT4gJ3VzZU5vZGVDb25uZWN0aW9uczogTm8gbm9kZSBJRCBmb3VuZC4gQ2FsbCB1c2VOb2RlQ29ubmVjdGlvbnMgaW5zaWRlIGEgY3VzdG9tIE5vZGUgb3IgcHJvdmlkZSBhIG5vZGUgSUQuJyxcbiAgICBlcnJvcjAxNTogKCkgPT4gJ0l0IHNlZW1zIHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gZHJhZyBhIG5vZGUgdGhhdCBpcyBub3QgaW5pdGlhbGl6ZWQuIFBsZWFzZSB1c2Ugb25Ob2Rlc0NoYW5nZSBhcyBleHBsYWluZWQgaW4gdGhlIGRvY3MuJyxcbn07XG5jb25zdCBpbmZpbml0ZUV4dGVudCA9IFtcbiAgICBbTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFldLFxuICAgIFtOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWV0sXG5dO1xuY29uc3QgZWxlbWVudFNlbGVjdGlvbktleXMgPSBbJ0VudGVyJywgJyAnLCAnRXNjYXBlJ107XG5cbi8qKlxuICogVGhlIGBDb25uZWN0aW9uTW9kZWAgaXMgdXNlZCB0byBzZXQgdGhlIG1vZGUgb2YgY29ubmVjdGlvbiBiZXR3ZWVuIG5vZGVzLlxuICogVGhlIGBTdHJpY3RgIG1vZGUgaXMgdGhlIGRlZmF1bHQgb25lIGFuZCBvbmx5IGFsbG93cyBzb3VyY2UgdG8gdGFyZ2V0IGVkZ2VzLlxuICogYExvb3NlYCBtb2RlIGFsbG93cyBzb3VyY2UgdG8gc291cmNlIGFuZCB0YXJnZXQgdG8gdGFyZ2V0IGVkZ2VzIGFzIHdlbGwuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgQ29ubmVjdGlvbk1vZGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25Nb2RlKSB7XG4gICAgQ29ubmVjdGlvbk1vZGVbXCJTdHJpY3RcIl0gPSBcInN0cmljdFwiO1xuICAgIENvbm5lY3Rpb25Nb2RlW1wiTG9vc2VcIl0gPSBcImxvb3NlXCI7XG59KShDb25uZWN0aW9uTW9kZSB8fCAoQ29ubmVjdGlvbk1vZGUgPSB7fSkpO1xuLyoqXG4gKiBUaGlzIGVudW0gaXMgdXNlZCB0byBzZXQgdGhlIGRpZmZlcmVudCBtb2RlcyBvZiBwYW5uaW5nIHRoZSB2aWV3cG9ydCB3aGVuIHRoZVxuICogdXNlciBzY3JvbGxzLiBUaGUgYEZyZWVgIG1vZGUgYWxsb3dzIHRoZSB1c2VyIHRvIHBhbiBpbiBhbnkgZGlyZWN0aW9uIGJ5IHNjcm9sbGluZ1xuICogd2l0aCBhIGRldmljZSBsaWtlIGEgdHJhY2twYWQuIFRoZSBgVmVydGljYWxgIGFuZCBgSG9yaXpvbnRhbGAgbW9kZXMgcmVzdHJpY3RcbiAqIHNjcm9sbCBwYW5uaW5nIHRvIG9ubHkgdGhlIHZlcnRpY2FsIG9yIGhvcml6b250YWwgYXhpcywgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFBhbk9uU2Nyb2xsTW9kZTtcbihmdW5jdGlvbiAoUGFuT25TY3JvbGxNb2RlKSB7XG4gICAgUGFuT25TY3JvbGxNb2RlW1wiRnJlZVwiXSA9IFwiZnJlZVwiO1xuICAgIFBhbk9uU2Nyb2xsTW9kZVtcIlZlcnRpY2FsXCJdID0gXCJ2ZXJ0aWNhbFwiO1xuICAgIFBhbk9uU2Nyb2xsTW9kZVtcIkhvcml6b250YWxcIl0gPSBcImhvcml6b250YWxcIjtcbn0pKFBhbk9uU2Nyb2xsTW9kZSB8fCAoUGFuT25TY3JvbGxNb2RlID0ge30pKTtcbnZhciBTZWxlY3Rpb25Nb2RlO1xuKGZ1bmN0aW9uIChTZWxlY3Rpb25Nb2RlKSB7XG4gICAgU2VsZWN0aW9uTW9kZVtcIlBhcnRpYWxcIl0gPSBcInBhcnRpYWxcIjtcbiAgICBTZWxlY3Rpb25Nb2RlW1wiRnVsbFwiXSA9IFwiZnVsbFwiO1xufSkoU2VsZWN0aW9uTW9kZSB8fCAoU2VsZWN0aW9uTW9kZSA9IHt9KSk7XG5jb25zdCBpbml0aWFsQ29ubmVjdGlvbiA9IHtcbiAgICBpblByb2dyZXNzOiBmYWxzZSxcbiAgICBpc1ZhbGlkOiBudWxsLFxuICAgIGZyb206IG51bGwsXG4gICAgZnJvbUhhbmRsZTogbnVsbCxcbiAgICBmcm9tUG9zaXRpb246IG51bGwsXG4gICAgZnJvbU5vZGU6IG51bGwsXG4gICAgdG86IG51bGwsXG4gICAgdG9IYW5kbGU6IG51bGwsXG4gICAgdG9Qb3NpdGlvbjogbnVsbCxcbiAgICB0b05vZGU6IG51bGwsXG59O1xuXG4vKipcbiAqIElmIHlvdSBzZXQgdGhlIGBjb25uZWN0aW9uTGluZVR5cGVgIHByb3Agb24geW91ciBbYDxSZWFjdEZsb3cgLz5gXSgvYXBpLXJlZmVyZW5jZS9yZWFjdC1mbG93I2Nvbm5lY3Rpb24tY29ubmVjdGlvbkxpbmVUeXBlKVxuICpjb21wb25lbnQsIGl0IHdpbGwgZGljdGF0ZSB0aGUgc3R5bGUgb2YgY29ubmVjdGlvbiBsaW5lIHJlbmRlcmVkIHdoZW4gY3JlYXRpbmdcbiAqbmV3IGVkZ2VzLlxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKiBAcmVtYXJrcyBJZiB5b3UgY2hvb3NlIHRvIHJlbmRlciBhIGN1c3RvbSBjb25uZWN0aW9uIGxpbmUgY29tcG9uZW50LCB0aGlzIHZhbHVlIHdpbGwgYmVcbiAqcGFzc2VkIHRvIHlvdXIgY29tcG9uZW50IGFzIHBhcnQgb2YgaXRzIFtgQ29ubmVjdGlvbkxpbmVDb21wb25lbnRQcm9wc2BdKC9hcGktcmVmZXJlbmNlL3R5cGVzL2Nvbm5lY3Rpb24tbGluZS1jb21wb25lbnQtcHJvcHMpLlxuICovXG52YXIgQ29ubmVjdGlvbkxpbmVUeXBlO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uTGluZVR5cGUpIHtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJCZXppZXJcIl0gPSBcImRlZmF1bHRcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTdHJhaWdodFwiXSA9IFwic3RyYWlnaHRcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTdGVwXCJdID0gXCJzdGVwXCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU21vb3RoU3RlcFwiXSA9IFwic21vb3Roc3RlcFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlNpbXBsZUJlemllclwiXSA9IFwic2ltcGxlYmV6aWVyXCI7XG59KShDb25uZWN0aW9uTGluZVR5cGUgfHwgKENvbm5lY3Rpb25MaW5lVHlwZSA9IHt9KSk7XG4vKipcbiAqIEVkZ2VzIG1heSBvcHRpb25hbGx5IGhhdmUgYSBtYXJrZXIgb24gZWl0aGVyIGVuZC4gVGhlIE1hcmtlclR5cGUgdHlwZSBlbnVtZXJhdGVzXG4gKiB0aGUgb3B0aW9ucyBhdmFpbGFibGUgdG8geW91IHdoZW4gY29uZmlndXJpbmcgYSBnaXZlbiBtYXJrZXIuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgTWFya2VyVHlwZTtcbihmdW5jdGlvbiAoTWFya2VyVHlwZSkge1xuICAgIE1hcmtlclR5cGVbXCJBcnJvd1wiXSA9IFwiYXJyb3dcIjtcbiAgICBNYXJrZXJUeXBlW1wiQXJyb3dDbG9zZWRcIl0gPSBcImFycm93Y2xvc2VkXCI7XG59KShNYXJrZXJUeXBlIHx8IChNYXJrZXJUeXBlID0ge30pKTtcblxuLyoqXG4gKiBXaGlsZSBbYFBhbmVsUG9zaXRpb25gXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9wYW5lbC1wb3NpdGlvbikgY2FuIGJlIHVzZWQgdG8gcGxhY2UgYVxuICogY29tcG9uZW50IGluIHRoZSBjb3JuZXJzIG9mIGEgY29udGFpbmVyLCB0aGUgYFBvc2l0aW9uYCBlbnVtIGlzIGxlc3MgcHJlY2lzZSBhbmQgdXNlZFxuICogcHJpbWFyaWx5IGluIHJlbGF0aW9uIHRvIGVkZ2VzIGFuZCBoYW5kbGVzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFBvc2l0aW9uO1xuKGZ1bmN0aW9uIChQb3NpdGlvbikge1xuICAgIFBvc2l0aW9uW1wiTGVmdFwiXSA9IFwibGVmdFwiO1xuICAgIFBvc2l0aW9uW1wiVG9wXCJdID0gXCJ0b3BcIjtcbiAgICBQb3NpdGlvbltcIlJpZ2h0XCJdID0gXCJyaWdodFwiO1xuICAgIFBvc2l0aW9uW1wiQm90dG9tXCJdID0gXCJib3R0b21cIjtcbn0pKFBvc2l0aW9uIHx8IChQb3NpdGlvbiA9IHt9KSk7XG5jb25zdCBvcHBvc2l0ZVBvc2l0aW9uID0ge1xuICAgIFtQb3NpdGlvbi5MZWZ0XTogUG9zaXRpb24uUmlnaHQsXG4gICAgW1Bvc2l0aW9uLlJpZ2h0XTogUG9zaXRpb24uTGVmdCxcbiAgICBbUG9zaXRpb24uVG9wXTogUG9zaXRpb24uQm90dG9tLFxuICAgIFtQb3NpdGlvbi5Cb3R0b21dOiBQb3NpdGlvbi5Ub3AsXG59O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBhcmVDb25uZWN0aW9uTWFwc0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghYSB8fCAhYiB8fCBhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghYS5zaXplICYmICFiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGEua2V5cygpKSB7XG4gICAgICAgIGlmICghYi5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBXZSBjYWxsIHRoZSBjYWxsYmFjayBmb3IgYWxsIGNvbm5lY3Rpb25zIGluIGEgdGhhdCBhcmUgbm90IGluIGJcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaGFuZGxlQ29ubmVjdGlvbkNoYW5nZShhLCBiLCBjYikge1xuICAgIGlmICghY2IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaWZmID0gW107XG4gICAgYS5mb3JFYWNoKChjb25uZWN0aW9uLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKCFiPy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgZGlmZi5wdXNoKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGRpZmYubGVuZ3RoKSB7XG4gICAgICAgIGNiKGRpZmYpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbm5lY3Rpb25TdGF0dXMoaXNWYWxpZCkge1xuICAgIHJldHVybiBpc1ZhbGlkID09PSBudWxsID8gbnVsbCA6IGlzVmFsaWQgPyAndmFsaWQnIDogJ2ludmFsaWQnO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBvYmplY3QgaXMgdXNhYmxlIGFzIGFuIEVkZ2VcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBFZGdlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFuIEVkZ2VcbiAqL1xuY29uc3QgaXNFZGdlQmFzZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ3NvdXJjZScgaW4gZWxlbWVudCAmJiAndGFyZ2V0JyBpbiBlbGVtZW50O1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVzYWJsZSBhcyBhIE5vZGVcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBOb2RlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFuIE5vZGVcbiAqL1xuY29uc3QgaXNOb2RlQmFzZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ3Bvc2l0aW9uJyBpbiBlbGVtZW50ICYmICEoJ3NvdXJjZScgaW4gZWxlbWVudCkgJiYgISgndGFyZ2V0JyBpbiBlbGVtZW50KTtcbmNvbnN0IGlzSW50ZXJuYWxOb2RlQmFzZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ2ludGVybmFscycgaW4gZWxlbWVudCAmJiAhKCdzb3VyY2UnIGluIGVsZW1lbnQpICYmICEoJ3RhcmdldCcgaW4gZWxlbWVudCk7XG4vKipcbiAqIFRoaXMgdXRpbCBpcyB1c2VkIHRvIHRlbGwgeW91IHdoYXQgbm9kZXMsIGlmIGFueSwgYXJlIGNvbm5lY3RlZCB0byB0aGUgZ2l2ZW4gbm9kZVxuICogYXMgdGhlIF90YXJnZXRfIG9mIGFuIGVkZ2UuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGdldCB0aGUgY29ubmVjdGVkIG5vZGVzIGZyb20uXG4gKiBAcGFyYW0gbm9kZXMgLSBUaGUgYXJyYXkgb2YgYWxsIG5vZGVzLlxuICogQHBhcmFtIGVkZ2VzIC0gVGhlIGFycmF5IG9mIGFsbCBlZGdlcy5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIHRoYXQgYXJlIGNvbm5lY3RlZCBvdmVyIGVkZ2VzIHdoZXJlIHRoZSBzb3VyY2UgaXMgdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKmltcG9ydCB7IGdldE91dGdvZXJzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtdO1xuICpjb25zdCBlZGdlcyA9IFtdO1xuICpcbiAqY29uc3Qgb3V0Z29lcnMgPSBnZXRPdXRnb2VycyhcbiAqICB7IGlkOiAnMScsIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSwgZGF0YTogeyBsYWJlbDogJ25vZGUnIH0gfSxcbiAqICBub2RlcyxcbiAqICBlZGdlcyxcbiAqKTtcbiAqYGBgXG4gKi9cbmNvbnN0IGdldE91dGdvZXJzID0gKG5vZGUsIG5vZGVzLCBlZGdlcykgPT4ge1xuICAgIGlmICghbm9kZS5pZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IG91dGdvZXJJZHMgPSBuZXcgU2V0KCk7XG4gICAgZWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICBpZiAoZWRnZS5zb3VyY2UgPT09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgIG91dGdvZXJJZHMuYWRkKGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2Rlcy5maWx0ZXIoKG4pID0+IG91dGdvZXJJZHMuaGFzKG4uaWQpKTtcbn07XG4vKipcbiAqIFRoaXMgdXRpbCBpcyB1c2VkIHRvIHRlbGwgeW91IHdoYXQgbm9kZXMsIGlmIGFueSwgYXJlIGNvbm5lY3RlZCB0byB0aGUgZ2l2ZW4gbm9kZVxuICogYXMgdGhlIF9zb3VyY2VfIG9mIGFuIGVkZ2UuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGdldCB0aGUgY29ubmVjdGVkIG5vZGVzIGZyb20uXG4gKiBAcGFyYW0gbm9kZXMgLSBUaGUgYXJyYXkgb2YgYWxsIG5vZGVzLlxuICogQHBhcmFtIGVkZ2VzIC0gVGhlIGFycmF5IG9mIGFsbCBlZGdlcy5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIHRoYXQgYXJlIGNvbm5lY3RlZCBvdmVyIGVkZ2VzIHdoZXJlIHRoZSB0YXJnZXQgaXMgdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKmltcG9ydCB7IGdldEluY29tZXJzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtdO1xuICpjb25zdCBlZGdlcyA9IFtdO1xuICpcbiAqY29uc3QgaW5jb21lcnMgPSBnZXRJbmNvbWVycyhcbiAqICB7IGlkOiAnMScsIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSwgZGF0YTogeyBsYWJlbDogJ25vZGUnIH0gfSxcbiAqICBub2RlcyxcbiAqICBlZGdlcyxcbiAqKTtcbiAqYGBgXG4gKi9cbmNvbnN0IGdldEluY29tZXJzID0gKG5vZGUsIG5vZGVzLCBlZGdlcykgPT4ge1xuICAgIGlmICghbm9kZS5pZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGluY29tZXJzSWRzID0gbmV3IFNldCgpO1xuICAgIGVkZ2VzLmZvckVhY2goKGVkZ2UpID0+IHtcbiAgICAgICAgaWYgKGVkZ2UudGFyZ2V0ID09PSBub2RlLmlkKSB7XG4gICAgICAgICAgICBpbmNvbWVyc0lkcy5hZGQoZWRnZS5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcigobikgPT4gaW5jb21lcnNJZHMuaGFzKG4uaWQpKTtcbn07XG5jb25zdCBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luID0gKG5vZGUsIG5vZGVPcmlnaW4gPSBbMCwgMF0pID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldE5vZGVEaW1lbnNpb25zKG5vZGUpO1xuICAgIGNvbnN0IG9yaWdpbiA9IG5vZGUub3JpZ2luID8/IG5vZGVPcmlnaW47XG4gICAgY29uc3Qgb2Zmc2V0WCA9IHdpZHRoICogb3JpZ2luWzBdO1xuICAgIGNvbnN0IG9mZnNldFkgPSBoZWlnaHQgKiBvcmlnaW5bMV07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogbm9kZS5wb3NpdGlvbi54IC0gb2Zmc2V0WCxcbiAgICAgICAgeTogbm9kZS5wb3NpdGlvbi55IC0gb2Zmc2V0WSxcbiAgICB9O1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IHRoYXQgY29udGFpbnMgYWxsIHRoZSBnaXZlbiBub2RlcyBpbiBhbiBhcnJheS4gVGhpcyBjYW5cbiAqIGJlIHVzZWZ1bCB3aGVuIGNvbWJpbmVkIHdpdGggW2BnZXRWaWV3cG9ydEZvckJvdW5kc2BdKC9hcGktcmVmZXJlbmNlL3V0aWxzL2dldC12aWV3cG9ydC1mb3ItYm91bmRzKVxuICogdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSB0byBmaXQgdGhlIGdpdmVuIG5vZGVzIGluIGEgdmlld3BvcnQuXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBVc2VmdWwgd2hlbiBjb21iaW5lZCB3aXRoIHtAbGluayBnZXRWaWV3cG9ydEZvckJvdW5kc30gdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSB0byBmaXQgdGhlIGdpdmVuIG5vZGVzIGluIGEgdmlld3BvcnQuXG4gKiBAcGFyYW0gbm9kZXMgLSBOb2RlcyB0byBjYWxjdWxhdGUgdGhlIGJvdW5kcyBmb3IuXG4gKiBAcmV0dXJucyBCb3VuZGluZyBib3ggZW5jbG9zaW5nIGFsbCBub2Rlcy5cbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHdhcyBwcmV2aW91c2x5IGNhbGxlZCBgZ2V0UmVjdE9mTm9kZXNgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmltcG9ydCB7IGdldE5vZGVzQm91bmRzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtcbiAqICB7XG4gKiAgICBpZDogJ2EnLFxuICogICAgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LFxuICogICAgZGF0YTogeyBsYWJlbDogJ2EnIH0sXG4gKiAgICB3aWR0aDogNTAsXG4gKiAgICBoZWlnaHQ6IDI1LFxuICogIH0sXG4gKiAge1xuICogICAgaWQ6ICdiJyxcbiAqICAgIHBvc2l0aW9uOiB7IHg6IDEwMCwgeTogMTAwIH0sXG4gKiAgICBkYXRhOiB7IGxhYmVsOiAnYicgfSxcbiAqICAgIHdpZHRoOiA1MCxcbiAqICAgIGhlaWdodDogMjUsXG4gKiAgfSxcbiAqXTtcbiAqXG4gKmNvbnN0IGJvdW5kcyA9IGdldE5vZGVzQm91bmRzKG5vZGVzKTtcbiAqYGBgXG4gKi9cbmNvbnN0IGdldE5vZGVzQm91bmRzID0gKG5vZGVzLCBwYXJhbXMgPSB7IG5vZGVPcmlnaW46IFswLCAwXSB9KSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICFwYXJhbXMubm9kZUxvb2t1cCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1BsZWFzZSB1c2UgYGdldE5vZGVzQm91bmRzYCBmcm9tIGB1c2VSZWFjdEZsb3dgL2B1c2VTdmVsdGVGbG93YCBob29rIHRvIGVuc3VyZSBjb3JyZWN0IHZhbHVlcyBmb3Igc3ViIGZsb3dzLiBJZiBub3QgcG9zc2libGUsIHlvdSBoYXZlIHRvIHByb3ZpZGUgYSBub2RlTG9va3VwIHRvIHN1cHBvcnQgc3ViIGZsb3dzLicpO1xuICAgIH1cbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICB9XG4gICAgY29uc3QgYm94ID0gbm9kZXMucmVkdWNlKChjdXJyQm94LCBub2RlT3JJZCkgPT4ge1xuICAgICAgICBjb25zdCBpc0lkID0gdHlwZW9mIG5vZGVPcklkID09PSAnc3RyaW5nJztcbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gIXBhcmFtcy5ub2RlTG9va3VwICYmICFpc0lkID8gbm9kZU9ySWQgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChwYXJhbXMubm9kZUxvb2t1cCkge1xuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBpc0lkXG4gICAgICAgICAgICAgICAgPyBwYXJhbXMubm9kZUxvb2t1cC5nZXQobm9kZU9ySWQpXG4gICAgICAgICAgICAgICAgOiAhaXNJbnRlcm5hbE5vZGVCYXNlKG5vZGVPcklkKVxuICAgICAgICAgICAgICAgICAgICA/IHBhcmFtcy5ub2RlTG9va3VwLmdldChub2RlT3JJZC5pZClcbiAgICAgICAgICAgICAgICAgICAgOiBub2RlT3JJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlQm94ID0gY3VycmVudE5vZGUgPyBub2RlVG9Cb3goY3VycmVudE5vZGUsIHBhcmFtcy5ub2RlT3JpZ2luKSA6IHsgeDogMCwgeTogMCwgeDI6IDAsIHkyOiAwIH07XG4gICAgICAgIHJldHVybiBnZXRCb3VuZHNPZkJveGVzKGN1cnJCb3gsIG5vZGVCb3gpO1xuICAgIH0sIHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5LCB4MjogLUluZmluaXR5LCB5MjogLUluZmluaXR5IH0pO1xuICAgIHJldHVybiBib3hUb1JlY3QoYm94KTtcbn07XG4vKipcbiAqIERldGVybWluZXMgYSBib3VuZGluZyBib3ggdGhhdCBjb250YWlucyBhbGwgZ2l2ZW4gbm9kZXMgaW4gYW4gYXJyYXlcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBnZXRJbnRlcm5hbE5vZGVzQm91bmRzID0gKG5vZGVMb29rdXAsIHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgaWYgKG5vZGVMb29rdXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgfVxuICAgIGxldCBib3ggPSB7IHg6IEluZmluaXR5LCB5OiBJbmZpbml0eSwgeDI6IC1JbmZpbml0eSwgeTI6IC1JbmZpbml0eSB9O1xuICAgIG5vZGVMb29rdXAuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBpZiAocGFyYW1zLmZpbHRlciA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcy5maWx0ZXIobm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVCb3ggPSBub2RlVG9Cb3gobm9kZSk7XG4gICAgICAgICAgICBib3ggPSBnZXRCb3VuZHNPZkJveGVzKGJveCwgbm9kZUJveCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYm94VG9SZWN0KGJveCk7XG59O1xuY29uc3QgZ2V0Tm9kZXNJbnNpZGUgPSAobm9kZXMsIHJlY3QsIFt0eCwgdHksIHRTY2FsZV0gPSBbMCwgMCwgMV0sIHBhcnRpYWxseSA9IGZhbHNlLCBcbi8vIHNldCBleGNsdWRlTm9uU2VsZWN0YWJsZU5vZGVzIGlmIHlvdSB3YW50IHRvIHBheSBhdHRlbnRpb24gdG8gdGhlIG5vZGVzIFwic2VsZWN0YWJsZVwiIGF0dHJpYnV0ZVxuZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgcGFuZVJlY3QgPSB7XG4gICAgICAgIC4uLnBvaW50VG9SZW5kZXJlclBvaW50KHJlY3QsIFt0eCwgdHksIHRTY2FsZV0pLFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCAvIHRTY2FsZSxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCAvIHRTY2FsZSxcbiAgICB9O1xuICAgIGNvbnN0IHZpc2libGVOb2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcy52YWx1ZXMoKSkge1xuICAgICAgICBjb25zdCB7IG1lYXN1cmVkLCBzZWxlY3RhYmxlID0gdHJ1ZSwgaGlkZGVuID0gZmFsc2UgfSA9IG5vZGU7XG4gICAgICAgIGlmICgoZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyAmJiAhc2VsZWN0YWJsZSkgfHwgaGlkZGVuKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3aWR0aCA9IG1lYXN1cmVkLndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gbnVsbDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWVhc3VyZWQuaGVpZ2h0ID8/IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCA/PyBudWxsO1xuICAgICAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBnZXRPdmVybGFwcGluZ0FyZWEocGFuZVJlY3QsIG5vZGVUb1JlY3Qobm9kZSkpO1xuICAgICAgICBjb25zdCBhcmVhID0gKHdpZHRoID8/IDApICogKGhlaWdodCA/PyAwKTtcbiAgICAgICAgY29uc3QgcGFydGlhbGx5VmlzaWJsZSA9IHBhcnRpYWxseSAmJiBvdmVybGFwcGluZ0FyZWEgPiAwO1xuICAgICAgICBjb25zdCBmb3JjZUluaXRpYWxSZW5kZXIgPSAhbm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzO1xuICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBmb3JjZUluaXRpYWxSZW5kZXIgfHwgcGFydGlhbGx5VmlzaWJsZSB8fCBvdmVybGFwcGluZ0FyZWEgPj0gYXJlYTtcbiAgICAgICAgaWYgKGlzVmlzaWJsZSB8fCBub2RlLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB2aXNpYmxlTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmlzaWJsZU5vZGVzO1xufTtcbi8qKlxuICogVGhpcyB1dGlsaXR5IGZpbHRlcnMgYW4gYXJyYXkgb2YgZWRnZXMsIGtlZXBpbmcgb25seSB0aG9zZSB3aGVyZSBlaXRoZXIgdGhlIHNvdXJjZSBvciB0YXJnZXRcbiAqIG5vZGUgaXMgcHJlc2VudCBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2Ygbm9kZXMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gbm9kZXMgLSBOb2RlcyB5b3Ugd2FudCB0byBnZXQgdGhlIGNvbm5lY3RlZCBlZGdlcyBmb3IuXG4gKiBAcGFyYW0gZWRnZXMgLSBBbGwgZWRnZXMuXG4gKiBAcmV0dXJucyBBcnJheSBvZiBlZGdlcyB0aGF0IGNvbm5lY3QgYW55IG9mIHRoZSBnaXZlbiBub2RlcyB3aXRoIGVhY2ggb3RoZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmltcG9ydCB7IGdldENvbm5lY3RlZEVkZ2VzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtcbiAqICB7IGlkOiAnYScsIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSB9LFxuICogIHsgaWQ6ICdiJywgcG9zaXRpb246IHsgeDogMTAwLCB5OiAwIH0gfSxcbiAqXTtcbiAqXG4gKmNvbnN0IGVkZ2VzID0gW1xuICogIHsgaWQ6ICdhLT5jJywgc291cmNlOiAnYScsIHRhcmdldDogJ2MnIH0sXG4gKiAgeyBpZDogJ2MtPmQnLCBzb3VyY2U6ICdjJywgdGFyZ2V0OiAnZCcgfSxcbiAqXTtcbiAqXG4gKmNvbnN0IGNvbm5lY3RlZEVkZ2VzID0gZ2V0Q29ubmVjdGVkRWRnZXMobm9kZXMsIGVkZ2VzKTtcbiAqIC8vID0+IFt7IGlkOiAnYS0+YycsIHNvdXJjZTogJ2EnLCB0YXJnZXQ6ICdjJyB9XVxuICpgYGBcbiAqL1xuY29uc3QgZ2V0Q29ubmVjdGVkRWRnZXMgPSAobm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgY29uc3Qgbm9kZUlkcyA9IG5ldyBTZXQoKTtcbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIG5vZGVJZHMuYWRkKG5vZGUuaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBlZGdlcy5maWx0ZXIoKGVkZ2UpID0+IG5vZGVJZHMuaGFzKGVkZ2Uuc291cmNlKSB8fCBub2RlSWRzLmhhcyhlZGdlLnRhcmdldCkpO1xufTtcbmZ1bmN0aW9uIGdldEZpdFZpZXdOb2Rlcyhub2RlTG9va3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZml0Vmlld05vZGVzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG9wdGlvbk5vZGVJZHMgPSBvcHRpb25zPy5ub2RlcyA/IG5ldyBTZXQob3B0aW9ucy5ub2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuaWQpKSA6IG51bGw7XG4gICAgbm9kZUxvb2t1cC5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IG4ubWVhc3VyZWQud2lkdGggJiYgbi5tZWFzdXJlZC5oZWlnaHQgJiYgKG9wdGlvbnM/LmluY2x1ZGVIaWRkZW5Ob2RlcyB8fCAhbi5oaWRkZW4pO1xuICAgICAgICBpZiAoaXNWaXNpYmxlICYmICghb3B0aW9uTm9kZUlkcyB8fCBvcHRpb25Ob2RlSWRzLmhhcyhuLmlkKSkpIHtcbiAgICAgICAgICAgIGZpdFZpZXdOb2Rlcy5zZXQobi5pZCwgbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZml0Vmlld05vZGVzO1xufVxuYXN5bmMgZnVuY3Rpb24gZml0Vmlld3BvcnQoeyBub2Rlcywgd2lkdGgsIGhlaWdodCwgcGFuWm9vbSwgbWluWm9vbSwgbWF4Wm9vbSB9LCBvcHRpb25zKSB7XG4gICAgaWYgKG5vZGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZXNUb0ZpdCA9IGdldEZpdFZpZXdOb2Rlcyhub2Rlcywgb3B0aW9ucyk7XG4gICAgY29uc3QgYm91bmRzID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhub2Rlc1RvRml0KTtcbiAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucz8ubWluWm9vbSA/PyBtaW5ab29tLCBvcHRpb25zPy5tYXhab29tID8/IG1heFpvb20sIG9wdGlvbnM/LnBhZGRpbmcgPz8gMC4xKTtcbiAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHZpZXdwb3J0LCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIG5leHQgcG9zaXRpb24gb2YgYSBub2RlLCB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBub2RlJ3MgZXh0ZW50LCBwYXJlbnQgbm9kZSwgYW5kIG9yaWdpbi5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm5zIHBvc2l0aW9uLCBwb3NpdGlvbkFic29sdXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZU5vZGVQb3NpdGlvbih7IG5vZGVJZCwgbmV4dFBvc2l0aW9uLCBub2RlTG9va3VwLCBub2RlT3JpZ2luID0gWzAsIDBdLCBub2RlRXh0ZW50LCBvbkVycm9yLCB9KSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50SWQgPyBub2RlTG9va3VwLmdldChub2RlLnBhcmVudElkKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCB7IHg6IHBhcmVudFgsIHk6IHBhcmVudFkgfSA9IHBhcmVudE5vZGUgPyBwYXJlbnROb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlIDogeyB4OiAwLCB5OiAwIH07XG4gICAgY29uc3Qgb3JpZ2luID0gbm9kZS5vcmlnaW4gPz8gbm9kZU9yaWdpbjtcbiAgICBsZXQgZXh0ZW50ID0gbm9kZUV4dGVudDtcbiAgICBpZiAobm9kZS5leHRlbnQgPT09ICdwYXJlbnQnICYmICFub2RlLmV4cGFuZFBhcmVudCkge1xuICAgICAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG9uRXJyb3I/LignMDA1JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDUnXSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFdpZHRoID0gcGFyZW50Tm9kZS5tZWFzdXJlZC53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEhlaWdodCA9IHBhcmVudE5vZGUubWVhc3VyZWQuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHBhcmVudFdpZHRoICYmIHBhcmVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgIGV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgW3BhcmVudFgsIHBhcmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbcGFyZW50WCArIHBhcmVudFdpZHRoLCBwYXJlbnRZICsgcGFyZW50SGVpZ2h0XSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmVudE5vZGUgJiYgaXNDb29yZGluYXRlRXh0ZW50KG5vZGUuZXh0ZW50KSkge1xuICAgICAgICBleHRlbnQgPSBbXG4gICAgICAgICAgICBbbm9kZS5leHRlbnRbMF1bMF0gKyBwYXJlbnRYLCBub2RlLmV4dGVudFswXVsxXSArIHBhcmVudFldLFxuICAgICAgICAgICAgW25vZGUuZXh0ZW50WzFdWzBdICsgcGFyZW50WCwgbm9kZS5leHRlbnRbMV1bMV0gKyBwYXJlbnRZXSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgcG9zaXRpb25BYnNvbHV0ZSA9IGlzQ29vcmRpbmF0ZUV4dGVudChleHRlbnQpXG4gICAgICAgID8gY2xhbXBQb3NpdGlvbihuZXh0UG9zaXRpb24sIGV4dGVudCwgbm9kZS5tZWFzdXJlZClcbiAgICAgICAgOiBuZXh0UG9zaXRpb247XG4gICAgaWYgKG5vZGUubWVhc3VyZWQud2lkdGggPT09IHVuZGVmaW5lZCB8fCBub2RlLm1lYXN1cmVkLmhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9uRXJyb3I/LignMDE1JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTUnXSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHBvc2l0aW9uQWJzb2x1dGUueCAtIHBhcmVudFggKyAobm9kZS5tZWFzdXJlZC53aWR0aCA/PyAwKSAqIG9yaWdpblswXSxcbiAgICAgICAgICAgIHk6IHBvc2l0aW9uQWJzb2x1dGUueSAtIHBhcmVudFkgKyAobm9kZS5tZWFzdXJlZC5oZWlnaHQgPz8gMCkgKiBvcmlnaW5bMV0sXG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uQWJzb2x1dGUsXG4gICAgfTtcbn1cbi8qKlxuICogUGFzcyBpbiBub2RlcyAmIGVkZ2VzIHRvIGRlbGV0ZSwgZ2V0IGFycmF5cyBvZiBub2RlcyBhbmQgZWRnZXMgdGhhdCBhY3R1YWxseSBjYW4gYmUgZGVsZXRlZFxuICogQGludGVybmFsXG4gKiBAcGFyYW0gcGFyYW0ubm9kZXNUb1JlbW92ZSAtIFRoZSBub2RlcyB0byByZW1vdmVcbiAqIEBwYXJhbSBwYXJhbS5lZGdlc1RvUmVtb3ZlIC0gVGhlIGVkZ2VzIHRvIHJlbW92ZVxuICogQHBhcmFtIHBhcmFtLm5vZGVzIC0gQWxsIG5vZGVzXG4gKiBAcGFyYW0gcGFyYW0uZWRnZXMgLSBBbGwgZWRnZXNcbiAqIEBwYXJhbSBwYXJhbS5vbkJlZm9yZURlbGV0ZSAtIENhbGxiYWNrIHRvIGNoZWNrIHdoaWNoIG5vZGVzIGFuZCBlZGdlcyBjYW4gYmUgZGVsZXRlZFxuICogQHJldHVybnMgbm9kZXM6IG5vZGVzIHRoYXQgY2FuIGJlIGRlbGV0ZWQsIGVkZ2VzOiBlZGdlcyB0aGF0IGNhbiBiZSBkZWxldGVkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEVsZW1lbnRzVG9SZW1vdmUoeyBub2Rlc1RvUmVtb3ZlID0gW10sIGVkZ2VzVG9SZW1vdmUgPSBbXSwgbm9kZXMsIGVkZ2VzLCBvbkJlZm9yZURlbGV0ZSwgfSkge1xuICAgIGNvbnN0IG5vZGVJZHMgPSBuZXcgU2V0KG5vZGVzVG9SZW1vdmUubWFwKChub2RlKSA9PiBub2RlLmlkKSk7XG4gICAgY29uc3QgbWF0Y2hpbmdOb2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZS5kZWxldGFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0luY2x1ZGVkID0gbm9kZUlkcy5oYXMobm9kZS5pZCk7XG4gICAgICAgIGNvbnN0IHBhcmVudEhpdCA9ICFpc0luY2x1ZGVkICYmIG5vZGUucGFyZW50SWQgJiYgbWF0Y2hpbmdOb2Rlcy5maW5kKChuKSA9PiBuLmlkID09PSBub2RlLnBhcmVudElkKTtcbiAgICAgICAgaWYgKGlzSW5jbHVkZWQgfHwgcGFyZW50SGl0KSB7XG4gICAgICAgICAgICBtYXRjaGluZ05vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWRnZUlkcyA9IG5ldyBTZXQoZWRnZXNUb1JlbW92ZS5tYXAoKGVkZ2UpID0+IGVkZ2UuaWQpKTtcbiAgICBjb25zdCBkZWxldGFibGVFZGdlcyA9IGVkZ2VzLmZpbHRlcigoZWRnZSkgPT4gZWRnZS5kZWxldGFibGUgIT09IGZhbHNlKTtcbiAgICBjb25zdCBjb25uZWN0ZWRFZGdlcyA9IGdldENvbm5lY3RlZEVkZ2VzKG1hdGNoaW5nTm9kZXMsIGRlbGV0YWJsZUVkZ2VzKTtcbiAgICBjb25zdCBtYXRjaGluZ0VkZ2VzID0gY29ubmVjdGVkRWRnZXM7XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGRlbGV0YWJsZUVkZ2VzKSB7XG4gICAgICAgIGNvbnN0IGlzSW5jbHVkZWQgPSBlZGdlSWRzLmhhcyhlZGdlLmlkKTtcbiAgICAgICAgaWYgKGlzSW5jbHVkZWQgJiYgIW1hdGNoaW5nRWRnZXMuZmluZCgoZSkgPT4gZS5pZCA9PT0gZWRnZS5pZCkpIHtcbiAgICAgICAgICAgIG1hdGNoaW5nRWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW9uQmVmb3JlRGVsZXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlZGdlczogbWF0Y2hpbmdFZGdlcyxcbiAgICAgICAgICAgIG5vZGVzOiBtYXRjaGluZ05vZGVzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvbkJlZm9yZURlbGV0ZVJlc3VsdCA9IGF3YWl0IG9uQmVmb3JlRGVsZXRlKHtcbiAgICAgICAgbm9kZXM6IG1hdGNoaW5nTm9kZXMsXG4gICAgICAgIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzLFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2Ygb25CZWZvcmVEZWxldGVSZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gb25CZWZvcmVEZWxldGVSZXN1bHQgPyB7IGVkZ2VzOiBtYXRjaGluZ0VkZ2VzLCBub2RlczogbWF0Y2hpbmdOb2RlcyB9IDogeyBlZGdlczogW10sIG5vZGVzOiBbXSB9O1xuICAgIH1cbiAgICByZXR1cm4gb25CZWZvcmVEZWxldGVSZXN1bHQ7XG59XG5cbmNvbnN0IGNsYW1wID0gKHZhbCwgbWluID0gMCwgbWF4ID0gMSkgPT4gTWF0aC5taW4oTWF0aC5tYXgodmFsLCBtaW4pLCBtYXgpO1xuY29uc3QgY2xhbXBQb3NpdGlvbiA9IChwb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9LCBleHRlbnQsIGRpbWVuc2lvbnMpID0+ICh7XG4gICAgeDogY2xhbXAocG9zaXRpb24ueCwgZXh0ZW50WzBdWzBdLCBleHRlbnRbMV1bMF0gLSAoZGltZW5zaW9ucz8ud2lkdGggPz8gMCkpLFxuICAgIHk6IGNsYW1wKHBvc2l0aW9uLnksIGV4dGVudFswXVsxXSwgZXh0ZW50WzFdWzFdIC0gKGRpbWVuc2lvbnM/LmhlaWdodCA/PyAwKSksXG59KTtcbmZ1bmN0aW9uIGNsYW1wUG9zaXRpb25Ub1BhcmVudChjaGlsZFBvc2l0aW9uLCBjaGlsZERpbWVuc2lvbnMsIHBhcmVudCkge1xuICAgIGNvbnN0IHsgd2lkdGg6IHBhcmVudFdpZHRoLCBoZWlnaHQ6IHBhcmVudEhlaWdodCB9ID0gZ2V0Tm9kZURpbWVuc2lvbnMocGFyZW50KTtcbiAgICBjb25zdCB7IHg6IHBhcmVudFgsIHk6IHBhcmVudFkgfSA9IHBhcmVudC5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZTtcbiAgICByZXR1cm4gY2xhbXBQb3NpdGlvbihjaGlsZFBvc2l0aW9uLCBbXG4gICAgICAgIFtwYXJlbnRYLCBwYXJlbnRZXSxcbiAgICAgICAgW3BhcmVudFggKyBwYXJlbnRXaWR0aCwgcGFyZW50WSArIHBhcmVudEhlaWdodF0sXG4gICAgXSwgY2hpbGREaW1lbnNpb25zKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgdmVsb2NpdHkgb2YgcGFubmluZyB3aGVuIHRoZSBtb3VzZSBpcyBjbG9zZSB0byB0aGUgZWRnZSBvZiB0aGUgY2FudmFzXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB2YWx1ZSAtIE9uZSBkaW1lbnNpb25hbCBwb2l0aW9uIG9mIHRoZSBtb3VzZSAoeCBvciB5KVxuICogQHBhcmFtIG1pbiAtIE1pbmltYWwgcG9zaXRpb24gb24gY2FudmFzIGJlZm9yZSBwYW5uaW5nIHN0YXJ0c1xuICogQHBhcmFtIG1heCAtIE1heGltYWwgcG9zaXRpb24gb24gY2FudmFzIGJlZm9yZSBwYW5uaW5nIHN0YXJ0c1xuICogQHJldHVybnMgLSBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgdGhhdCByZXByZXNlbnRzIHRoZSB2ZWxvY2l0eSBvZiBwYW5uaW5nXG4gKi9cbmNvbnN0IGNhbGNBdXRvUGFuVmVsb2NpdHkgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiB7XG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIHJldHVybiBjbGFtcChNYXRoLmFicyh2YWx1ZSAtIG1pbiksIDEsIG1pbikgLyBtaW47XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgIHJldHVybiAtY2xhbXAoTWF0aC5hYnModmFsdWUgLSBtYXgpLCAxLCBtaW4pIC8gbWluO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5jb25zdCBjYWxjQXV0b1BhbiA9IChwb3MsIGJvdW5kcywgc3BlZWQgPSAxNSwgZGlzdGFuY2UgPSA0MCkgPT4ge1xuICAgIGNvbnN0IHhNb3ZlbWVudCA9IGNhbGNBdXRvUGFuVmVsb2NpdHkocG9zLngsIGRpc3RhbmNlLCBib3VuZHMud2lkdGggLSBkaXN0YW5jZSkgKiBzcGVlZDtcbiAgICBjb25zdCB5TW92ZW1lbnQgPSBjYWxjQXV0b1BhblZlbG9jaXR5KHBvcy55LCBkaXN0YW5jZSwgYm91bmRzLmhlaWdodCAtIGRpc3RhbmNlKSAqIHNwZWVkO1xuICAgIHJldHVybiBbeE1vdmVtZW50LCB5TW92ZW1lbnRdO1xufTtcbmNvbnN0IGdldEJvdW5kc09mQm94ZXMgPSAoYm94MSwgYm94MikgPT4gKHtcbiAgICB4OiBNYXRoLm1pbihib3gxLngsIGJveDIueCksXG4gICAgeTogTWF0aC5taW4oYm94MS55LCBib3gyLnkpLFxuICAgIHgyOiBNYXRoLm1heChib3gxLngyLCBib3gyLngyKSxcbiAgICB5MjogTWF0aC5tYXgoYm94MS55MiwgYm94Mi55MiksXG59KTtcbmNvbnN0IHJlY3RUb0JveCA9ICh7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSkgPT4gKHtcbiAgICB4LFxuICAgIHksXG4gICAgeDI6IHggKyB3aWR0aCxcbiAgICB5MjogeSArIGhlaWdodCxcbn0pO1xuY29uc3QgYm94VG9SZWN0ID0gKHsgeCwgeSwgeDIsIHkyIH0pID0+ICh7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiB4MiAtIHgsXG4gICAgaGVpZ2h0OiB5MiAtIHksXG59KTtcbmNvbnN0IG5vZGVUb1JlY3QgPSAobm9kZSwgbm9kZU9yaWdpbiA9IFswLCAwXSkgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gaXNJbnRlcm5hbE5vZGVCYXNlKG5vZGUpXG4gICAgICAgID8gbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZVxuICAgICAgICA6IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4obm9kZSwgbm9kZU9yaWdpbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGg6IG5vZGUubWVhc3VyZWQ/LndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gMCxcbiAgICAgICAgaGVpZ2h0OiBub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IDAsXG4gICAgfTtcbn07XG5jb25zdCBub2RlVG9Cb3ggPSAobm9kZSwgbm9kZU9yaWdpbiA9IFswLCAwXSkgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gaXNJbnRlcm5hbE5vZGVCYXNlKG5vZGUpXG4gICAgICAgID8gbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZVxuICAgICAgICA6IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4obm9kZSwgbm9kZU9yaWdpbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgeDI6IHggKyAobm9kZS5tZWFzdXJlZD8ud2lkdGggPz8gbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyAwKSxcbiAgICAgICAgeTI6IHkgKyAobm9kZS5tZWFzdXJlZD8uaGVpZ2h0ID8/IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCA/PyAwKSxcbiAgICB9O1xufTtcbmNvbnN0IGdldEJvdW5kc09mUmVjdHMgPSAocmVjdDEsIHJlY3QyKSA9PiBib3hUb1JlY3QoZ2V0Qm91bmRzT2ZCb3hlcyhyZWN0VG9Cb3gocmVjdDEpLCByZWN0VG9Cb3gocmVjdDIpKSk7XG5jb25zdCBnZXRPdmVybGFwcGluZ0FyZWEgPSAocmVjdEEsIHJlY3RCKSA9PiB7XG4gICAgY29uc3QgeE92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWN0QS54ICsgcmVjdEEud2lkdGgsIHJlY3RCLnggKyByZWN0Qi53aWR0aCkgLSBNYXRoLm1heChyZWN0QS54LCByZWN0Qi54KSk7XG4gICAgY29uc3QgeU92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWN0QS55ICsgcmVjdEEuaGVpZ2h0LCByZWN0Qi55ICsgcmVjdEIuaGVpZ2h0KSAtIE1hdGgubWF4KHJlY3RBLnksIHJlY3RCLnkpKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHhPdmVybGFwICogeU92ZXJsYXApO1xufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBpc1JlY3RPYmplY3QgPSAob2JqKSA9PiBpc051bWVyaWMob2JqLndpZHRoKSAmJiBpc051bWVyaWMob2JqLmhlaWdodCkgJiYgaXNOdW1lcmljKG9iai54KSAmJiBpc051bWVyaWMob2JqLnkpO1xuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IGlzTnVtZXJpYyA9IChuKSA9PiAhaXNOYU4obikgJiYgaXNGaW5pdGUobik7XG4vLyB1c2VkIGZvciBhMTF5IGtleSBib2FyZCBjb250cm9scyBmb3Igbm9kZXMgYW5kIGVkZ2VzXG5jb25zdCBkZXZXYXJuID0gKGlkLCBtZXNzYWdlKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW1JlYWN0IEZsb3ddOiAke21lc3NhZ2V9IEhlbHA6IGh0dHBzOi8vcmVhY3RmbG93LmRldi9lcnJvciMke2lkfWApO1xuICAgIH1cbn07XG5jb25zdCBzbmFwUG9zaXRpb24gPSAocG9zaXRpb24sIHNuYXBHcmlkID0gWzEsIDFdKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogc25hcEdyaWRbMF0gKiBNYXRoLnJvdW5kKHBvc2l0aW9uLnggLyBzbmFwR3JpZFswXSksXG4gICAgICAgIHk6IHNuYXBHcmlkWzFdICogTWF0aC5yb3VuZChwb3NpdGlvbi55IC8gc25hcEdyaWRbMV0pLFxuICAgIH07XG59O1xuY29uc3QgcG9pbnRUb1JlbmRlcmVyUG9pbnQgPSAoeyB4LCB5IH0sIFt0eCwgdHksIHRTY2FsZV0sIHNuYXBUb0dyaWQgPSBmYWxzZSwgc25hcEdyaWQgPSBbMSwgMV0pID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgICAgeDogKHggLSB0eCkgLyB0U2NhbGUsXG4gICAgICAgIHk6ICh5IC0gdHkpIC8gdFNjYWxlLFxuICAgIH07XG4gICAgcmV0dXJuIHNuYXBUb0dyaWQgPyBzbmFwUG9zaXRpb24ocG9zaXRpb24sIHNuYXBHcmlkKSA6IHBvc2l0aW9uO1xufTtcbmNvbnN0IHJlbmRlcmVyUG9pbnRUb1BvaW50ID0gKHsgeCwgeSB9LCBbdHgsIHR5LCB0U2NhbGVdKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAqIHRTY2FsZSArIHR4LFxuICAgICAgICB5OiB5ICogdFNjYWxlICsgdHksXG4gICAgfTtcbn07XG4vKipcbiAqIFBhcnNlcyBhIHNpbmdsZSBwYWRkaW5nIHZhbHVlIHRvIGEgbnVtYmVyXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBwYWRkaW5nIC0gUGFkZGluZyB0byBwYXJzZVxuICogQHBhcmFtIHZpZXdwb3J0IC0gV2lkdGggb3IgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydFxuICogQHJldHVybnMgVGhlIHBhZGRpbmcgaW4gcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUGFkZGluZyhwYWRkaW5nLCB2aWV3cG9ydCkge1xuICAgIGlmICh0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHZpZXdwb3J0IC0gdmlld3BvcnQgLyAoMSArIHBhZGRpbmcpKSAqIDAuNSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFkZGluZyA9PT0gJ3N0cmluZycgJiYgcGFkZGluZy5lbmRzV2l0aCgncHgnKSkge1xuICAgICAgICBjb25zdCBwYWRkaW5nVmFsdWUgPSBwYXJzZUZsb2F0KHBhZGRpbmcpO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTihwYWRkaW5nVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihwYWRkaW5nVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFkZGluZyA9PT0gJ3N0cmluZycgJiYgcGFkZGluZy5lbmRzV2l0aCgnJScpKSB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdWYWx1ZSA9IHBhcnNlRmxvYXQocGFkZGluZyk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHBhZGRpbmdWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZpZXdwb3J0ICogcGFkZGluZ1ZhbHVlICogMC4wMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5lcnJvcihgW1JlYWN0IEZsb3ddIFRoZSBwYWRkaW5nIHZhbHVlIFwiJHtwYWRkaW5nfVwiIGlzIGludmFsaWQuIFBsZWFzZSBwcm92aWRlIGEgbnVtYmVyIG9yIGEgc3RyaW5nIHdpdGggYSB2YWxpZCB1bml0IChweCBvciAlKS5gKTtcbiAgICByZXR1cm4gMDtcbn1cbi8qKlxuICogUGFyc2VzIHRoZSBwYWRkaW5ncyB0byBhbiBvYmplY3Qgd2l0aCB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHggYW5kIHkgcGFkZGluZ3NcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHBhZGRpbmcgLSBQYWRkaW5nIHRvIHBhcnNlXG4gKiBAcGFyYW0gd2lkdGggLSBXaWR0aCBvZiB0aGUgdmlld3BvcnRcbiAqIEBwYXJhbSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIHZpZXdwb3J0XG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB0aGUgcGFkZGluZ3MgaW4gcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUGFkZGluZ3MocGFkZGluZywgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh0eXBlb2YgcGFkZGluZyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdZID0gcGFyc2VQYWRkaW5nKHBhZGRpbmcsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdYID0gcGFyc2VQYWRkaW5nKHBhZGRpbmcsIHdpZHRoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogcGFkZGluZ1ksXG4gICAgICAgICAgICByaWdodDogcGFkZGluZ1gsXG4gICAgICAgICAgICBib3R0b206IHBhZGRpbmdZLFxuICAgICAgICAgICAgbGVmdDogcGFkZGluZ1gsXG4gICAgICAgICAgICB4OiBwYWRkaW5nWCAqIDIsXG4gICAgICAgICAgICB5OiBwYWRkaW5nWSAqIDIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFkZGluZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgdG9wID0gcGFyc2VQYWRkaW5nKHBhZGRpbmcudG9wID8/IHBhZGRpbmcueSA/PyAwLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBib3R0b20gPSBwYXJzZVBhZGRpbmcocGFkZGluZy5ib3R0b20gPz8gcGFkZGluZy55ID8/IDAsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBwYXJzZVBhZGRpbmcocGFkZGluZy5sZWZ0ID8/IHBhZGRpbmcueCA/PyAwLCB3aWR0aCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VQYWRkaW5nKHBhZGRpbmcucmlnaHQgPz8gcGFkZGluZy54ID8/IDAsIHdpZHRoKTtcbiAgICAgICAgcmV0dXJuIHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB4OiBsZWZ0ICsgcmlnaHQsIHk6IHRvcCArIGJvdHRvbSB9O1xuICAgIH1cbiAgICByZXR1cm4geyB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDAsIHg6IDAsIHk6IDAgfTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgcmVzdWx0aW5nIHBhZGRpbmdzIGlmIHRoZSBuZXcgdmlld3BvcnQgaXMgYXBwbGllZFxuICogQGludGVybmFsXG4gKiBAcGFyYW0gYm91bmRzIC0gQm91bmRzIHRvIGZpdCBpbnNpZGUgdmlld3BvcnRcbiAqIEBwYXJhbSB4IC0gWCBwb3NpdGlvbiBvZiB0aGUgdmlld3BvcnRcbiAqIEBwYXJhbSB5IC0gWSBwb3NpdGlvbiBvZiB0aGUgdmlld3BvcnRcbiAqIEBwYXJhbSB6b29tIC0gWm9vbSBsZXZlbCBvZiB0aGUgdmlld3BvcnRcbiAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIGhlaWdodCAtIEhlaWdodCBvZiB0aGUgdmlld3BvcnRcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHRoZSBtaW5pbXVtIHBhZGRpbmcgcmVxdWlyZWQgdG8gZml0IHRoZSBib3VuZHMgaW5zaWRlIHRoZSB2aWV3cG9ydFxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVBcHBsaWVkUGFkZGluZ3MoYm91bmRzLCB4LCB5LCB6b29tLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgeyB4OiBsZWZ0LCB5OiB0b3AgfSA9IHJlbmRlcmVyUG9pbnRUb1BvaW50KGJvdW5kcywgW3gsIHksIHpvb21dKTtcbiAgICBjb25zdCB7IHg6IGJvdW5kUmlnaHQsIHk6IGJvdW5kQm90dG9tIH0gPSByZW5kZXJlclBvaW50VG9Qb2ludCh7IHg6IGJvdW5kcy54ICsgYm91bmRzLndpZHRoLCB5OiBib3VuZHMueSArIGJvdW5kcy5oZWlnaHQgfSwgW3gsIHksIHpvb21dKTtcbiAgICBjb25zdCByaWdodCA9IHdpZHRoIC0gYm91bmRSaWdodDtcbiAgICBjb25zdCBib3R0b20gPSBoZWlnaHQgLSBib3VuZEJvdHRvbTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBNYXRoLmZsb29yKGxlZnQpLFxuICAgICAgICB0b3A6IE1hdGguZmxvb3IodG9wKSxcbiAgICAgICAgcmlnaHQ6IE1hdGguZmxvb3IocmlnaHQpLFxuICAgICAgICBib3R0b206IE1hdGguZmxvb3IoYm90dG9tKSxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgdmlld3BvcnQgdGhhdCBlbmNsb3NlcyB0aGUgZ2l2ZW4gYm91bmRzIHdpdGggcGFkZGluZy5cbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIFlvdSBjYW4gZGV0ZXJtaW5lIGJvdW5kcyBvZiBub2RlcyB3aXRoIHtAbGluayBnZXROb2Rlc0JvdW5kc30gYW5kIHtAbGluayBnZXRCb3VuZHNPZlJlY3RzfVxuICogQHBhcmFtIGJvdW5kcyAtIEJvdW5kcyB0byBmaXQgaW5zaWRlIHZpZXdwb3J0LlxuICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgdGhlIHZpZXdwb3J0LlxuICogQHBhcmFtIGhlaWdodCAgLSBIZWlnaHQgb2YgdGhlIHZpZXdwb3J0LlxuICogQHBhcmFtIG1pblpvb20gLSBNaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIHJlc3VsdGluZyB2aWV3cG9ydC5cbiAqIEBwYXJhbSBtYXhab29tIC0gTWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSByZXN1bHRpbmcgdmlld3BvcnQuXG4gKiBAcGFyYW0gcGFkZGluZyAtIFBhZGRpbmcgYXJvdW5kIHRoZSBib3VuZHMuXG4gKiBAcmV0dXJucyBBIHRyYW5zZm9ybWVkIHtAbGluayBWaWV3cG9ydH0gdGhhdCBlbmNsb3NlcyB0aGUgZ2l2ZW4gYm91bmRzIHdoaWNoIHlvdSBjYW4gcGFzcyB0byBlLmcuIHtAbGluayBzZXRWaWV3cG9ydH0uXG4gKiBAZXhhbXBsZVxuICogY29uc3QgeyB4LCB5LCB6b29tIH0gPSBnZXRWaWV3cG9ydEZvckJvdW5kcyhcbiAqIHsgeDogMCwgeTogMCwgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDB9LFxuICogMTIwMCwgODAwLCAwLjUsIDIpO1xuICovXG5jb25zdCBnZXRWaWV3cG9ydEZvckJvdW5kcyA9IChib3VuZHMsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20sIHBhZGRpbmcpID0+IHtcbiAgICAvLyBGaXJzdCB3ZSByZXNvbHZlIGFsbCB0aGUgcGFkZGluZ3MgdG8gYWN0dWFsIHBpeGVsIHZhbHVlc1xuICAgIGNvbnN0IHAgPSBwYXJzZVBhZGRpbmdzKHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHhab29tID0gKHdpZHRoIC0gcC54KSAvIGJvdW5kcy53aWR0aDtcbiAgICBjb25zdCB5Wm9vbSA9IChoZWlnaHQgLSBwLnkpIC8gYm91bmRzLmhlaWdodDtcbiAgICAvLyBXZSBjYWxjdWxhdGUgdGhlIG5ldyB4LCB5LCB6b29tIGZvciBhIGNlbnRlcmVkIHZpZXdcbiAgICBjb25zdCB6b29tID0gTWF0aC5taW4oeFpvb20sIHlab29tKTtcbiAgICBjb25zdCBjbGFtcGVkWm9vbSA9IGNsYW1wKHpvb20sIG1pblpvb20sIG1heFpvb20pO1xuICAgIGNvbnN0IGJvdW5kc0NlbnRlclggPSBib3VuZHMueCArIGJvdW5kcy53aWR0aCAvIDI7XG4gICAgY29uc3QgYm91bmRzQ2VudGVyWSA9IGJvdW5kcy55ICsgYm91bmRzLmhlaWdodCAvIDI7XG4gICAgY29uc3QgeCA9IHdpZHRoIC8gMiAtIGJvdW5kc0NlbnRlclggKiBjbGFtcGVkWm9vbTtcbiAgICBjb25zdCB5ID0gaGVpZ2h0IC8gMiAtIGJvdW5kc0NlbnRlclkgKiBjbGFtcGVkWm9vbTtcbiAgICAvLyBUaGVuIHdlIGNhbGN1bGF0ZSB0aGUgbWluaW11bSBwYWRkaW5nLCB0byByZXNwZWN0IGFzeW1tZXRyaWMgcGFkZGluZ3NcbiAgICBjb25zdCBuZXdQYWRkaW5nID0gY2FsY3VsYXRlQXBwbGllZFBhZGRpbmdzKGJvdW5kcywgeCwgeSwgY2xhbXBlZFpvb20sIHdpZHRoLCBoZWlnaHQpO1xuICAgIC8vIFdlIG9ubHkgd2FudCB0byBoYXZlIGFuIG9mZnNldCBpZiB0aGUgbmV3UGFkZGluZyBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlcXVpcmVkIHBhZGRpbmdcbiAgICBjb25zdCBvZmZzZXQgPSB7XG4gICAgICAgIGxlZnQ6IE1hdGgubWluKG5ld1BhZGRpbmcubGVmdCAtIHAubGVmdCwgMCksXG4gICAgICAgIHRvcDogTWF0aC5taW4obmV3UGFkZGluZy50b3AgLSBwLnRvcCwgMCksXG4gICAgICAgIHJpZ2h0OiBNYXRoLm1pbihuZXdQYWRkaW5nLnJpZ2h0IC0gcC5yaWdodCwgMCksXG4gICAgICAgIGJvdHRvbTogTWF0aC5taW4obmV3UGFkZGluZy5ib3R0b20gLSBwLmJvdHRvbSwgMCksXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4IC0gb2Zmc2V0LmxlZnQgKyBvZmZzZXQucmlnaHQsXG4gICAgICAgIHk6IHkgLSBvZmZzZXQudG9wICsgb2Zmc2V0LmJvdHRvbSxcbiAgICAgICAgem9vbTogY2xhbXBlZFpvb20sXG4gICAgfTtcbn07XG5jb25zdCBpc01hY09zID0gKCkgPT4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yPy51c2VyQWdlbnQ/LmluZGV4T2YoJ01hYycpID49IDA7XG5mdW5jdGlvbiBpc0Nvb3JkaW5hdGVFeHRlbnQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGV4dGVudCAhPT0gdW5kZWZpbmVkICYmIGV4dGVudCAhPT0gJ3BhcmVudCc7XG59XG5mdW5jdGlvbiBnZXROb2RlRGltZW5zaW9ucyhub2RlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IG5vZGUubWVhc3VyZWQ/LndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gMCxcbiAgICAgICAgaGVpZ2h0OiBub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IDAsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5vZGVIYXNEaW1lbnNpb25zKG5vZGUpIHtcbiAgICByZXR1cm4gKChub2RlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoKSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0KSAhPT0gdW5kZWZpbmVkKTtcbn1cbi8qKlxuICogQ29udmVydCBjaGlsZCBwb3NpdGlvbiB0byBhYm9zbHV0ZSBwb3NpdGlvblxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHBvc2l0aW9uXG4gKiBAcGFyYW0gcGFyZW50SWRcbiAqIEBwYXJhbSBub2RlTG9va3VwXG4gKiBAcGFyYW0gbm9kZU9yaWdpblxuICogQHJldHVybnMgYW4gaW50ZXJuYWwgbm9kZSB3aXRoIGFuIGFic29sdXRlIHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbihwb3NpdGlvbiwgZGltZW5zaW9ucyA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9LCBwYXJlbnRJZCwgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbikge1xuICAgIGNvbnN0IHBvc2l0aW9uQWJzb2x1dGUgPSB7IC4uLnBvc2l0aW9uIH07XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZUxvb2t1cC5nZXQocGFyZW50SWQpO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gcGFyZW50Lm9yaWdpbiB8fCBub2RlT3JpZ2luO1xuICAgICAgICBwb3NpdGlvbkFic29sdXRlLnggKz0gcGFyZW50LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggLSAoZGltZW5zaW9ucy53aWR0aCA/PyAwKSAqIG9yaWdpblswXTtcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZS55ICs9IHBhcmVudC5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55IC0gKGRpbWVuc2lvbnMuaGVpZ2h0ID8/IDApICogb3JpZ2luWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb25BYnNvbHV0ZTtcbn1cbmZ1bmN0aW9uIGFyZVNldHNFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGEpIHtcbiAgICAgICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgUHJvbWlzZS53aXRoUmVzb2x2ZXJzIHVudGlsIHdlIGNhbiB1c2UgaXQgaW4gYWxsIGJyb3dzZXJzXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gd2l0aFJlc29sdmVycygpIHtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBsZXQgcmVqZWN0O1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgcmVqZWN0ID0gcmVqO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xufVxuXG5mdW5jdGlvbiBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQsIHsgc25hcEdyaWQgPSBbMCwgMF0sIHNuYXBUb0dyaWQgPSBmYWxzZSwgdHJhbnNmb3JtLCBjb250YWluZXJCb3VuZHMgfSkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgcG9pbnRlclBvcyA9IHBvaW50VG9SZW5kZXJlclBvaW50KHsgeDogeCAtIChjb250YWluZXJCb3VuZHM/LmxlZnQgPz8gMCksIHk6IHkgLSAoY29udGFpbmVyQm91bmRzPy50b3AgPz8gMCkgfSwgdHJhbnNmb3JtKTtcbiAgICBjb25zdCB7IHg6IHhTbmFwcGVkLCB5OiB5U25hcHBlZCB9ID0gc25hcFRvR3JpZCA/IHNuYXBQb3NpdGlvbihwb2ludGVyUG9zLCBzbmFwR3JpZCkgOiBwb2ludGVyUG9zO1xuICAgIC8vIHdlIG5lZWQgdGhlIHNuYXBwZWQgcG9zaXRpb24gaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBza2lwIHVubmVjZXNzYXJ5IGRyYWcgZXZlbnRzXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeFNuYXBwZWQsXG4gICAgICAgIHlTbmFwcGVkLFxuICAgICAgICAuLi5wb2ludGVyUG9zLFxuICAgIH07XG59XG5jb25zdCBnZXREaW1lbnNpb25zID0gKG5vZGUpID0+ICh7XG4gICAgd2lkdGg6IG5vZGUub2Zmc2V0V2lkdGgsXG4gICAgaGVpZ2h0OiBub2RlLm9mZnNldEhlaWdodCxcbn0pO1xuY29uc3QgZ2V0SG9zdEZvckVsZW1lbnQgPSAoZWxlbWVudCkgPT4gZWxlbWVudD8uZ2V0Um9vdE5vZGU/LigpIHx8IHdpbmRvdz8uZG9jdW1lbnQ7XG5jb25zdCBpbnB1dFRhZ3MgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdURVhUQVJFQSddO1xuZnVuY3Rpb24gaXNJbnB1dERPTU5vZGUoZXZlbnQpIHtcbiAgICAvLyB1c2luZyBjb21wb3NlZCBwYXRoIGZvciBoYW5kbGluZyBzaGFkb3cgZG9tXG4gICAgY29uc3QgdGFyZ2V0ID0gKGV2ZW50LmNvbXBvc2VkUGF0aD8uKCk/LlswXSB8fCBldmVudC50YXJnZXQpO1xuICAgIGlmICh0YXJnZXQ/Lm5vZGVUeXBlICE9PSAxIC8qIE5vZGUuRUxFTUVOVF9OT0RFICovKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgaXNJbnB1dCA9IGlucHV0VGFncy5pbmNsdWRlcyh0YXJnZXQubm9kZU5hbWUpIHx8IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICAgIC8vIHdoZW4gYW4gaW5wdXQgZmllbGQgaXMgZm9jdXNlZCB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgZGVsZXRpb24gb3IgbW92ZW1lbnQgb2Ygbm9kZXNcbiAgICByZXR1cm4gaXNJbnB1dCB8fCAhIXRhcmdldC5jbG9zZXN0KCcubm9rZXknKTtcbn1cbmNvbnN0IGlzTW91c2VFdmVudCA9IChldmVudCkgPT4gJ2NsaWVudFgnIGluIGV2ZW50O1xuY29uc3QgZ2V0RXZlbnRQb3NpdGlvbiA9IChldmVudCwgYm91bmRzKSA9PiB7XG4gICAgY29uc3QgaXNNb3VzZSA9IGlzTW91c2VFdmVudChldmVudCk7XG4gICAgY29uc3QgZXZ0WCA9IGlzTW91c2UgPyBldmVudC5jbGllbnRYIDogZXZlbnQudG91Y2hlcz8uWzBdLmNsaWVudFg7XG4gICAgY29uc3QgZXZ0WSA9IGlzTW91c2UgPyBldmVudC5jbGllbnRZIDogZXZlbnQudG91Y2hlcz8uWzBdLmNsaWVudFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZ0WCAtIChib3VuZHM/LmxlZnQgPz8gMCksXG4gICAgICAgIHk6IGV2dFkgLSAoYm91bmRzPy50b3AgPz8gMCksXG4gICAgfTtcbn07XG4vKlxuICogVGhlIGhhbmRsZSBib3VuZHMgYXJlIGNhbGN1bGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG5vZGUgZWxlbWVudC5cbiAqIFdlIHN0b3JlIHRoZW0gaW4gdGhlIGludGVybmFscyBvYmplY3Qgb2YgdGhlIG5vZGUgaW4gb3JkZXIgdG8gYXZvaWRcbiAqIHVubmVjZXNzYXJ5IHJlY2FsY3VsYXRpb25zLlxuICovXG5jb25zdCBnZXRIYW5kbGVCb3VuZHMgPSAodHlwZSwgbm9kZUVsZW1lbnQsIG5vZGVCb3VuZHMsIHpvb20sIG5vZGVJZCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZXMgPSBub2RlRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHt0eXBlfWApO1xuICAgIGlmICghaGFuZGxlcyB8fCAhaGFuZGxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGhhbmRsZXMpLm1hcCgoaGFuZGxlKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUJvdW5kcyA9IGhhbmRsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBoYW5kbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZWlkJyksXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgcG9zaXRpb246IGhhbmRsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFuZGxlcG9zJyksXG4gICAgICAgICAgICB4OiAoaGFuZGxlQm91bmRzLmxlZnQgLSBub2RlQm91bmRzLmxlZnQpIC8gem9vbSxcbiAgICAgICAgICAgIHk6IChoYW5kbGVCb3VuZHMudG9wIC0gbm9kZUJvdW5kcy50b3ApIC8gem9vbSxcbiAgICAgICAgICAgIC4uLmdldERpbWVuc2lvbnMoaGFuZGxlKSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGdldEJlemllckVkZ2VDZW50ZXIoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VDb250cm9sWCwgc291cmNlQ29udHJvbFksIHRhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWSwgfSkge1xuICAgIC8qXG4gICAgICogY3ViaWMgYmV6aWVyIHQ9MC41IG1pZCBwb2ludCwgbm90IHRoZSBhY3R1YWwgbWlkIHBvaW50LCBidXQgZWFzeSB0byBjYWxjdWxhdGVcbiAgICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82NzUxNjEwMS9ob3ctdG8tZmluZC1kaXN0YW5jZS1taWQtcG9pbnQtb2YtYmV6aWVyLWN1cnZlXG4gICAgICovXG4gICAgY29uc3QgY2VudGVyWCA9IHNvdXJjZVggKiAwLjEyNSArIHNvdXJjZUNvbnRyb2xYICogMC4zNzUgKyB0YXJnZXRDb250cm9sWCAqIDAuMzc1ICsgdGFyZ2V0WCAqIDAuMTI1O1xuICAgIGNvbnN0IGNlbnRlclkgPSBzb3VyY2VZICogMC4xMjUgKyBzb3VyY2VDb250cm9sWSAqIDAuMzc1ICsgdGFyZ2V0Q29udHJvbFkgKiAwLjM3NSArIHRhcmdldFkgKiAwLjEyNTtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5hYnMoY2VudGVyWCAtIHNvdXJjZVgpO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmFicyhjZW50ZXJZIC0gc291cmNlWSk7XG4gICAgcmV0dXJuIFtjZW50ZXJYLCBjZW50ZXJZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoZGlzdGFuY2UsIGN1cnZhdHVyZSkge1xuICAgIGlmIChkaXN0YW5jZSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAwLjUgKiBkaXN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnZhdHVyZSAqIDI1ICogTWF0aC5zcXJ0KC1kaXN0YW5jZSk7XG59XG5mdW5jdGlvbiBnZXRDb250cm9sV2l0aEN1cnZhdHVyZSh7IHBvcywgeDEsIHkxLCB4MiwgeTIsIGMgfSkge1xuICAgIHN3aXRjaCAocG9zKSB7XG4gICAgICAgIGNhc2UgUG9zaXRpb24uTGVmdDpcbiAgICAgICAgICAgIHJldHVybiBbeDEgLSBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHgxIC0geDIsIGMpLCB5MV07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uUmlnaHQ6XG4gICAgICAgICAgICByZXR1cm4gW3gxICsgY2FsY3VsYXRlQ29udHJvbE9mZnNldCh4MiAtIHgxLCBjKSwgeTFdO1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlRvcDpcbiAgICAgICAgICAgIHJldHVybiBbeDEsIHkxIC0gY2FsY3VsYXRlQ29udHJvbE9mZnNldCh5MSAtIHkyLCBjKV07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uQm90dG9tOlxuICAgICAgICAgICAgcmV0dXJuIFt4MSwgeTEgKyBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHkyIC0geTEsIGMpXTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBgZ2V0QmV6aWVyUGF0aGAgdXRpbCByZXR1cm5zIGV2ZXJ5dGhpbmcgeW91IG5lZWQgdG8gcmVuZGVyIGEgYmV6aWVyIGVkZ2VcbiAqYmV0d2VlbiB0d28gbm9kZXMuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBBIHBhdGggc3RyaW5nIHlvdSBjYW4gdXNlIGluIGFuIFNWRywgdGhlIGBsYWJlbFhgIGFuZCBgbGFiZWxZYCBwb3NpdGlvbiAoY2VudGVyIG9mIHBhdGgpXG4gKiBhbmQgYG9mZnNldFhgLCBgb2Zmc2V0WWAgYmV0d2VlbiBzb3VyY2UgaGFuZGxlIGFuZCBsYWJlbC5cbiAqIC0gYHBhdGhgOiB0aGUgcGF0aCB0byB1c2UgaW4gYW4gU1ZHIGA8cGF0aD5gIGVsZW1lbnQuXG4gKiAtIGBsYWJlbFhgOiB0aGUgYHhgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBsYWJlbFlgOiB0aGUgYHlgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBvZmZzZXRYYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB4YCBwb3NpdGlvbiBhbmQgdGhlIGB4YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKiAtIGBvZmZzZXRZYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB5YCBwb3NpdGlvbiBhbmQgdGhlIGB5YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqICBjb25zdCBzb3VyY2UgPSB7IHg6IDAsIHk6IDIwIH07XG4gKiAgY29uc3QgdGFyZ2V0ID0geyB4OiAxNTAsIHk6IDEwMCB9O1xuICpcbiAqICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0QmV6aWVyUGF0aCh7XG4gKiAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAqICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICogICAgc291cmNlUG9zaXRpb246IFBvc2l0aW9uLlJpZ2h0LFxuICogICAgdGFyZ2V0WDogdGFyZ2V0LngsXG4gKiAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAqICAgIHRhcmdldFBvc2l0aW9uOiBQb3NpdGlvbi5MZWZ0LFxuICp9KTtcbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHVwbGUgKGFrYSBhIGZpeGVkLXNpemUgYXJyYXkpIHRvIG1ha2UgaXQgZWFzaWVyIHRvXG4gKndvcmsgd2l0aCBtdWx0aXBsZSBlZGdlIHBhdGhzIGF0IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIGdldEJlemllclBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0WCwgdGFyZ2V0WSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGN1cnZhdHVyZSA9IDAuMjUsIH0pIHtcbiAgICBjb25zdCBbc291cmNlQ29udHJvbFgsIHNvdXJjZUNvbnRyb2xZXSA9IGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHtcbiAgICAgICAgcG9zOiBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgeDE6IHNvdXJjZVgsXG4gICAgICAgIHkxOiBzb3VyY2VZLFxuICAgICAgICB4MjogdGFyZ2V0WCxcbiAgICAgICAgeTI6IHRhcmdldFksXG4gICAgICAgIGM6IGN1cnZhdHVyZSxcbiAgICB9KTtcbiAgICBjb25zdCBbdGFyZ2V0Q29udHJvbFgsIHRhcmdldENvbnRyb2xZXSA9IGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHtcbiAgICAgICAgcG9zOiB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgeDE6IHRhcmdldFgsXG4gICAgICAgIHkxOiB0YXJnZXRZLFxuICAgICAgICB4Mjogc291cmNlWCxcbiAgICAgICAgeTI6IHNvdXJjZVksXG4gICAgICAgIGM6IGN1cnZhdHVyZSxcbiAgICB9KTtcbiAgICBjb25zdCBbbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0QmV6aWVyRWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgICAgIHNvdXJjZUNvbnRyb2xYLFxuICAgICAgICBzb3VyY2VDb250cm9sWSxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFgsXG4gICAgICAgIHRhcmdldENvbnRyb2xZLFxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGBNJHtzb3VyY2VYfSwke3NvdXJjZVl9IEMke3NvdXJjZUNvbnRyb2xYfSwke3NvdXJjZUNvbnRyb2xZfSAke3RhcmdldENvbnRyb2xYfSwke3RhcmdldENvbnRyb2xZfSAke3RhcmdldFh9LCR7dGFyZ2V0WX1gLFxuICAgICAgICBsYWJlbFgsXG4gICAgICAgIGxhYmVsWSxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICBdO1xufVxuXG4vLyB0aGlzIGlzIHVzZWQgZm9yIHN0cmFpZ2h0IGVkZ2VzIGFuZCBzaW1wbGUgc21vb3Roc3RlcCBlZGdlcyAoTFRSLCBSVEwsIEJUVCwgVFRCKVxuZnVuY3Rpb24gZ2V0RWRnZUNlbnRlcih7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIH0pIHtcbiAgICBjb25zdCB4T2Zmc2V0ID0gTWF0aC5hYnModGFyZ2V0WCAtIHNvdXJjZVgpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJYID0gdGFyZ2V0WCA8IHNvdXJjZVggPyB0YXJnZXRYICsgeE9mZnNldCA6IHRhcmdldFggLSB4T2Zmc2V0O1xuICAgIGNvbnN0IHlPZmZzZXQgPSBNYXRoLmFicyh0YXJnZXRZIC0gc291cmNlWSkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSB0YXJnZXRZIDwgc291cmNlWSA/IHRhcmdldFkgKyB5T2Zmc2V0IDogdGFyZ2V0WSAtIHlPZmZzZXQ7XG4gICAgcmV0dXJuIFtjZW50ZXJYLCBjZW50ZXJZLCB4T2Zmc2V0LCB5T2Zmc2V0XTtcbn1cbmZ1bmN0aW9uIGdldEVsZXZhdGVkRWRnZVpJbmRleCh7IHNvdXJjZU5vZGUsIHRhcmdldE5vZGUsIHNlbGVjdGVkID0gZmFsc2UsIHpJbmRleCA9IDAsIGVsZXZhdGVPblNlbGVjdCA9IGZhbHNlLCB9KSB7XG4gICAgaWYgKCFlbGV2YXRlT25TZWxlY3QpIHtcbiAgICAgICAgcmV0dXJuIHpJbmRleDtcbiAgICB9XG4gICAgY29uc3QgZWRnZU9yQ29ubmVjdGVkTm9kZVNlbGVjdGVkID0gc2VsZWN0ZWQgfHwgdGFyZ2V0Tm9kZS5zZWxlY3RlZCB8fCBzb3VyY2VOb2RlLnNlbGVjdGVkO1xuICAgIGNvbnN0IHNlbGVjdGVkWkluZGV4ID0gTWF0aC5tYXgoc291cmNlTm9kZS5pbnRlcm5hbHMueiB8fCAwLCB0YXJnZXROb2RlLmludGVybmFscy56IHx8IDAsIDEwMDApO1xuICAgIHJldHVybiB6SW5kZXggKyAoZWRnZU9yQ29ubmVjdGVkTm9kZVNlbGVjdGVkID8gc2VsZWN0ZWRaSW5kZXggOiAwKTtcbn1cbmZ1bmN0aW9uIGlzRWRnZVZpc2libGUoeyBzb3VyY2VOb2RlLCB0YXJnZXROb2RlLCB3aWR0aCwgaGVpZ2h0LCB0cmFuc2Zvcm0gfSkge1xuICAgIGNvbnN0IGVkZ2VCb3ggPSBnZXRCb3VuZHNPZkJveGVzKG5vZGVUb0JveChzb3VyY2VOb2RlKSwgbm9kZVRvQm94KHRhcmdldE5vZGUpKTtcbiAgICBpZiAoZWRnZUJveC54ID09PSBlZGdlQm94LngyKSB7XG4gICAgICAgIGVkZ2VCb3gueDIgKz0gMTtcbiAgICB9XG4gICAgaWYgKGVkZ2VCb3gueSA9PT0gZWRnZUJveC55Mikge1xuICAgICAgICBlZGdlQm94LnkyICs9IDE7XG4gICAgfVxuICAgIGNvbnN0IHZpZXdSZWN0ID0ge1xuICAgICAgICB4OiAtdHJhbnNmb3JtWzBdIC8gdHJhbnNmb3JtWzJdLFxuICAgICAgICB5OiAtdHJhbnNmb3JtWzFdIC8gdHJhbnNmb3JtWzJdLFxuICAgICAgICB3aWR0aDogd2lkdGggLyB0cmFuc2Zvcm1bMl0sXG4gICAgICAgIGhlaWdodDogaGVpZ2h0IC8gdHJhbnNmb3JtWzJdLFxuICAgIH07XG4gICAgcmV0dXJuIGdldE92ZXJsYXBwaW5nQXJlYSh2aWV3UmVjdCwgYm94VG9SZWN0KGVkZ2VCb3gpKSA+IDA7XG59XG5jb25zdCBnZXRFZGdlSWQgPSAoeyBzb3VyY2UsIHNvdXJjZUhhbmRsZSwgdGFyZ2V0LCB0YXJnZXRIYW5kbGUgfSkgPT4gYHh5LWVkZ2VfXyR7c291cmNlfSR7c291cmNlSGFuZGxlIHx8ICcnfS0ke3RhcmdldH0ke3RhcmdldEhhbmRsZSB8fCAnJ31gO1xuY29uc3QgY29ubmVjdGlvbkV4aXN0cyA9IChlZGdlLCBlZGdlcykgPT4ge1xuICAgIHJldHVybiBlZGdlcy5zb21lKChlbCkgPT4gZWwuc291cmNlID09PSBlZGdlLnNvdXJjZSAmJlxuICAgICAgICBlbC50YXJnZXQgPT09IGVkZ2UudGFyZ2V0ICYmXG4gICAgICAgIChlbC5zb3VyY2VIYW5kbGUgPT09IGVkZ2Uuc291cmNlSGFuZGxlIHx8ICghZWwuc291cmNlSGFuZGxlICYmICFlZGdlLnNvdXJjZUhhbmRsZSkpICYmXG4gICAgICAgIChlbC50YXJnZXRIYW5kbGUgPT09IGVkZ2UudGFyZ2V0SGFuZGxlIHx8ICghZWwudGFyZ2V0SGFuZGxlICYmICFlZGdlLnRhcmdldEhhbmRsZSkpKTtcbn07XG4vKipcbiAqIFRoaXMgdXRpbCBpcyBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFkZCBhIG5ldyBFZGdlIHRvIGFuIGFycmF5IG9mIGVkZ2VzLiBJdCBhbHNvIHBlcmZvcm1zIHNvbWUgdmFsaWRhdGlvbiB0byBtYWtlIHN1cmUgeW91IGRvbid0IGFkZCBhbiBpbnZhbGlkIGVkZ2Ugb3IgZHVwbGljYXRlIGFuIGV4aXN0aW5nIG9uZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBlZGdlUGFyYW1zIC0gRWl0aGVyIGFuIGBFZGdlYCBvciBhIGBDb25uZWN0aW9uYCB5b3Ugd2FudCB0byBhZGQuXG4gKiBAcGFyYW0gZWRnZXMgLSBUaGUgYXJyYXkgb2YgYWxsIGN1cnJlbnQgZWRnZXMuXG4gKiBAcmV0dXJucyBBIG5ldyBhcnJheSBvZiBlZGdlcyB3aXRoIHRoZSBuZXcgZWRnZSBhZGRlZC5cbiAqXG4gKiBAcmVtYXJrcyBJZiBhbiBlZGdlIHdpdGggdGhlIHNhbWUgYHRhcmdldGAgYW5kIGBzb3VyY2VgIGFscmVhZHkgZXhpc3RzIChhbmQgdGhlIHNhbWVcbiAqYHRhcmdldEhhbmRsZWAgYW5kIGBzb3VyY2VIYW5kbGVgIGlmIHRob3NlIGFyZSBzZXQpLCB0aGVuIHRoaXMgdXRpbCB3b24ndCBhZGRcbiAqYSBuZXcgZWRnZSBldmVuIGlmIHRoZSBgaWRgIHByb3BlcnR5IGlzIGRpZmZlcmVudC5cbiAqXG4gKi9cbmNvbnN0IGFkZEVkZ2UgPSAoZWRnZVBhcmFtcywgZWRnZXMpID0+IHtcbiAgICBpZiAoIWVkZ2VQYXJhbXMuc291cmNlIHx8ICFlZGdlUGFyYW1zLnRhcmdldCkge1xuICAgICAgICBkZXZXYXJuKCcwMDYnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNiddKCkpO1xuICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIGxldCBlZGdlO1xuICAgIGlmIChpc0VkZ2VCYXNlKGVkZ2VQYXJhbXMpKSB7XG4gICAgICAgIGVkZ2UgPSB7IC4uLmVkZ2VQYXJhbXMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVkZ2UgPSB7XG4gICAgICAgICAgICAuLi5lZGdlUGFyYW1zLFxuICAgICAgICAgICAgaWQ6IGdldEVkZ2VJZChlZGdlUGFyYW1zKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNvbm5lY3Rpb25FeGlzdHMoZWRnZSwgZWRnZXMpKSB7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgaWYgKGVkZ2Uuc291cmNlSGFuZGxlID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBlZGdlLnNvdXJjZUhhbmRsZTtcbiAgICB9XG4gICAgaWYgKGVkZ2UudGFyZ2V0SGFuZGxlID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBlZGdlLnRhcmdldEhhbmRsZTtcbiAgICB9XG4gICAgcmV0dXJuIGVkZ2VzLmNvbmNhdChlZGdlKTtcbn07XG4vKipcbiAqIEEgaGFuZHkgdXRpbGl0eSB0byB1cGRhdGUgYW4gZXhpc3RpbmcgW2BFZGdlYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvZWRnZSkgd2l0aCBuZXcgcHJvcGVydGllcy5cbiAqVGhpcyBzZWFyY2hlcyB5b3VyIGVkZ2UgYXJyYXkgZm9yIGFuIGVkZ2Ugd2l0aCBhIG1hdGNoaW5nIGBpZGAgYW5kIHVwZGF0ZXMgaXRzXG4gKnByb3BlcnRpZXMgd2l0aCB0aGUgY29ubmVjdGlvbiB5b3UgcHJvdmlkZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBvbGRFZGdlIC0gVGhlIGVkZ2UgeW91IHdhbnQgdG8gdXBkYXRlLlxuICogQHBhcmFtIG5ld0Nvbm5lY3Rpb24gLSBUaGUgbmV3IGNvbm5lY3Rpb24geW91IHdhbnQgdG8gdXBkYXRlIHRoZSBlZGdlIHdpdGguXG4gKiBAcGFyYW0gZWRnZXMgLSBUaGUgYXJyYXkgb2YgYWxsIGN1cnJlbnQgZWRnZXMuXG4gKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBlZGdlcyBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqY29uc3Qgb25SZWNvbm5lY3QgPSB1c2VDYWxsYmFjayhcbiAqICAob2xkRWRnZTogRWRnZSwgbmV3Q29ubmVjdGlvbjogQ29ubmVjdGlvbikgPT4gc2V0RWRnZXMoKGVscykgPT4gcmVjb25uZWN0RWRnZShvbGRFZGdlLCBuZXdDb25uZWN0aW9uLCBlbHMpKSxbXSk7XG4gKmBgYFxuICovXG5jb25zdCByZWNvbm5lY3RFZGdlID0gKG9sZEVkZ2UsIG5ld0Nvbm5lY3Rpb24sIGVkZ2VzLCBvcHRpb25zID0geyBzaG91bGRSZXBsYWNlSWQ6IHRydWUgfSkgPT4ge1xuICAgIGNvbnN0IHsgaWQ6IG9sZEVkZ2VJZCwgLi4ucmVzdCB9ID0gb2xkRWRnZTtcbiAgICBpZiAoIW5ld0Nvbm5lY3Rpb24uc291cmNlIHx8ICFuZXdDb25uZWN0aW9uLnRhcmdldCkge1xuICAgICAgICBkZXZXYXJuKCcwMDYnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNiddKCkpO1xuICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIGNvbnN0IGZvdW5kRWRnZSA9IGVkZ2VzLmZpbmQoKGUpID0+IGUuaWQgPT09IG9sZEVkZ2UuaWQpO1xuICAgIGlmICghZm91bmRFZGdlKSB7XG4gICAgICAgIGRldldhcm4oJzAwNycsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA3J10ob2xkRWRnZUlkKSk7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgLy8gUmVtb3ZlIG9sZCBlZGdlIGFuZCBjcmVhdGUgdGhlIG5ldyBlZGdlIHdpdGggcGFyYW1ldGVycyBvZiBvbGQgZWRnZS5cbiAgICBjb25zdCBlZGdlID0ge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICBpZDogb3B0aW9ucy5zaG91bGRSZXBsYWNlSWQgPyBnZXRFZGdlSWQobmV3Q29ubmVjdGlvbikgOiBvbGRFZGdlSWQsXG4gICAgICAgIHNvdXJjZTogbmV3Q29ubmVjdGlvbi5zb3VyY2UsXG4gICAgICAgIHRhcmdldDogbmV3Q29ubmVjdGlvbi50YXJnZXQsXG4gICAgICAgIHNvdXJjZUhhbmRsZTogbmV3Q29ubmVjdGlvbi5zb3VyY2VIYW5kbGUsXG4gICAgICAgIHRhcmdldEhhbmRsZTogbmV3Q29ubmVjdGlvbi50YXJnZXRIYW5kbGUsXG4gICAgfTtcbiAgICByZXR1cm4gZWRnZXMuZmlsdGVyKChlKSA9PiBlLmlkICE9PSBvbGRFZGdlSWQpLmNvbmNhdChlZGdlKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3RyYWlnaHQgbGluZSBwYXRoIGJldHdlZW4gdHdvIHBvaW50cy5cbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEEgcGF0aCBzdHJpbmcgeW91IGNhbiB1c2UgaW4gYW4gU1ZHLCB0aGUgYGxhYmVsWGAgYW5kIGBsYWJlbFlgIHBvc2l0aW9uIChjZW50ZXIgb2YgcGF0aClcbiAqIGFuZCBgb2Zmc2V0WGAsIGBvZmZzZXRZYCBiZXR3ZWVuIHNvdXJjZSBoYW5kbGUgYW5kIGxhYmVsLlxuICpcbiAqIC0gYHBhdGhgOiB0aGUgcGF0aCB0byB1c2UgaW4gYW4gU1ZHIGA8cGF0aD5gIGVsZW1lbnQuXG4gKiAtIGBsYWJlbFhgOiB0aGUgYHhgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBsYWJlbFlgOiB0aGUgYHlgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBvZmZzZXRYYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB4YCBwb3NpdGlvbiBhbmQgdGhlIGB4YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKiAtIGBvZmZzZXRZYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB5YCBwb3NpdGlvbiBhbmQgdGhlIGB5YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqICBjb25zdCBzb3VyY2UgPSB7IHg6IDAsIHk6IDIwIH07XG4gKiAgY29uc3QgdGFyZ2V0ID0geyB4OiAxNTAsIHk6IDEwMCB9O1xuICpcbiAqICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0U3RyYWlnaHRQYXRoKHtcbiAqICAgIHNvdXJjZVg6IHNvdXJjZS54LFxuICogICAgc291cmNlWTogc291cmNlLnksXG4gKiAgICBzb3VyY2VQb3NpdGlvbjogUG9zaXRpb24uUmlnaHQsXG4gKiAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAqICAgIHRhcmdldFk6IHRhcmdldC55LFxuICogICAgdGFyZ2V0UG9zaXRpb246IFBvc2l0aW9uLkxlZnQsXG4gKiAgfSk7XG4gKiBgYGBcbiAqIEByZW1hcmtzIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHR1cGxlIChha2EgYSBmaXhlZC1zaXplIGFycmF5KSB0byBtYWtlIGl0IGVhc2llciB0byB3b3JrIHdpdGggbXVsdGlwbGUgZWRnZSBwYXRocyBhdCBvbmNlLlxuICovXG5mdW5jdGlvbiBnZXRTdHJhaWdodFBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCB9KSB7XG4gICAgY29uc3QgW2xhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldEVkZ2VDZW50ZXIoe1xuICAgICAgICBzb3VyY2VYLFxuICAgICAgICBzb3VyY2VZLFxuICAgICAgICB0YXJnZXRYLFxuICAgICAgICB0YXJnZXRZLFxuICAgIH0pO1xuICAgIHJldHVybiBbYE0gJHtzb3VyY2VYfSwke3NvdXJjZVl9TCAke3RhcmdldFh9LCR7dGFyZ2V0WX1gLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV07XG59XG5cbmNvbnN0IGhhbmRsZURpcmVjdGlvbnMgPSB7XG4gICAgW1Bvc2l0aW9uLkxlZnRdOiB7IHg6IC0xLCB5OiAwIH0sXG4gICAgW1Bvc2l0aW9uLlJpZ2h0XTogeyB4OiAxLCB5OiAwIH0sXG4gICAgW1Bvc2l0aW9uLlRvcF06IHsgeDogMCwgeTogLTEgfSxcbiAgICBbUG9zaXRpb24uQm90dG9tXTogeyB4OiAwLCB5OiAxIH0sXG59O1xuY29uc3QgZ2V0RGlyZWN0aW9uID0gKHsgc291cmNlLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0LCB9KSA9PiB7XG4gICAgaWYgKHNvdXJjZVBvc2l0aW9uID09PSBQb3NpdGlvbi5MZWZ0IHx8IHNvdXJjZVBvc2l0aW9uID09PSBQb3NpdGlvbi5SaWdodCkge1xuICAgICAgICByZXR1cm4gc291cmNlLnggPCB0YXJnZXQueCA/IHsgeDogMSwgeTogMCB9IDogeyB4OiAtMSwgeTogMCB9O1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlLnkgPCB0YXJnZXQueSA/IHsgeDogMCwgeTogMSB9IDogeyB4OiAwLCB5OiAtMSB9O1xufTtcbmNvbnN0IGRpc3RhbmNlID0gKGEsIGIpID0+IE1hdGguc3FydChNYXRoLnBvdyhiLnggLSBhLngsIDIpICsgTWF0aC5wb3coYi55IC0gYS55LCAyKSk7XG4vKlxuICogV2l0aCB0aGlzIGZ1bmN0aW9uIHdlIHRyeSB0byBtaW1pYyBhbiBvcnRob2dvbmFsIGVkZ2Ugcm91dGluZyBiZWhhdmlvdXJcbiAqIEl0J3Mgbm90IGFzIGdvb2QgYXMgYSByZWFsIG9ydGhvZ29uYWwgZWRnZSByb3V0aW5nLCBidXQgaXQncyBmYXN0ZXIgYW5kIGdvb2QgZW5vdWdoIGFzIGEgZGVmYXVsdCBmb3Igc3RlcCBhbmQgc21vb3RoIHN0ZXAgZWRnZXNcbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRzKHsgc291cmNlLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0LCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgY2VudGVyLCBvZmZzZXQsIH0pIHtcbiAgICBjb25zdCBzb3VyY2VEaXIgPSBoYW5kbGVEaXJlY3Rpb25zW3NvdXJjZVBvc2l0aW9uXTtcbiAgICBjb25zdCB0YXJnZXREaXIgPSBoYW5kbGVEaXJlY3Rpb25zW3RhcmdldFBvc2l0aW9uXTtcbiAgICBjb25zdCBzb3VyY2VHYXBwZWQgPSB7IHg6IHNvdXJjZS54ICsgc291cmNlRGlyLnggKiBvZmZzZXQsIHk6IHNvdXJjZS55ICsgc291cmNlRGlyLnkgKiBvZmZzZXQgfTtcbiAgICBjb25zdCB0YXJnZXRHYXBwZWQgPSB7IHg6IHRhcmdldC54ICsgdGFyZ2V0RGlyLnggKiBvZmZzZXQsIHk6IHRhcmdldC55ICsgdGFyZ2V0RGlyLnkgKiBvZmZzZXQgfTtcbiAgICBjb25zdCBkaXIgPSBnZXREaXJlY3Rpb24oe1xuICAgICAgICBzb3VyY2U6IHNvdXJjZUdhcHBlZCxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldDogdGFyZ2V0R2FwcGVkLFxuICAgIH0pO1xuICAgIGNvbnN0IGRpckFjY2Vzc29yID0gZGlyLnggIT09IDAgPyAneCcgOiAneSc7XG4gICAgY29uc3QgY3VyckRpciA9IGRpcltkaXJBY2Nlc3Nvcl07XG4gICAgbGV0IHBvaW50cyA9IFtdO1xuICAgIGxldCBjZW50ZXJYLCBjZW50ZXJZO1xuICAgIGNvbnN0IHNvdXJjZUdhcE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICAgIGNvbnN0IHRhcmdldEdhcE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICAgIGNvbnN0IFtkZWZhdWx0Q2VudGVyWCwgZGVmYXVsdENlbnRlclksIGRlZmF1bHRPZmZzZXRYLCBkZWZhdWx0T2Zmc2V0WV0gPSBnZXRFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWDogc291cmNlLngsXG4gICAgICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICAgICAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAgICAgICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gICAgfSk7XG4gICAgLy8gb3Bwb3NpdGUgaGFuZGxlIHBvc2l0aW9ucywgZGVmYXVsdCBjYXNlXG4gICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gKiB0YXJnZXREaXJbZGlyQWNjZXNzb3JdID09PSAtMSkge1xuICAgICAgICBjZW50ZXJYID0gY2VudGVyLnggPz8gZGVmYXVsdENlbnRlclg7XG4gICAgICAgIGNlbnRlclkgPSBjZW50ZXIueSA/PyBkZWZhdWx0Q2VudGVyWTtcbiAgICAgICAgLypcbiAgICAgICAgICogICAgLS0tPlxuICAgICAgICAgKiAgICB8XG4gICAgICAgICAqID4tLS1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHZlcnRpY2FsU3BsaXQgPSBbXG4gICAgICAgICAgICB7IHg6IGNlbnRlclgsIHk6IHNvdXJjZUdhcHBlZC55IH0sXG4gICAgICAgICAgICB7IHg6IGNlbnRlclgsIHk6IHRhcmdldEdhcHBlZC55IH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qXG4gICAgICAgICAqICAgIHxcbiAgICAgICAgICogIC0tLVxuICAgICAgICAgKiAgfFxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgaG9yaXpvbnRhbFNwbGl0ID0gW1xuICAgICAgICAgICAgeyB4OiBzb3VyY2VHYXBwZWQueCwgeTogY2VudGVyWSB9LFxuICAgICAgICAgICAgeyB4OiB0YXJnZXRHYXBwZWQueCwgeTogY2VudGVyWSB9LFxuICAgICAgICBdO1xuICAgICAgICBpZiAoc291cmNlRGlyW2RpckFjY2Vzc29yXSA9PT0gY3VyckRpcikge1xuICAgICAgICAgICAgcG9pbnRzID0gZGlyQWNjZXNzb3IgPT09ICd4JyA/IHZlcnRpY2FsU3BsaXQgOiBob3Jpem9udGFsU3BsaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb2ludHMgPSBkaXJBY2Nlc3NvciA9PT0gJ3gnID8gaG9yaXpvbnRhbFNwbGl0IDogdmVydGljYWxTcGxpdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gc291cmNlVGFyZ2V0IG1lYW5zIHdlIHRha2UgeCBmcm9tIHNvdXJjZSBhbmQgeSBmcm9tIHRhcmdldCwgdGFyZ2V0U291cmNlIGlzIHRoZSBvcHBvc2l0ZVxuICAgICAgICBjb25zdCBzb3VyY2VUYXJnZXQgPSBbeyB4OiBzb3VyY2VHYXBwZWQueCwgeTogdGFyZ2V0R2FwcGVkLnkgfV07XG4gICAgICAgIGNvbnN0IHRhcmdldFNvdXJjZSA9IFt7IHg6IHRhcmdldEdhcHBlZC54LCB5OiBzb3VyY2VHYXBwZWQueSB9XTtcbiAgICAgICAgLy8gdGhpcyBoYW5kbGVzIGVkZ2VzIHdpdGggc2FtZSBoYW5kbGUgcG9zaXRpb25zXG4gICAgICAgIGlmIChkaXJBY2Nlc3NvciA9PT0gJ3gnKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBzb3VyY2VEaXIueCA9PT0gY3VyckRpciA/IHRhcmdldFNvdXJjZSA6IHNvdXJjZVRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50cyA9IHNvdXJjZURpci55ID09PSBjdXJyRGlyID8gc291cmNlVGFyZ2V0IDogdGFyZ2V0U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VQb3NpdGlvbiA9PT0gdGFyZ2V0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyhzb3VyY2VbZGlyQWNjZXNzb3JdIC0gdGFyZ2V0W2RpckFjY2Vzc29yXSk7XG4gICAgICAgICAgICAvLyBpZiBhbiBlZGdlIGdvZXMgZnJvbSByaWdodCB0byByaWdodCBmb3IgZXhhbXBsZSAoc291cmNlUG9zaXRpb24gPT09IHRhcmdldFBvc2l0aW9uKSBhbmQgdGhlIGRpc3RhbmNlIGJldHdlZW4gc291cmNlLnggYW5kIHRhcmdldC54IGlzIGxlc3MgdGhhbiB0aGUgb2Zmc2V0LCB0aGUgYWRkZWQgcG9pbnQgYW5kIHRoZSBnYXBwZWQgc291cmNlL3RhcmdldCB3aWxsIG92ZXJsYXAuIFRoaXMgbGVhZHMgdG8gYSB3ZWlyZCBlZGdlIHBhdGguIFRvIGF2b2lkIHRoaXMgd2UgYWRkIGEgZ2FwT2Zmc2V0IHRvIHRoZSBzb3VyY2UvdGFyZ2V0XG4gICAgICAgICAgICBpZiAoZGlmZiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnYXBPZmZzZXQgPSBNYXRoLm1pbihvZmZzZXQgLSAxLCBvZmZzZXQgLSBkaWZmKTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlRGlyW2RpckFjY2Vzc29yXSA9PT0gY3VyckRpcikge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VHYXBPZmZzZXRbZGlyQWNjZXNzb3JdID0gKHNvdXJjZUdhcHBlZFtkaXJBY2Nlc3Nvcl0gPiBzb3VyY2VbZGlyQWNjZXNzb3JdID8gLTEgOiAxKSAqIGdhcE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEdhcE9mZnNldFtkaXJBY2Nlc3Nvcl0gPSAodGFyZ2V0R2FwcGVkW2RpckFjY2Vzc29yXSA+IHRhcmdldFtkaXJBY2Nlc3Nvcl0gPyAtMSA6IDEpICogZ2FwT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGVzZSBhcmUgY29uZGl0aW9ucyBmb3IgaGFuZGxpbmcgbWl4ZWQgaGFuZGxlIHBvc2l0aW9ucyBsaWtlIFJpZ2h0IC0+IEJvdHRvbSBmb3IgZXhhbXBsZVxuICAgICAgICBpZiAoc291cmNlUG9zaXRpb24gIT09IHRhcmdldFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBkaXJBY2Nlc3Nvck9wcG9zaXRlID0gZGlyQWNjZXNzb3IgPT09ICd4JyA/ICd5JyA6ICd4JztcbiAgICAgICAgICAgIGNvbnN0IGlzU2FtZURpciA9IHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IHRhcmdldERpcltkaXJBY2Nlc3Nvck9wcG9zaXRlXTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUd0VGFyZ2V0T3BwbyA9IHNvdXJjZUdhcHBlZFtkaXJBY2Nlc3Nvck9wcG9zaXRlXSA+IHRhcmdldEdhcHBlZFtkaXJBY2Nlc3Nvck9wcG9zaXRlXTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUx0VGFyZ2V0T3BwbyA9IHNvdXJjZUdhcHBlZFtkaXJBY2Nlc3Nvck9wcG9zaXRlXSA8IHRhcmdldEdhcHBlZFtkaXJBY2Nlc3Nvck9wcG9zaXRlXTtcbiAgICAgICAgICAgIGNvbnN0IGZsaXBTb3VyY2VUYXJnZXQgPSAoc291cmNlRGlyW2RpckFjY2Vzc29yXSA9PT0gMSAmJiAoKCFpc1NhbWVEaXIgJiYgc291cmNlR3RUYXJnZXRPcHBvKSB8fCAoaXNTYW1lRGlyICYmIHNvdXJjZUx0VGFyZ2V0T3BwbykpKSB8fFxuICAgICAgICAgICAgICAgIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdICE9PSAxICYmICgoIWlzU2FtZURpciAmJiBzb3VyY2VMdFRhcmdldE9wcG8pIHx8IChpc1NhbWVEaXIgJiYgc291cmNlR3RUYXJnZXRPcHBvKSkpO1xuICAgICAgICAgICAgaWYgKGZsaXBTb3VyY2VUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBkaXJBY2Nlc3NvciA9PT0gJ3gnID8gc291cmNlVGFyZ2V0IDogdGFyZ2V0U291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZUdhcFBvaW50ID0geyB4OiBzb3VyY2VHYXBwZWQueCArIHNvdXJjZUdhcE9mZnNldC54LCB5OiBzb3VyY2VHYXBwZWQueSArIHNvdXJjZUdhcE9mZnNldC55IH07XG4gICAgICAgIGNvbnN0IHRhcmdldEdhcFBvaW50ID0geyB4OiB0YXJnZXRHYXBwZWQueCArIHRhcmdldEdhcE9mZnNldC54LCB5OiB0YXJnZXRHYXBwZWQueSArIHRhcmdldEdhcE9mZnNldC55IH07XG4gICAgICAgIGNvbnN0IG1heFhEaXN0YW5jZSA9IE1hdGgubWF4KE1hdGguYWJzKHNvdXJjZUdhcFBvaW50LnggLSBwb2ludHNbMF0ueCksIE1hdGguYWJzKHRhcmdldEdhcFBvaW50LnggLSBwb2ludHNbMF0ueCkpO1xuICAgICAgICBjb25zdCBtYXhZRGlzdGFuY2UgPSBNYXRoLm1heChNYXRoLmFicyhzb3VyY2VHYXBQb2ludC55IC0gcG9pbnRzWzBdLnkpLCBNYXRoLmFicyh0YXJnZXRHYXBQb2ludC55IC0gcG9pbnRzWzBdLnkpKTtcbiAgICAgICAgLy8gd2Ugd2FudCB0byBwbGFjZSB0aGUgbGFiZWwgb24gdGhlIGxvbmdlc3Qgc2VnbWVudCBvZiB0aGUgZWRnZVxuICAgICAgICBpZiAobWF4WERpc3RhbmNlID49IG1heFlEaXN0YW5jZSkge1xuICAgICAgICAgICAgY2VudGVyWCA9IChzb3VyY2VHYXBQb2ludC54ICsgdGFyZ2V0R2FwUG9pbnQueCkgLyAyO1xuICAgICAgICAgICAgY2VudGVyWSA9IHBvaW50c1swXS55O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2VudGVyWCA9IHBvaW50c1swXS54O1xuICAgICAgICAgICAgY2VudGVyWSA9IChzb3VyY2VHYXBQb2ludC55ICsgdGFyZ2V0R2FwUG9pbnQueSkgLyAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhdGhQb2ludHMgPSBbXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgeyB4OiBzb3VyY2VHYXBwZWQueCArIHNvdXJjZUdhcE9mZnNldC54LCB5OiBzb3VyY2VHYXBwZWQueSArIHNvdXJjZUdhcE9mZnNldC55IH0sXG4gICAgICAgIC4uLnBvaW50cyxcbiAgICAgICAgeyB4OiB0YXJnZXRHYXBwZWQueCArIHRhcmdldEdhcE9mZnNldC54LCB5OiB0YXJnZXRHYXBwZWQueSArIHRhcmdldEdhcE9mZnNldC55IH0sXG4gICAgICAgIHRhcmdldCxcbiAgICBdO1xuICAgIHJldHVybiBbcGF0aFBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgZGVmYXVsdE9mZnNldFgsIGRlZmF1bHRPZmZzZXRZXTtcbn1cbmZ1bmN0aW9uIGdldEJlbmQoYSwgYiwgYywgc2l6ZSkge1xuICAgIGNvbnN0IGJlbmRTaXplID0gTWF0aC5taW4oZGlzdGFuY2UoYSwgYikgLyAyLCBkaXN0YW5jZShiLCBjKSAvIDIsIHNpemUpO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYjtcbiAgICAvLyBubyBiZW5kXG4gICAgaWYgKChhLnggPT09IHggJiYgeCA9PT0gYy54KSB8fCAoYS55ID09PSB5ICYmIHkgPT09IGMueSkpIHtcbiAgICAgICAgcmV0dXJuIGBMJHt4fSAke3l9YDtcbiAgICB9XG4gICAgLy8gZmlyc3Qgc2VnbWVudCBpcyBob3Jpem9udGFsXG4gICAgaWYgKGEueSA9PT0geSkge1xuICAgICAgICBjb25zdCB4RGlyID0gYS54IDwgYy54ID8gLTEgOiAxO1xuICAgICAgICBjb25zdCB5RGlyID0gYS55IDwgYy55ID8gMSA6IC0xO1xuICAgICAgICByZXR1cm4gYEwgJHt4ICsgYmVuZFNpemUgKiB4RGlyfSwke3l9USAke3h9LCR7eX0gJHt4fSwke3kgKyBiZW5kU2l6ZSAqIHlEaXJ9YDtcbiAgICB9XG4gICAgY29uc3QgeERpciA9IGEueCA8IGMueCA/IDEgOiAtMTtcbiAgICBjb25zdCB5RGlyID0gYS55IDwgYy55ID8gLTEgOiAxO1xuICAgIHJldHVybiBgTCAke3h9LCR7eSArIGJlbmRTaXplICogeURpcn1RICR7eH0sJHt5fSAke3ggKyBiZW5kU2l6ZSAqIHhEaXJ9LCR7eX1gO1xufVxuLyoqXG4gKiBUaGUgYGdldFNtb290aFN0ZXBQYXRoYCB1dGlsIHJldHVybnMgZXZlcnl0aGluZyB5b3UgbmVlZCB0byByZW5kZXIgYSBzdGVwcGVkIHBhdGhcbiAqIGJldHdlZW4gdHdvIG5vZGVzLiBUaGUgYGJvcmRlclJhZGl1c2AgcHJvcGVydHkgY2FuIGJlIHVzZWQgdG8gY2hvb3NlIGhvdyByb3VuZGVkXG4gKiB0aGUgY29ybmVycyBvZiB0aG9zZSBzdGVwcyBhcmUuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBBIHBhdGggc3RyaW5nIHlvdSBjYW4gdXNlIGluIGFuIFNWRywgdGhlIGBsYWJlbFhgIGFuZCBgbGFiZWxZYCBwb3NpdGlvbiAoY2VudGVyIG9mIHBhdGgpXG4gKiBhbmQgYG9mZnNldFhgLCBgb2Zmc2V0WWAgYmV0d2VlbiBzb3VyY2UgaGFuZGxlIGFuZCBsYWJlbC5cbiAqXG4gKiAtIGBwYXRoYDogdGhlIHBhdGggdG8gdXNlIGluIGFuIFNWRyBgPHBhdGg+YCBlbGVtZW50LlxuICogLSBgbGFiZWxYYDogdGhlIGB4YCBwb3NpdGlvbiB5b3UgY2FuIHVzZSB0byByZW5kZXIgYSBsYWJlbCBmb3IgdGhpcyBlZGdlLlxuICogLSBgbGFiZWxZYDogdGhlIGB5YCBwb3NpdGlvbiB5b3UgY2FuIHVzZSB0byByZW5kZXIgYSBsYWJlbCBmb3IgdGhpcyBlZGdlLlxuICogLSBgb2Zmc2V0WGA6IHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNvdXJjZSBgeGAgcG9zaXRpb24gYW5kIHRoZSBgeGAgcG9zaXRpb24gb2YgdGhlXG4gKiBtaWRkbGUgb2YgdGhpcyBwYXRoLlxuICogLSBgb2Zmc2V0WWA6IHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNvdXJjZSBgeWAgcG9zaXRpb24gYW5kIHRoZSBgeWAgcG9zaXRpb24gb2YgdGhlXG4gKiBtaWRkbGUgb2YgdGhpcyBwYXRoLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAgY29uc3Qgc291cmNlID0geyB4OiAwLCB5OiAyMCB9O1xuICogIGNvbnN0IHRhcmdldCA9IHsgeDogMTUwLCB5OiAxMDAgfTtcbiAqXG4gKiAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldFNtb290aFN0ZXBQYXRoKHtcbiAqICAgIHNvdXJjZVg6IHNvdXJjZS54LFxuICogICAgc291cmNlWTogc291cmNlLnksXG4gKiAgICBzb3VyY2VQb3NpdGlvbjogUG9zaXRpb24uUmlnaHQsXG4gKiAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAqICAgIHRhcmdldFk6IHRhcmdldC55LFxuICogICAgdGFyZ2V0UG9zaXRpb246IFBvc2l0aW9uLkxlZnQsXG4gKiAgfSk7XG4gKiBgYGBcbiAqIEByZW1hcmtzIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHR1cGxlIChha2EgYSBmaXhlZC1zaXplIGFycmF5KSB0byBtYWtlIGl0IGVhc2llciB0byB3b3JrIHdpdGggbXVsdGlwbGUgZWRnZSBwYXRocyBhdCBvbmNlLlxuICovXG5mdW5jdGlvbiBnZXRTbW9vdGhTdGVwUGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRYLCB0YXJnZXRZLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgYm9yZGVyUmFkaXVzID0gNSwgY2VudGVyWCwgY2VudGVyWSwgb2Zmc2V0ID0gMjAsIH0pIHtcbiAgICBjb25zdCBbcG9pbnRzLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRQb2ludHMoe1xuICAgICAgICBzb3VyY2U6IHsgeDogc291cmNlWCwgeTogc291cmNlWSB9LFxuICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0OiB7IHg6IHRhcmdldFgsIHk6IHRhcmdldFkgfSxcbiAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIGNlbnRlcjogeyB4OiBjZW50ZXJYLCB5OiBjZW50ZXJZIH0sXG4gICAgICAgIG9mZnNldCxcbiAgICB9KTtcbiAgICBjb25zdCBwYXRoID0gcG9pbnRzLnJlZHVjZSgocmVzLCBwLCBpKSA9PiB7XG4gICAgICAgIGxldCBzZWdtZW50ID0gJyc7XG4gICAgICAgIGlmIChpID4gMCAmJiBpIDwgcG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBnZXRCZW5kKHBvaW50c1tpIC0gMV0sIHAsIHBvaW50c1tpICsgMV0sIGJvcmRlclJhZGl1cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWdtZW50ID0gYCR7aSA9PT0gMCA/ICdNJyA6ICdMJ30ke3AueH0gJHtwLnl9YDtcbiAgICAgICAgfVxuICAgICAgICByZXMgKz0gc2VnbWVudDtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCAnJyk7XG4gICAgcmV0dXJuIFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV07XG59XG5cbmZ1bmN0aW9uIGlzTm9kZUluaXRpYWxpemVkKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUgJiZcbiAgICAgICAgISEobm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzIHx8IG5vZGUuaGFuZGxlcz8ubGVuZ3RoKSAmJlxuICAgICAgICAhIShub2RlLm1lYXN1cmVkLndpZHRoIHx8IG5vZGUud2lkdGggfHwgbm9kZS5pbml0aWFsV2lkdGgpKTtcbn1cbmZ1bmN0aW9uIGdldEVkZ2VQb3NpdGlvbihwYXJhbXMpIHtcbiAgICBjb25zdCB7IHNvdXJjZU5vZGUsIHRhcmdldE5vZGUgfSA9IHBhcmFtcztcbiAgICBpZiAoIWlzTm9kZUluaXRpYWxpemVkKHNvdXJjZU5vZGUpIHx8ICFpc05vZGVJbml0aWFsaXplZCh0YXJnZXROb2RlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlSGFuZGxlQm91bmRzID0gc291cmNlTm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzIHx8IHRvSGFuZGxlQm91bmRzKHNvdXJjZU5vZGUuaGFuZGxlcyk7XG4gICAgY29uc3QgdGFyZ2V0SGFuZGxlQm91bmRzID0gdGFyZ2V0Tm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzIHx8IHRvSGFuZGxlQm91bmRzKHRhcmdldE5vZGUuaGFuZGxlcyk7XG4gICAgY29uc3Qgc291cmNlSGFuZGxlID0gZ2V0SGFuZGxlJDEoc291cmNlSGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10sIHBhcmFtcy5zb3VyY2VIYW5kbGUpO1xuICAgIGNvbnN0IHRhcmdldEhhbmRsZSA9IGdldEhhbmRsZSQxKFxuICAgIC8vIHdoZW4gY29ubmVjdGlvbiB0eXBlIGlzIGxvb3NlIHdlIGNhbiBkZWZpbmUgYWxsIGhhbmRsZXMgYXMgc291cmNlcyBhbmQgY29ubmVjdCBzb3VyY2UgLT4gc291cmNlXG4gICAgcGFyYW1zLmNvbm5lY3Rpb25Nb2RlID09PSBDb25uZWN0aW9uTW9kZS5TdHJpY3RcbiAgICAgICAgPyB0YXJnZXRIYW5kbGVCb3VuZHM/LnRhcmdldCA/PyBbXVxuICAgICAgICA6ICh0YXJnZXRIYW5kbGVCb3VuZHM/LnRhcmdldCA/PyBbXSkuY29uY2F0KHRhcmdldEhhbmRsZUJvdW5kcz8uc291cmNlID8/IFtdKSwgcGFyYW1zLnRhcmdldEhhbmRsZSk7XG4gICAgaWYgKCFzb3VyY2VIYW5kbGUgfHwgIXRhcmdldEhhbmRsZSkge1xuICAgICAgICBwYXJhbXMub25FcnJvcj8uKCcwMDgnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwOCddKCFzb3VyY2VIYW5kbGUgPyAnc291cmNlJyA6ICd0YXJnZXQnLCB7XG4gICAgICAgICAgICBpZDogcGFyYW1zLmlkLFxuICAgICAgICAgICAgc291cmNlSGFuZGxlOiBwYXJhbXMuc291cmNlSGFuZGxlLFxuICAgICAgICAgICAgdGFyZ2V0SGFuZGxlOiBwYXJhbXMudGFyZ2V0SGFuZGxlLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IHNvdXJjZUhhbmRsZT8ucG9zaXRpb24gfHwgUG9zaXRpb24uQm90dG9tO1xuICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gdGFyZ2V0SGFuZGxlPy5wb3NpdGlvbiB8fCBQb3NpdGlvbi5Ub3A7XG4gICAgY29uc3Qgc291cmNlID0gZ2V0SGFuZGxlUG9zaXRpb24oc291cmNlTm9kZSwgc291cmNlSGFuZGxlLCBzb3VyY2VQb3NpdGlvbik7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0SGFuZGxlUG9zaXRpb24odGFyZ2V0Tm9kZSwgdGFyZ2V0SGFuZGxlLCB0YXJnZXRQb3NpdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlWDogc291cmNlLngsXG4gICAgICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICAgICAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAgICAgICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9IYW5kbGVCb3VuZHMoaGFuZGxlcykge1xuICAgIGlmICghaGFuZGxlcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gW107XG4gICAgY29uc3QgdGFyZ2V0ID0gW107XG4gICAgZm9yIChjb25zdCBoYW5kbGUgb2YgaGFuZGxlcykge1xuICAgICAgICBoYW5kbGUud2lkdGggPSBoYW5kbGUud2lkdGggPz8gMTtcbiAgICAgICAgaGFuZGxlLmhlaWdodCA9IGhhbmRsZS5oZWlnaHQgPz8gMTtcbiAgICAgICAgaWYgKGhhbmRsZS50eXBlID09PSAnc291cmNlJykge1xuICAgICAgICAgICAgc291cmNlLnB1c2goaGFuZGxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYW5kbGUudHlwZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICB0YXJnZXQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZVBvc2l0aW9uKG5vZGUsIGhhbmRsZSwgZmFsbGJhY2tQb3NpdGlvbiA9IFBvc2l0aW9uLkxlZnQsIGNlbnRlciA9IGZhbHNlKSB7XG4gICAgY29uc3QgeCA9IChoYW5kbGU/LnggPz8gMCkgKyBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLng7XG4gICAgY29uc3QgeSA9IChoYW5kbGU/LnkgPz8gMCkgKyBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnk7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBoYW5kbGUgPz8gZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSk7XG4gICAgaWYgKGNlbnRlcikge1xuICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGggLyAyLCB5OiB5ICsgaGVpZ2h0IC8gMiB9O1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbiA9IGhhbmRsZT8ucG9zaXRpb24gPz8gZmFsbGJhY2tQb3NpdGlvbjtcbiAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgUG9zaXRpb24uVG9wOlxuICAgICAgICAgICAgcmV0dXJuIHsgeDogeCArIHdpZHRoIC8gMiwgeSB9O1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgcmV0dXJuIHsgeDogeCArIHdpZHRoLCB5OiB5ICsgaGVpZ2h0IC8gMiB9O1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkJvdHRvbTpcbiAgICAgICAgICAgIHJldHVybiB7IHg6IHggKyB3aWR0aCAvIDIsIHk6IHkgKyBoZWlnaHQgfTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5MZWZ0OlxuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeTogeSArIGhlaWdodCAvIDIgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRIYW5kbGUkMShib3VuZHMsIGhhbmRsZUlkKSB7XG4gICAgaWYgKCFib3VuZHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIGlmIG5vIGhhbmRsZUlkIGlzIGdpdmVuLCB3ZSB1c2UgdGhlIGZpcnN0IGhhbmRsZSwgb3RoZXJ3aXNlIHdlIGNoZWNrIGZvciB0aGUgaWRcbiAgICByZXR1cm4gKCFoYW5kbGVJZCA/IGJvdW5kc1swXSA6IGJvdW5kcy5maW5kKChkKSA9PiBkLmlkID09PSBoYW5kbGVJZCkpIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldE1hcmtlcklkKG1hcmtlciwgaWQpIHtcbiAgICBpZiAoIW1hcmtlcikge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWFya2VyID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgIH1cbiAgICBjb25zdCBpZFByZWZpeCA9IGlkID8gYCR7aWR9X19gIDogJyc7XG4gICAgcmV0dXJuIGAke2lkUHJlZml4fSR7T2JqZWN0LmtleXMobWFya2VyKVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5tYXAoKGtleSkgPT4gYCR7a2V5fT0ke21hcmtlcltrZXldfWApXG4gICAgICAgIC5qb2luKCcmJyl9YDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1hcmtlcklkcyhlZGdlcywgeyBpZCwgZGVmYXVsdENvbG9yLCBkZWZhdWx0TWFya2VyU3RhcnQsIGRlZmF1bHRNYXJrZXJFbmQsIH0pIHtcbiAgICBjb25zdCBpZHMgPSBuZXcgU2V0KCk7XG4gICAgcmV0dXJuIGVkZ2VzXG4gICAgICAgIC5yZWR1Y2UoKG1hcmtlcnMsIGVkZ2UpID0+IHtcbiAgICAgICAgW2VkZ2UubWFya2VyU3RhcnQgfHwgZGVmYXVsdE1hcmtlclN0YXJ0LCBlZGdlLm1hcmtlckVuZCB8fCBkZWZhdWx0TWFya2VyRW5kXS5mb3JFYWNoKChtYXJrZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXJrZXIgJiYgdHlwZW9mIG1hcmtlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXJJZCA9IGdldE1hcmtlcklkKG1hcmtlciwgaWQpO1xuICAgICAgICAgICAgICAgIGlmICghaWRzLmhhcyhtYXJrZXJJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKHsgaWQ6IG1hcmtlcklkLCBjb2xvcjogbWFya2VyLmNvbG9yIHx8IGRlZmF1bHRDb2xvciwgLi4ubWFya2VyIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZHMuYWRkKG1hcmtlcklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWFya2VycztcbiAgICB9LCBbXSlcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuaWQubG9jYWxlQ29tcGFyZShiLmlkKSk7XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVUb29sYmFyVHJhbnNmb3JtKG5vZGVSZWN0LCB2aWV3cG9ydCwgcG9zaXRpb24sIG9mZnNldCwgYWxpZ24pIHtcbiAgICBsZXQgYWxpZ25tZW50T2Zmc2V0ID0gMC41O1xuICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBhbGlnbm1lbnRPZmZzZXQgPSAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgYWxpZ25tZW50T2Zmc2V0ID0gMTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBwb3NpdGlvbiA9PT0gUG9zaXRpb24uVG9wXG4gICAgICogd2Ugc2V0IHRoZSB4IGFueSB5IHBvc2l0aW9uIG9mIHRoZSB0b29sYmFyIGJhc2VkIG9uIHRoZSBub2RlcyBwb3NpdGlvblxuICAgICAqL1xuICAgIGxldCBwb3MgPSBbXG4gICAgICAgIChub2RlUmVjdC54ICsgbm9kZVJlY3Qud2lkdGggKiBhbGlnbm1lbnRPZmZzZXQpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LngsXG4gICAgICAgIG5vZGVSZWN0LnkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueSAtIG9mZnNldCxcbiAgICBdO1xuICAgIC8vIGFuZCB0aGFuIHNoaWZ0IGl0IGJhc2VkIG9uIHRoZSBhbGlnbm1lbnQuIFRoZSBzaGlmdCB2YWx1ZXMgYXJlIGluICUuXG4gICAgbGV0IHNoaWZ0ID0gWy0xMDAgKiBhbGlnbm1lbnRPZmZzZXQsIC0xMDBdO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5SaWdodDpcbiAgICAgICAgICAgIHBvcyA9IFtcbiAgICAgICAgICAgICAgICAobm9kZVJlY3QueCArIG5vZGVSZWN0LndpZHRoKSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC54ICsgb2Zmc2V0LFxuICAgICAgICAgICAgICAgIChub2RlUmVjdC55ICsgbm9kZVJlY3QuaGVpZ2h0ICogYWxpZ25tZW50T2Zmc2V0KSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC55LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHNoaWZ0ID0gWzAsIC0xMDAgKiBhbGlnbm1lbnRPZmZzZXRdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUG9zaXRpb24uQm90dG9tOlxuICAgICAgICAgICAgcG9zWzFdID0gKG5vZGVSZWN0LnkgKyBub2RlUmVjdC5oZWlnaHQpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnkgKyBvZmZzZXQ7XG4gICAgICAgICAgICBzaGlmdFsxXSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5MZWZ0OlxuICAgICAgICAgICAgcG9zID0gW1xuICAgICAgICAgICAgICAgIG5vZGVSZWN0LnggKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueCAtIG9mZnNldCxcbiAgICAgICAgICAgICAgICAobm9kZVJlY3QueSArIG5vZGVSZWN0LmhlaWdodCAqIGFsaWdubWVudE9mZnNldCkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBzaGlmdCA9IFstMTAwLCAtMTAwICogYWxpZ25tZW50T2Zmc2V0XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3Bvc1swXX1weCwgJHtwb3NbMV19cHgpIHRyYW5zbGF0ZSgke3NoaWZ0WzBdfSUsICR7c2hpZnRbMV19JSlgO1xufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBub2RlT3JpZ2luOiBbMCwgMF0sXG4gICAgbm9kZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IHRydWUsXG4gICAgZGVmYXVsdHM6IHt9LFxufTtcbmNvbnN0IGFkb3B0VXNlck5vZGVzRGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgY2hlY2tFcXVhbGl0eTogdHJ1ZSxcbn07XG5mdW5jdGlvbiBtZXJnZU9iamVjdHMoYmFzZSwgaW5jb21pbmcpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7IC4uLmJhc2UgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmNvbWluZykge1xuICAgICAgICBpZiAoaW5jb21pbmdba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB0eXBlY2FzdCBpcyBzYWZlIGhlcmUsIGJlY2F1c2Ugd2UgY2hlY2sgZm9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBpbmNvbWluZ1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1cGRhdGVBYnNvbHV0ZVBvc2l0aW9ucyhub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBfb3B0aW9ucyA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVMb29rdXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkTm9kZShub2RlLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIF9vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uV2l0aE9yaWdpbiA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4obm9kZSwgX29wdGlvbnMubm9kZU9yaWdpbik7XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBpc0Nvb3JkaW5hdGVFeHRlbnQobm9kZS5leHRlbnQpID8gbm9kZS5leHRlbnQgOiBfb3B0aW9ucy5ub2RlRXh0ZW50O1xuICAgICAgICAgICAgY29uc3QgY2xhbXBlZFBvc2l0aW9uID0gY2xhbXBQb3NpdGlvbihwb3NpdGlvbldpdGhPcmlnaW4sIGV4dGVudCwgZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSkpO1xuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSA9IGNsYW1wZWRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFkb3B0VXNlck5vZGVzKG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBfb3B0aW9ucyA9IG1lcmdlT2JqZWN0cyhhZG9wdFVzZXJOb2Rlc0RlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBsZXQgbm9kZXNJbml0aWFsaXplZCA9IG5vZGVzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgdG1wTG9va3VwID0gbmV3IE1hcChub2RlTG9va3VwKTtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVaID0gX29wdGlvbnM/LmVsZXZhdGVOb2Rlc09uU2VsZWN0ID8gMTAwMCA6IDA7XG4gICAgbm9kZUxvb2t1cC5jbGVhcigpO1xuICAgIHBhcmVudExvb2t1cC5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgdXNlck5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgbGV0IGludGVybmFsTm9kZSA9IHRtcExvb2t1cC5nZXQodXNlck5vZGUuaWQpO1xuICAgICAgICBpZiAoX29wdGlvbnMuY2hlY2tFcXVhbGl0eSAmJiB1c2VyTm9kZSA9PT0gaW50ZXJuYWxOb2RlPy5pbnRlcm5hbHMudXNlck5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVMb29rdXAuc2V0KHVzZXJOb2RlLmlkLCBpbnRlcm5hbE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25XaXRoT3JpZ2luID0gZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbih1c2VyTm9kZSwgX29wdGlvbnMubm9kZU9yaWdpbik7XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBpc0Nvb3JkaW5hdGVFeHRlbnQodXNlck5vZGUuZXh0ZW50KSA/IHVzZXJOb2RlLmV4dGVudCA6IF9vcHRpb25zLm5vZGVFeHRlbnQ7XG4gICAgICAgICAgICBjb25zdCBjbGFtcGVkUG9zaXRpb24gPSBjbGFtcFBvc2l0aW9uKHBvc2l0aW9uV2l0aE9yaWdpbiwgZXh0ZW50LCBnZXROb2RlRGltZW5zaW9ucyh1c2VyTm9kZSkpO1xuICAgICAgICAgICAgaW50ZXJuYWxOb2RlID0ge1xuICAgICAgICAgICAgICAgIC4uLl9vcHRpb25zLmRlZmF1bHRzLFxuICAgICAgICAgICAgICAgIC4uLnVzZXJOb2RlLFxuICAgICAgICAgICAgICAgIG1lYXN1cmVkOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB1c2VyTm9kZS5tZWFzdXJlZD8ud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdXNlck5vZGUubWVhc3VyZWQ/LmhlaWdodCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGludGVybmFsczoge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlOiBjbGFtcGVkUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHVzZXIgcmUtaW5pdGlhbGl6ZXMgdGhlIG5vZGUgb3IgcmVtb3ZlcyBgbWVhc3VyZWRgIGZvciB3aGF0ZXZlciByZWFzb24sIHdlIHJlc2V0IHRoZSBoYW5kbGVCb3VuZHMgc28gdGhhdCB0aGUgbm9kZSBnZXRzIHJlLW1lYXN1cmVkXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUJvdW5kczogIXVzZXJOb2RlLm1lYXN1cmVkID8gdW5kZWZpbmVkIDogaW50ZXJuYWxOb2RlPy5pbnRlcm5hbHMuaGFuZGxlQm91bmRzLFxuICAgICAgICAgICAgICAgICAgICB6OiBjYWxjdWxhdGVaKHVzZXJOb2RlLCBzZWxlY3RlZE5vZGVaKSxcbiAgICAgICAgICAgICAgICAgICAgdXNlck5vZGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBub2RlTG9va3VwLnNldCh1c2VyTm9kZS5pZCwgaW50ZXJuYWxOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGludGVybmFsTm9kZS5tZWFzdXJlZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBpbnRlcm5hbE5vZGUubWVhc3VyZWQud2lkdGggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgaW50ZXJuYWxOb2RlLm1lYXN1cmVkLmhlaWdodCA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgIWludGVybmFsTm9kZS5oaWRkZW4pIHtcbiAgICAgICAgICAgIG5vZGVzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlck5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkTm9kZShpbnRlcm5hbE5vZGUsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzSW5pdGlhbGl6ZWQ7XG59XG5mdW5jdGlvbiB1cGRhdGVQYXJlbnRMb29rdXAobm9kZSwgcGFyZW50TG9va3VwKSB7XG4gICAgaWYgKCFub2RlLnBhcmVudElkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHBhcmVudExvb2t1cC5nZXQobm9kZS5wYXJlbnRJZCk7XG4gICAgaWYgKGNoaWxkTm9kZXMpIHtcbiAgICAgICAgY2hpbGROb2Rlcy5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJlbnRMb29rdXAuc2V0KG5vZGUucGFyZW50SWQsIG5ldyBNYXAoW1tub2RlLmlkLCBub2RlXV0pKTtcbiAgICB9XG59XG4vKipcbiAqIFVwZGF0ZXMgcG9zaXRpb25BYnNvbHV0ZSBhbmQgekluZGV4IG9mIGEgY2hpbGQgbm9kZSBhbmQgdGhlIHBhcmVudExvb2t1cC5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlQ2hpbGROb2RlKG5vZGUsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgZWxldmF0ZU5vZGVzT25TZWxlY3QsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQgfSA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgcGFyZW50SWQgPSBub2RlLnBhcmVudElkO1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlTG9va3VwLmdldChwYXJlbnRJZCk7XG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgUGFyZW50IG5vZGUgJHtwYXJlbnRJZH0gbm90IGZvdW5kLiBQbGVhc2UgbWFrZSBzdXJlIHRoYXQgcGFyZW50IG5vZGVzIGFyZSBpbiBmcm9udCBvZiB0aGVpciBjaGlsZCBub2RlcyBpbiB0aGUgbm9kZXMgYXJyYXkuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlUGFyZW50TG9va3VwKG5vZGUsIHBhcmVudExvb2t1cCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlWiA9IGVsZXZhdGVOb2Rlc09uU2VsZWN0ID8gMTAwMCA6IDA7XG4gICAgY29uc3QgeyB4LCB5LCB6IH0gPSBjYWxjdWxhdGVDaGlsZFhZWihub2RlLCBwYXJlbnROb2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBzZWxlY3RlZE5vZGVaKTtcbiAgICBjb25zdCB7IHBvc2l0aW9uQWJzb2x1dGUgfSA9IG5vZGUuaW50ZXJuYWxzO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHggIT09IHBvc2l0aW9uQWJzb2x1dGUueCB8fCB5ICE9PSBwb3NpdGlvbkFic29sdXRlLnk7XG4gICAgaWYgKHBvc2l0aW9uQ2hhbmdlZCB8fCB6ICE9PSBub2RlLmludGVybmFscy56KSB7XG4gICAgICAgIC8vIHdlIGNyZWF0ZSBhIG5ldyBvYmplY3QgdG8gbWFyayB0aGUgbm9kZSBhcyB1cGRhdGVkXG4gICAgICAgIG5vZGVMb29rdXAuc2V0KG5vZGUuaWQsIHtcbiAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICBpbnRlcm5hbHM6IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLmludGVybmFscyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlOiBwb3NpdGlvbkNoYW5nZWQgPyB7IHgsIHkgfSA6IHBvc2l0aW9uQWJzb2x1dGUsXG4gICAgICAgICAgICAgICAgeixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVoobm9kZSwgc2VsZWN0ZWROb2RlWikge1xuICAgIHJldHVybiAoaXNOdW1lcmljKG5vZGUuekluZGV4KSA/IG5vZGUuekluZGV4IDogMCkgKyAobm9kZS5zZWxlY3RlZCA/IHNlbGVjdGVkTm9kZVogOiAwKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNoaWxkWFlaKGNoaWxkTm9kZSwgcGFyZW50Tm9kZSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgc2VsZWN0ZWROb2RlWikge1xuICAgIGNvbnN0IHsgeDogcGFyZW50WCwgeTogcGFyZW50WSB9ID0gcGFyZW50Tm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZTtcbiAgICBjb25zdCBjaGlsZERpbWVuc2lvbnMgPSBnZXROb2RlRGltZW5zaW9ucyhjaGlsZE5vZGUpO1xuICAgIGNvbnN0IHBvc2l0aW9uV2l0aE9yaWdpbiA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4oY2hpbGROb2RlLCBub2RlT3JpZ2luKTtcbiAgICBjb25zdCBjbGFtcGVkUG9zaXRpb24gPSBpc0Nvb3JkaW5hdGVFeHRlbnQoY2hpbGROb2RlLmV4dGVudClcbiAgICAgICAgPyBjbGFtcFBvc2l0aW9uKHBvc2l0aW9uV2l0aE9yaWdpbiwgY2hpbGROb2RlLmV4dGVudCwgY2hpbGREaW1lbnNpb25zKVxuICAgICAgICA6IHBvc2l0aW9uV2l0aE9yaWdpbjtcbiAgICBsZXQgYWJzb2x1dGVQb3NpdGlvbiA9IGNsYW1wUG9zaXRpb24oeyB4OiBwYXJlbnRYICsgY2xhbXBlZFBvc2l0aW9uLngsIHk6IHBhcmVudFkgKyBjbGFtcGVkUG9zaXRpb24ueSB9LCBub2RlRXh0ZW50LCBjaGlsZERpbWVuc2lvbnMpO1xuICAgIGlmIChjaGlsZE5vZGUuZXh0ZW50ID09PSAncGFyZW50Jykge1xuICAgICAgICBhYnNvbHV0ZVBvc2l0aW9uID0gY2xhbXBQb3NpdGlvblRvUGFyZW50KGFic29sdXRlUG9zaXRpb24sIGNoaWxkRGltZW5zaW9ucywgcGFyZW50Tm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkWiA9IGNhbGN1bGF0ZVooY2hpbGROb2RlLCBzZWxlY3RlZE5vZGVaKTtcbiAgICBjb25zdCBwYXJlbnRaID0gcGFyZW50Tm9kZS5pbnRlcm5hbHMueiA/PyAwO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGFic29sdXRlUG9zaXRpb24ueCxcbiAgICAgICAgeTogYWJzb2x1dGVQb3NpdGlvbi55LFxuICAgICAgICB6OiBwYXJlbnRaID4gY2hpbGRaID8gcGFyZW50WiA6IGNoaWxkWixcbiAgICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlRXhwYW5kUGFyZW50KGNoaWxkcmVuLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4gPSBbMCwgMF0pIHtcbiAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgY29uc3QgcGFyZW50RXhwYW5zaW9ucyA9IG5ldyBNYXAoKTtcbiAgICAvLyBkZXRlcm1pbmUgdGhlIGV4cGFuZGVkIHJlY3RhbmdsZSB0aGUgY2hpbGQgbm9kZXMgd291bGQgdGFrZSBmb3IgZWFjaCBwYXJlbnRcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGVMb29rdXAuZ2V0KGNoaWxkLnBhcmVudElkKTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudFJlY3QgPSBwYXJlbnRFeHBhbnNpb25zLmdldChjaGlsZC5wYXJlbnRJZCk/LmV4cGFuZGVkUmVjdCA/PyBub2RlVG9SZWN0KHBhcmVudCk7XG4gICAgICAgIGNvbnN0IGV4cGFuZGVkUmVjdCA9IGdldEJvdW5kc09mUmVjdHMocGFyZW50UmVjdCwgY2hpbGQucmVjdCk7XG4gICAgICAgIHBhcmVudEV4cGFuc2lvbnMuc2V0KGNoaWxkLnBhcmVudElkLCB7IGV4cGFuZGVkUmVjdCwgcGFyZW50IH0pO1xuICAgIH1cbiAgICBpZiAocGFyZW50RXhwYW5zaW9ucy5zaXplID4gMCkge1xuICAgICAgICBwYXJlbnRFeHBhbnNpb25zLmZvckVhY2goKHsgZXhwYW5kZWRSZWN0LCBwYXJlbnQgfSwgcGFyZW50SWQpID0+IHtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgcG9zaXRpb24gJiBkaW1lbnNpb25zIG9mIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uQWJzb2x1dGUgPSBwYXJlbnQuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb25zID0gZ2V0Tm9kZURpbWVuc2lvbnMocGFyZW50KTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IHBhcmVudC5vcmlnaW4gPz8gbm9kZU9yaWdpbjtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSBob3cgbXVjaCB0aGUgcGFyZW50IGV4cGFuZHMgaW4gd2lkdGggYW5kIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCB4Q2hhbmdlID0gZXhwYW5kZWRSZWN0LnggPCBwb3NpdGlvbkFic29sdXRlLnggPyBNYXRoLnJvdW5kKE1hdGguYWJzKHBvc2l0aW9uQWJzb2x1dGUueCAtIGV4cGFuZGVkUmVjdC54KSkgOiAwO1xuICAgICAgICAgICAgY29uc3QgeUNoYW5nZSA9IGV4cGFuZGVkUmVjdC55IDwgcG9zaXRpb25BYnNvbHV0ZS55ID8gTWF0aC5yb3VuZChNYXRoLmFicyhwb3NpdGlvbkFic29sdXRlLnkgLSBleHBhbmRlZFJlY3QueSkpIDogMDtcbiAgICAgICAgICAgIGNvbnN0IG5ld1dpZHRoID0gTWF0aC5tYXgoZGltZW5zaW9ucy53aWR0aCwgTWF0aC5yb3VuZChleHBhbmRlZFJlY3Qud2lkdGgpKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWF4KGRpbWVuc2lvbnMuaGVpZ2h0LCBNYXRoLnJvdW5kKGV4cGFuZGVkUmVjdC5oZWlnaHQpKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoQ2hhbmdlID0gKG5ld1dpZHRoIC0gZGltZW5zaW9ucy53aWR0aCkgKiBvcmlnaW5bMF07XG4gICAgICAgICAgICBjb25zdCBoZWlnaHRDaGFuZ2UgPSAobmV3SGVpZ2h0IC0gZGltZW5zaW9ucy5oZWlnaHQpICogb3JpZ2luWzFdO1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjb3JyZWN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgcGFyZW50IG5vZGUgaWYgdGhlIG9yaWdpbiBpcyBub3QgWzAsMF1cbiAgICAgICAgICAgIGlmICh4Q2hhbmdlID4gMCB8fCB5Q2hhbmdlID4gMCB8fCB3aWR0aENoYW5nZSB8fCBoZWlnaHRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogcGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBwYXJlbnQucG9zaXRpb24ueCAtIHhDaGFuZ2UgKyB3aWR0aENoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHBhcmVudC5wb3NpdGlvbi55IC0geUNoYW5nZSArIGhlaWdodENoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFdlIG1vdmUgYWxsIGNoaWxkIG5vZGVzIGluIHRoZSBvcHBzaXRlIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgICAqIHNvIHRoZSB4LHkgY2hhbmdlcyBvZiB0aGUgcGFyZW50IGRvIG5vdCBtb3ZlIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHBhcmVudExvb2t1cC5nZXQocGFyZW50SWQpPy5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZHJlbi5zb21lKChjaGlsZCkgPT4gY2hpbGQuaWQgPT09IGNoaWxkTm9kZS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNoaWxkTm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNoaWxkTm9kZS5wb3NpdGlvbi54ICsgeENoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY2hpbGROb2RlLnBvc2l0aW9uLnkgKyB5Q2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjb3JyZWN0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBwYXJlbnQgbm9kZSBpZiB0aGUgb3JpZ2luIGlzIG5vdCBbMCwwXVxuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMud2lkdGggPCBleHBhbmRlZFJlY3Qud2lkdGggfHwgZGltZW5zaW9ucy5oZWlnaHQgPCBleHBhbmRlZFJlY3QuaGVpZ2h0IHx8IHhDaGFuZ2UgfHwgeUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RpbWVuc2lvbnMnLFxuICAgICAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbmV3V2lkdGggKyAoeENoYW5nZSA/IG9yaWdpblswXSAqIHhDaGFuZ2UgLSB3aWR0aENoYW5nZSA6IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdIZWlnaHQgKyAoeUNoYW5nZSA/IG9yaWdpblsxXSAqIHlDaGFuZ2UgLSBoZWlnaHRDaGFuZ2UgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VzO1xufVxuZnVuY3Rpb24gdXBkYXRlTm9kZUludGVybmFscyh1cGRhdGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIGRvbU5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQpIHtcbiAgICBjb25zdCB2aWV3cG9ydE5vZGUgPSBkb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcueHlmbG93X192aWV3cG9ydCcpO1xuICAgIGxldCB1cGRhdGVkSW50ZXJuYWxzID0gZmFsc2U7XG4gICAgaWYgKCF2aWV3cG9ydE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogW10sIHVwZGF0ZWRJbnRlcm5hbHMgfTtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodmlld3BvcnROb2RlKTtcbiAgICBjb25zdCB7IG0yMjogem9vbSB9ID0gbmV3IHdpbmRvdy5ET01NYXRyaXhSZWFkT25seShzdHlsZS50cmFuc2Zvcm0pO1xuICAgIC8vIGluIHRoaXMgYXJyYXkgd2UgY29sbGVjdCBub2RlcywgdGhhdCBtaWdodCB0cmlnZ2VyIGNoYW5nZXMgKGxpa2UgZXhwYW5kaW5nIHBhcmVudClcbiAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGlsZHJlbiA9IFtdO1xuICAgIGZvciAoY29uc3QgdXBkYXRlIG9mIHVwZGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KHVwZGF0ZS5pZCk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaGlkZGVuKSB7XG4gICAgICAgICAgICBub2RlTG9va3VwLnNldChub2RlLmlkLCB7XG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubm9kZS5pbnRlcm5hbHMsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUJvdW5kczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVwZGF0ZWRJbnRlcm5hbHMgPSB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IGdldERpbWVuc2lvbnModXBkYXRlLm5vZGVFbGVtZW50KTtcbiAgICAgICAgY29uc3QgZGltZW5zaW9uQ2hhbmdlZCA9IG5vZGUubWVhc3VyZWQud2lkdGggIT09IGRpbWVuc2lvbnMud2lkdGggfHwgbm9kZS5tZWFzdXJlZC5oZWlnaHQgIT09IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBkb1VwZGF0ZSA9ICEhKGRpbWVuc2lvbnMud2lkdGggJiZcbiAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ICYmXG4gICAgICAgICAgICAoZGltZW5zaW9uQ2hhbmdlZCB8fCAhbm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzIHx8IHVwZGF0ZS5mb3JjZSkpO1xuICAgICAgICBpZiAoZG9VcGRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVCb3VuZHMgPSB1cGRhdGUubm9kZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBpc0Nvb3JkaW5hdGVFeHRlbnQobm9kZS5leHRlbnQpID8gbm9kZS5leHRlbnQgOiBub2RlRXh0ZW50O1xuICAgICAgICAgICAgbGV0IHsgcG9zaXRpb25BYnNvbHV0ZSB9ID0gbm9kZS5pbnRlcm5hbHM7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCAmJiBub2RlLmV4dGVudCA9PT0gJ3BhcmVudCcpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlID0gY2xhbXBQb3NpdGlvblRvUGFyZW50KHBvc2l0aW9uQWJzb2x1dGUsIGRpbWVuc2lvbnMsIG5vZGVMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4dGVudCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGUgPSBjbGFtcFBvc2l0aW9uKHBvc2l0aW9uQWJzb2x1dGUsIGV4dGVudCwgZGltZW5zaW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdOb2RlID0ge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgbWVhc3VyZWQ6IGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm5vZGUuaW50ZXJuYWxzLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVCb3VuZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZ2V0SGFuZGxlQm91bmRzKCdzb3VyY2UnLCB1cGRhdGUubm9kZUVsZW1lbnQsIG5vZGVCb3VuZHMsIHpvb20sIG5vZGUuaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBnZXRIYW5kbGVCb3VuZHMoJ3RhcmdldCcsIHVwZGF0ZS5ub2RlRWxlbWVudCwgbm9kZUJvdW5kcywgem9vbSwgbm9kZS5pZCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBub2RlTG9va3VwLnNldChub2RlLmlkLCBuZXdOb2RlKTtcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ2hpbGROb2RlKG5ld05vZGUsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgeyBub2RlT3JpZ2luIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlZEludGVybmFscyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZXhwYW5kUGFyZW50ICYmIG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RXhwYW5kQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBub2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdDogbm9kZVRvUmVjdChuZXdOb2RlLCBub2RlT3JpZ2luKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJlbnRFeHBhbmRDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoYW5nZXMgPSBoYW5kbGVFeHBhbmRQYXJlbnQocGFyZW50RXhwYW5kQ2hpbGRyZW4sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbik7XG4gICAgICAgIGNoYW5nZXMucHVzaCguLi5wYXJlbnRFeHBhbmRDaGFuZ2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2hhbmdlcywgdXBkYXRlZEludGVybmFscyB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcGFuQnkoeyBkZWx0YSwgcGFuWm9vbSwgdHJhbnNmb3JtLCB0cmFuc2xhdGVFeHRlbnQsIHdpZHRoLCBoZWlnaHQsIH0pIHtcbiAgICBpZiAoIXBhblpvb20gfHwgKCFkZWx0YS54ICYmICFkZWx0YS55KSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgY29uc3QgbmV4dFZpZXdwb3J0ID0gYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydENvbnN0cmFpbmVkKHtcbiAgICAgICAgeDogdHJhbnNmb3JtWzBdICsgZGVsdGEueCxcbiAgICAgICAgeTogdHJhbnNmb3JtWzFdICsgZGVsdGEueSxcbiAgICAgICAgem9vbTogdHJhbnNmb3JtWzJdLFxuICAgIH0sIFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbd2lkdGgsIGhlaWdodF0sXG4gICAgXSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICBjb25zdCB0cmFuc2Zvcm1DaGFuZ2VkID0gISFuZXh0Vmlld3BvcnQgJiZcbiAgICAgICAgKG5leHRWaWV3cG9ydC54ICE9PSB0cmFuc2Zvcm1bMF0gfHwgbmV4dFZpZXdwb3J0LnkgIT09IHRyYW5zZm9ybVsxXSB8fCBuZXh0Vmlld3BvcnQuayAhPT0gdHJhbnNmb3JtWzJdKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRyYW5zZm9ybUNoYW5nZWQpO1xufVxuLyoqXG4gKiB0aGlzIGZ1bmN0aW9uIGFkZHMgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIGNvbm5lY3Rpb25Mb29rdXBcbiAqIGF0IHRoZSBmb2xsb3dpbmcga2V5czogbm9kZUlkLXR5cGUtaGFuZGxlSWQsIG5vZGVJZC10eXBlIGFuZCBub2RlSWRcbiAqIEBwYXJhbSB0eXBlIHR5cGUgb2YgdGhlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBjb25uZWN0aW9uIGNvbm5lY3Rpb24gdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGxvb2t1cFxuICogQHBhcmFtIGNvbm5lY3Rpb25LZXkgYXQgd2hpY2gga2V5IHRoZSBjb25uZWN0aW9uIHNob3VsZCBiZSBhZGRlZFxuICogQHBhcmFtIGNvbm5lY3Rpb25Mb29rdXAgcmVmZXJlbmNlIHRvIHRoZSBjb25uZWN0aW9uIGxvb2t1cFxuICogQHBhcmFtIG5vZGVJZCBub2RlSWQgb2YgdGhlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBoYW5kbGVJZCBoYW5kbGVJZCBvZiB0aGUgY29ubmVjaXRvblxuICovXG5mdW5jdGlvbiBhZGRDb25uZWN0aW9uVG9Mb29rdXAodHlwZSwgY29ubmVjdGlvbiwgY29ubmVjdGlvbktleSwgY29ubmVjdGlvbkxvb2t1cCwgbm9kZUlkLCBoYW5kbGVJZCkge1xuICAgIC8qXG4gICAgICogV2UgYWRkIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBjb25uZWN0aW9uTG9va3VwIGF0IHRoZSBmb2xsb3dpbmcga2V5c1xuICAgICAqIDEuIG5vZGVJZCwgMi4gbm9kZUlkLXR5cGUsIDMuIG5vZGVJZC10eXBlLWhhbmRsZUlkXG4gICAgICogSWYgdGhlIGtleSBhbHJlYWR5IGV4aXN0cywgd2UgYWRkIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBleGlzdGluZyBtYXBcbiAgICAgKi9cbiAgICBsZXQga2V5ID0gbm9kZUlkO1xuICAgIGNvbnN0IG5vZGVNYXAgPSBjb25uZWN0aW9uTG9va3VwLmdldChrZXkpIHx8IG5ldyBNYXAoKTtcbiAgICBjb25uZWN0aW9uTG9va3VwLnNldChrZXksIG5vZGVNYXAuc2V0KGNvbm5lY3Rpb25LZXksIGNvbm5lY3Rpb24pKTtcbiAgICBrZXkgPSBgJHtub2RlSWR9LSR7dHlwZX1gO1xuICAgIGNvbnN0IHR5cGVNYXAgPSBjb25uZWN0aW9uTG9va3VwLmdldChrZXkpIHx8IG5ldyBNYXAoKTtcbiAgICBjb25uZWN0aW9uTG9va3VwLnNldChrZXksIHR5cGVNYXAuc2V0KGNvbm5lY3Rpb25LZXksIGNvbm5lY3Rpb24pKTtcbiAgICBpZiAoaGFuZGxlSWQpIHtcbiAgICAgICAga2V5ID0gYCR7bm9kZUlkfS0ke3R5cGV9LSR7aGFuZGxlSWR9YDtcbiAgICAgICAgY29uc3QgaGFuZGxlTWFwID0gY29ubmVjdGlvbkxvb2t1cC5nZXQoa2V5KSB8fCBuZXcgTWFwKCk7XG4gICAgICAgIGNvbm5lY3Rpb25Mb29rdXAuc2V0KGtleSwgaGFuZGxlTWFwLnNldChjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQ29ubmVjdGlvbkxvb2t1cChjb25uZWN0aW9uTG9va3VwLCBlZGdlTG9va3VwLCBlZGdlcykge1xuICAgIGNvbm5lY3Rpb25Mb29rdXAuY2xlYXIoKTtcbiAgICBlZGdlTG9va3VwLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGVkZ2VzKSB7XG4gICAgICAgIGNvbnN0IHsgc291cmNlOiBzb3VyY2VOb2RlLCB0YXJnZXQ6IHRhcmdldE5vZGUsIHNvdXJjZUhhbmRsZSA9IG51bGwsIHRhcmdldEhhbmRsZSA9IG51bGwgfSA9IGVkZ2U7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB7IGVkZ2VJZDogZWRnZS5pZCwgc291cmNlOiBzb3VyY2VOb2RlLCB0YXJnZXQ6IHRhcmdldE5vZGUsIHNvdXJjZUhhbmRsZSwgdGFyZ2V0SGFuZGxlIH07XG4gICAgICAgIGNvbnN0IHNvdXJjZUtleSA9IGAke3NvdXJjZU5vZGV9LSR7c291cmNlSGFuZGxlfS0tJHt0YXJnZXROb2RlfS0ke3RhcmdldEhhbmRsZX1gO1xuICAgICAgICBjb25zdCB0YXJnZXRLZXkgPSBgJHt0YXJnZXROb2RlfS0ke3RhcmdldEhhbmRsZX0tLSR7c291cmNlTm9kZX0tJHtzb3VyY2VIYW5kbGV9YDtcbiAgICAgICAgYWRkQ29ubmVjdGlvblRvTG9va3VwKCdzb3VyY2UnLCBjb25uZWN0aW9uLCB0YXJnZXRLZXksIGNvbm5lY3Rpb25Mb29rdXAsIHNvdXJjZU5vZGUsIHNvdXJjZUhhbmRsZSk7XG4gICAgICAgIGFkZENvbm5lY3Rpb25Ub0xvb2t1cCgndGFyZ2V0JywgY29ubmVjdGlvbiwgc291cmNlS2V5LCBjb25uZWN0aW9uTG9va3VwLCB0YXJnZXROb2RlLCB0YXJnZXRIYW5kbGUpO1xuICAgICAgICBlZGdlTG9va3VwLnNldChlZGdlLmlkLCBlZGdlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dOb2RlRGF0YShhLCBiKSB7XG4gICAgaWYgKGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IF9hID0gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbYV07XG4gICAgY29uc3QgX2IgPSBBcnJheS5pc0FycmF5KGIpID8gYiA6IFtiXTtcbiAgICBpZiAoX2EubGVuZ3RoICE9PSBfYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9hLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChfYVtpXS5pZCAhPT0gX2JbaV0uaWQgfHwgX2FbaV0udHlwZSAhPT0gX2JbaV0udHlwZSB8fCAhT2JqZWN0LmlzKF9hW2ldLmRhdGEsIF9iW2ldLmRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzUGFyZW50U2VsZWN0ZWQobm9kZSwgbm9kZUxvb2t1cCkge1xuICAgIGlmICghbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlTG9va3VwLmdldChub2RlLnBhcmVudElkKTtcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGFyZW50Tm9kZS5zZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzUGFyZW50U2VsZWN0ZWQocGFyZW50Tm9kZSwgbm9kZUxvb2t1cCk7XG59XG5mdW5jdGlvbiBoYXNTZWxlY3Rvcih0YXJnZXQsIHNlbGVjdG9yLCBkb21Ob2RlKSB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAoY3VycmVudD8ubWF0Y2hlcz8uKHNlbGVjdG9yKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gZG9tTm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQ/LnBhcmVudEVsZW1lbnQ7XG4gICAgfSB3aGlsZSAoY3VycmVudCk7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gbG9va3MgZm9yIGFsbCBzZWxlY3RlZCBub2RlcyBhbmQgY3JlYXRlZCBhIE5vZGVEcmFnSXRlbSBmb3IgZWFjaCBvZiB0aGVtXG5mdW5jdGlvbiBnZXREcmFnSXRlbXMobm9kZUxvb2t1cCwgbm9kZXNEcmFnZ2FibGUsIG1vdXNlUG9zLCBub2RlSWQpIHtcbiAgICBjb25zdCBkcmFnSXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbaWQsIG5vZGVdIG9mIG5vZGVMb29rdXApIHtcbiAgICAgICAgaWYgKChub2RlLnNlbGVjdGVkIHx8IG5vZGUuaWQgPT09IG5vZGVJZCkgJiZcbiAgICAgICAgICAgICghbm9kZS5wYXJlbnRJZCB8fCAhaXNQYXJlbnRTZWxlY3RlZChub2RlLCBub2RlTG9va3VwKSkgJiZcbiAgICAgICAgICAgIChub2RlLmRyYWdnYWJsZSB8fCAobm9kZXNEcmFnZ2FibGUgJiYgdHlwZW9mIG5vZGUuZHJhZ2dhYmxlID09PSAndW5kZWZpbmVkJykpKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGUgPSBub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxOb2RlKSB7XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLnNldChpZCwge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGludGVybmFsTm9kZS5wb3NpdGlvbiB8fCB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IG1vdXNlUG9zLnggLSBpbnRlcm5hbE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IG1vdXNlUG9zLnkgLSBpbnRlcm5hbE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50OiBpbnRlcm5hbE5vZGUuZXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogaW50ZXJuYWxOb2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGludGVybmFsTm9kZS5vcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZFBhcmVudDogaW50ZXJuYWxOb2RlLmV4cGFuZFBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlOiBpbnRlcm5hbE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgfHwgeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lYXN1cmVkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogaW50ZXJuYWxOb2RlLm1lYXN1cmVkLndpZHRoID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGludGVybmFsTm9kZS5tZWFzdXJlZC5oZWlnaHQgPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZHJhZ0l0ZW1zO1xufVxuLypcbiAqIHJldHVybnMgdHdvIHBhcmFtczpcbiAqIDEuIHRoZSBkcmFnZ2VkIG5vZGUgKG9yIHRoZSBmaXJzdCBvZiB0aGUgbGlzdCwgaWYgd2UgYXJlIGRyYWdnaW5nIGEgbm9kZSBzZWxlY3Rpb24pXG4gKiAyLiBhcnJheSBvZiBzZWxlY3RlZCBub2RlcyAoZm9yIG11bHRpIHNlbGVjdGlvbnMpXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50SGFuZGxlclBhcmFtcyh7IG5vZGVJZCwgZHJhZ0l0ZW1zLCBub2RlTG9va3VwLCBkcmFnZ2luZyA9IHRydWUsIH0pIHtcbiAgICBjb25zdCBub2Rlc0Zyb21EcmFnSXRlbXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZHJhZ0l0ZW1dIG9mIGRyYWdJdGVtcykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpPy5pbnRlcm5hbHMudXNlck5vZGU7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBub2Rlc0Zyb21EcmFnSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogZHJhZ0l0ZW0ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICByZXR1cm4gW25vZGVzRnJvbURyYWdJdGVtc1swXSwgbm9kZXNGcm9tRHJhZ0l0ZW1zXTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk/LmludGVybmFscy51c2VyTm9kZTtcbiAgICByZXR1cm4gW1xuICAgICAgICAhbm9kZVxuICAgICAgICAgICAgPyBub2Rlc0Zyb21EcmFnSXRlbXNbMF1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGRyYWdJdGVtcy5nZXQobm9kZUlkKT8ucG9zaXRpb24gfHwgbm9kZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIG5vZGVzRnJvbURyYWdJdGVtcyxcbiAgICBdO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gWFlEcmFnKHsgb25Ob2RlTW91c2VEb3duLCBnZXRTdG9yZUl0ZW1zLCBvbkRyYWdTdGFydCwgb25EcmFnLCBvbkRyYWdTdG9wLCB9KSB7XG4gICAgbGV0IGxhc3RQb3MgPSB7IHg6IG51bGwsIHk6IG51bGwgfTtcbiAgICBsZXQgYXV0b1BhbklkID0gMDtcbiAgICBsZXQgZHJhZ0l0ZW1zID0gbmV3IE1hcCgpO1xuICAgIGxldCBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBtb3VzZVBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gICAgbGV0IGNvbnRhaW5lckJvdW5kcyA9IG51bGw7XG4gICAgbGV0IGRyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IGQzU2VsZWN0aW9uID0gbnVsbDtcbiAgICBsZXQgYWJvcnREcmFnID0gZmFsc2U7IC8vIHByZXZlbnRzIHVuaW50ZW50aW9uYWwgZHJhZ2dpbmcgb24gbXVsdGl0b3VjaFxuICAgIC8vIHB1YmxpYyBmdW5jdGlvbnNcbiAgICBmdW5jdGlvbiB1cGRhdGUoeyBub0RyYWdDbGFzc05hbWUsIGhhbmRsZVNlbGVjdG9yLCBkb21Ob2RlLCBpc1NlbGVjdGFibGUsIG5vZGVJZCwgbm9kZUNsaWNrRGlzdGFuY2UgPSAwLCB9KSB7XG4gICAgICAgIGQzU2VsZWN0aW9uID0gc2VsZWN0KGRvbU5vZGUpO1xuICAgICAgICBmdW5jdGlvbiB1cGRhdGVOb2Rlcyh7IHgsIHkgfSwgZHJhZ0V2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIG5vZGVFeHRlbnQsIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlT3JpZ2luLCBvbk5vZGVEcmFnLCBvblNlbGVjdGlvbkRyYWcsIG9uRXJyb3IsIHVwZGF0ZU5vZGVQb3NpdGlvbnMsIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBsYXN0UG9zID0geyB4LCB5IH07XG4gICAgICAgICAgICBsZXQgaGFzQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbm9kZXNCb3ggPSB7IHg6IDAsIHk6IDAsIHgyOiAwLCB5MjogMCB9O1xuICAgICAgICAgICAgaWYgKGRyYWdJdGVtcy5zaXplID4gMSAmJiBub2RlRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IGdldEludGVybmFsTm9kZXNCb3VuZHMoZHJhZ0l0ZW1zKTtcbiAgICAgICAgICAgICAgICBub2Rlc0JveCA9IHJlY3RUb0JveChyZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgW2lkLCBkcmFnSXRlbV0gb2YgZHJhZ0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlTG9va3VwLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogaWYgdGhlIG5vZGUgaXMgbm90IGluIHRoZSBub2RlTG9va3VwIGFueW1vcmUsIGl0IHdhcyBwcm9iYWJseSBkZWxldGVkIHdoaWxlIGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgICAgICAqIGFuZCB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSBpdCBhbnltb3JlXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG5leHRQb3NpdGlvbiA9IHsgeDogeCAtIGRyYWdJdGVtLmRpc3RhbmNlLngsIHk6IHkgLSBkcmFnSXRlbS5kaXN0YW5jZS55IH07XG4gICAgICAgICAgICAgICAgaWYgKHNuYXBUb0dyaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uID0gc25hcFBvc2l0aW9uKG5leHRQb3NpdGlvbiwgc25hcEdyaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGlmIHRoZXJlIGlzIHNlbGVjdGlvbiB3aXRoIG11bHRpcGxlIG5vZGVzIGFuZCBhIG5vZGUgZXh0ZW50IGlzIHNldCwgd2UgbmVlZCB0byBhZGp1c3QgdGhlIG5vZGUgZXh0ZW50IGZvciBlYWNoIG5vZGVcbiAgICAgICAgICAgICAgICAgKiBiYXNlZCBvbiBpdHMgcG9zaXRpb24gc28gdGhhdCB0aGUgbm9kZSBzdGF5cyBhdCBpdCdzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbGV0IGFkanVzdGVkTm9kZUV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgW25vZGVFeHRlbnRbMF1bMF0sIG5vZGVFeHRlbnRbMF1bMV1dLFxuICAgICAgICAgICAgICAgICAgICBbbm9kZUV4dGVudFsxXVswXSwgbm9kZUV4dGVudFsxXVsxXV0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0l0ZW1zLnNpemUgPiAxICYmIG5vZGVFeHRlbnQgJiYgIWRyYWdJdGVtLmV4dGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uQWJzb2x1dGUgfSA9IGRyYWdJdGVtLmludGVybmFscztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeDEgPSBwb3NpdGlvbkFic29sdXRlLnggLSBub2Rlc0JveC54ICsgbm9kZUV4dGVudFswXVswXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeDIgPSBwb3NpdGlvbkFic29sdXRlLnggKyBkcmFnSXRlbS5tZWFzdXJlZC53aWR0aCAtIG5vZGVzQm94LngyICsgbm9kZUV4dGVudFsxXVswXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeTEgPSBwb3NpdGlvbkFic29sdXRlLnkgLSBub2Rlc0JveC55ICsgbm9kZUV4dGVudFswXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeTIgPSBwb3NpdGlvbkFic29sdXRlLnkgKyBkcmFnSXRlbS5tZWFzdXJlZC5oZWlnaHQgLSBub2Rlc0JveC55MiArIG5vZGVFeHRlbnRbMV1bMV07XG4gICAgICAgICAgICAgICAgICAgIGFkanVzdGVkTm9kZUV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4MSwgeTFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3gyLCB5Ml0sXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9zaXRpb24sIHBvc2l0aW9uQWJzb2x1dGUgfSA9IGNhbGN1bGF0ZU5vZGVQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUV4dGVudDogYWRqdXN0ZWROb2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgd2Ugb25seSBmaXJlIGEgY2hhbmdlIGV2ZW50IHdoZW4gdGhlcmUgaXMgYSBjaGFuZ2VcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2UgPSBoYXNDaGFuZ2UgfHwgZHJhZ0l0ZW0ucG9zaXRpb24ueCAhPT0gcG9zaXRpb24ueCB8fCBkcmFnSXRlbS5wb3NpdGlvbi55ICE9PSBwb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgIGRyYWdJdGVtLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW0uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgPSBwb3NpdGlvbkFic29sdXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVOb2RlUG9zaXRpb25zKGRyYWdJdGVtcywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZHJhZ0V2ZW50ICYmIChvbkRyYWcgfHwgb25Ob2RlRHJhZyB8fCAoIW5vZGVJZCAmJiBvblNlbGVjdGlvbkRyYWcpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzXSA9IGdldEV2ZW50SGFuZGxlclBhcmFtcyh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9uRHJhZz8uKGRyYWdFdmVudCwgZHJhZ0l0ZW1zLCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICBvbk5vZGVEcmFnPy4oZHJhZ0V2ZW50LCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGlvbkRyYWc/LihkcmFnRXZlbnQsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGF1dG9QYW4oKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lckJvdW5kcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBwYW5CeSwgYXV0b1BhblNwZWVkLCBhdXRvUGFuT25Ob2RlRHJhZyB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgaWYgKCFhdXRvUGFuT25Ob2RlRHJhZykge1xuICAgICAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYXV0b1BhbklkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbeE1vdmVtZW50LCB5TW92ZW1lbnRdID0gY2FsY0F1dG9QYW4obW91c2VQb3NpdGlvbiwgY29udGFpbmVyQm91bmRzLCBhdXRvUGFuU3BlZWQpO1xuICAgICAgICAgICAgaWYgKHhNb3ZlbWVudCAhPT0gMCB8fCB5TW92ZW1lbnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0UG9zLnggPSAobGFzdFBvcy54ID8/IDApIC0geE1vdmVtZW50IC8gdHJhbnNmb3JtWzJdO1xuICAgICAgICAgICAgICAgIGxhc3RQb3MueSA9IChsYXN0UG9zLnkgPz8gMCkgLSB5TW92ZW1lbnQgLyB0cmFuc2Zvcm1bMl07XG4gICAgICAgICAgICAgICAgaWYgKGF3YWl0IHBhbkJ5KHsgeDogeE1vdmVtZW50LCB5OiB5TW92ZW1lbnQgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlTm9kZXMobGFzdFBvcywgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXV0b1BhbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGF1dG9QYW4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0RHJhZyhldmVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBtdWx0aVNlbGVjdGlvbkFjdGl2ZSwgbm9kZXNEcmFnZ2FibGUsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIHNlbGVjdE5vZGVzT25EcmFnLCBvbk5vZGVEcmFnU3RhcnQsIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0LCB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBkcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoKCFzZWxlY3ROb2Rlc09uRHJhZyB8fCAhaXNTZWxlY3RhYmxlKSAmJiAhbXVsdGlTZWxlY3Rpb25BY3RpdmUgJiYgbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlTG9va3VwLmdldChub2RlSWQpPy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlc2V0IHNlbGVjdGVkIG5vZGVzIHdoZW4gc2VsZWN0Tm9kZXNPbkRyYWc9ZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU2VsZWN0YWJsZSAmJiBzZWxlY3ROb2Rlc09uRHJhZyAmJiBub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBvbk5vZGVNb3VzZURvd24/Lihub2RlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9pbnRlclBvcyA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBjb250YWluZXJCb3VuZHMgfSk7XG4gICAgICAgICAgICBsYXN0UG9zID0gcG9pbnRlclBvcztcbiAgICAgICAgICAgIGRyYWdJdGVtcyA9IGdldERyYWdJdGVtcyhub2RlTG9va3VwLCBub2Rlc0RyYWdnYWJsZSwgcG9pbnRlclBvcywgbm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChkcmFnSXRlbXMuc2l6ZSA+IDAgJiYgKG9uRHJhZ1N0YXJ0IHx8IG9uTm9kZURyYWdTdGFydCB8fCAoIW5vZGVJZCAmJiBvblNlbGVjdGlvbkRyYWdTdGFydCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2N1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXNdID0gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgICAgICBkcmFnSXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb25EcmFnU3RhcnQ/LihldmVudC5zb3VyY2VFdmVudCwgZHJhZ0l0ZW1zLCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICBvbk5vZGVEcmFnU3RhcnQ/LihldmVudC5zb3VyY2VFdmVudCwgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Rpb25EcmFnU3RhcnQ/LihldmVudC5zb3VyY2VFdmVudCwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZDNEcmFnSW5zdGFuY2UgPSBkcmFnKClcbiAgICAgICAgICAgIC5jbGlja0Rpc3RhbmNlKG5vZGVDbGlja0Rpc3RhbmNlKVxuICAgICAgICAgICAgLm9uKCdzdGFydCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkb21Ob2RlLCBub2RlRHJhZ1RocmVzaG9sZCwgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgY29udGFpbmVyQm91bmRzID0gZG9tTm9kZT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfHwgbnVsbDtcbiAgICAgICAgICAgIGFib3J0RHJhZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5vZGVEcmFnVGhyZXNob2xkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnREcmFnKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgY29udGFpbmVyQm91bmRzIH0pO1xuICAgICAgICAgICAgbGFzdFBvcyA9IHBvaW50ZXJQb3M7XG4gICAgICAgICAgICBtb3VzZVBvc2l0aW9uID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgY29udGFpbmVyQm91bmRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZHJhZycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhdXRvUGFuT25Ob2RlRHJhZywgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZURyYWdUaHJlc2hvbGQsIG5vZGVMb29rdXAgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgY29udGFpbmVyQm91bmRzIH0pO1xuICAgICAgICAgICAgaWYgKChldmVudC5zb3VyY2VFdmVudC50eXBlID09PSAndG91Y2htb3ZlJyAmJiBldmVudC5zb3VyY2VFdmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHx8XG4gICAgICAgICAgICAgICAgLy8gaWYgdXNlciBkZWxldGVzIGEgbm9kZSB3aGlsZSBkcmFnZ2luZywgd2UgbmVlZCB0byBhYm9ydCB0aGUgZHJhZyB0byBwcmV2ZW50IGVycm9yc1xuICAgICAgICAgICAgICAgIChub2RlSWQgJiYgIW5vZGVMb29rdXAuaGFzKG5vZGVJZCkpKSB7XG4gICAgICAgICAgICAgICAgYWJvcnREcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYm9ydERyYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWF1dG9QYW5TdGFydGVkICYmIGF1dG9QYW5Pbk5vZGVEcmFnICYmIGRyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF1dG9QYW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gcG9pbnRlclBvcy54U25hcHBlZCAtIChsYXN0UG9zLnggPz8gMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHBvaW50ZXJQb3MueVNuYXBwZWQgLSAobGFzdFBvcy55ID8/IDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IG5vZGVEcmFnVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RHJhZyhldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2tpcCBldmVudHMgd2l0aG91dCBtb3ZlbWVudFxuICAgICAgICAgICAgaWYgKChsYXN0UG9zLnggIT09IHBvaW50ZXJQb3MueFNuYXBwZWQgfHwgbGFzdFBvcy55ICE9PSBwb2ludGVyUG9zLnlTbmFwcGVkKSAmJiBkcmFnSXRlbXMgJiYgZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBkcmFnRXZlbnQgPSBldmVudC5zb3VyY2VFdmVudCBhcyBNb3VzZUV2ZW50O1xuICAgICAgICAgICAgICAgIG1vdXNlUG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVzKHBvaW50ZXJQb3MsIGV2ZW50LnNvdXJjZUV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZW5kJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRyYWdTdGFydGVkIHx8IGFib3J0RHJhZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBkcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYXV0b1BhbklkKTtcbiAgICAgICAgICAgIGlmIChkcmFnSXRlbXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHVwZGF0ZU5vZGVQb3NpdGlvbnMsIG9uTm9kZURyYWdTdG9wLCBvblNlbGVjdGlvbkRyYWdTdG9wIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhkcmFnSXRlbXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAob25EcmFnU3RvcCB8fCBvbk5vZGVEcmFnU3RvcCB8fCAoIW5vZGVJZCAmJiBvblNlbGVjdGlvbkRyYWdTdG9wKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlc10gPSBnZXRFdmVudEhhbmRsZXJQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9uRHJhZ1N0b3A/LihldmVudC5zb3VyY2VFdmVudCwgZHJhZ0l0ZW1zLCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgb25Ob2RlRHJhZ1N0b3A/LihldmVudC5zb3VyY2VFdmVudCwgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGlvbkRyYWdTdG9wPy4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhZXZlbnQuYnV0dG9uICYmXG4gICAgICAgICAgICAgICAgKCFub0RyYWdDbGFzc05hbWUgfHwgIWhhc1NlbGVjdG9yKHRhcmdldCwgYC4ke25vRHJhZ0NsYXNzTmFtZX1gLCBkb21Ob2RlKSkgJiZcbiAgICAgICAgICAgICAgICAoIWhhbmRsZVNlbGVjdG9yIHx8IGhhc1NlbGVjdG9yKHRhcmdldCwgaGFuZGxlU2VsZWN0b3IsIGRvbU5vZGUpKTtcbiAgICAgICAgICAgIHJldHVybiBpc0RyYWdnYWJsZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGQzU2VsZWN0aW9uLmNhbGwoZDNEcmFnSW5zdGFuY2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBkM1NlbGVjdGlvbj8ub24oJy5kcmFnJywgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXROb2Rlc1dpdGhpbkRpc3RhbmNlKHBvc2l0aW9uLCBub2RlTG9va3VwLCBkaXN0YW5jZSkge1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgcmVjdCA9IHtcbiAgICAgICAgeDogcG9zaXRpb24ueCAtIGRpc3RhbmNlLFxuICAgICAgICB5OiBwb3NpdGlvbi55IC0gZGlzdGFuY2UsXG4gICAgICAgIHdpZHRoOiBkaXN0YW5jZSAqIDIsXG4gICAgICAgIGhlaWdodDogZGlzdGFuY2UgKiAyLFxuICAgIH07XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVMb29rdXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKGdldE92ZXJsYXBwaW5nQXJlYShyZWN0LCBub2RlVG9SZWN0KG5vZGUpKSA+IDApIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuLypcbiAqIHRoaXMgZGlzdGFuY2UgaXMgdXNlZCBmb3IgdGhlIGFyZWEgYXJvdW5kIHRoZSB1c2VyIHBvaW50ZXJcbiAqIHdoaWxlIGRvaW5nIGEgY29ubmVjdGlvbiBmb3IgZmluZGluZyB0aGUgY2xvc2VzdCBub2Rlc1xuICovXG5jb25zdCBBRERJVElPTkFMX0RJU1RBTkNFID0gMjUwO1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEhhbmRsZShwb3NpdGlvbiwgY29ubmVjdGlvblJhZGl1cywgbm9kZUxvb2t1cCwgZnJvbUhhbmRsZSkge1xuICAgIGxldCBjbG9zZXN0SGFuZGxlcyA9IFtdO1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGNvbnN0IGNsb3NlTm9kZXMgPSBnZXROb2Rlc1dpdGhpbkRpc3RhbmNlKHBvc2l0aW9uLCBub2RlTG9va3VwLCBjb25uZWN0aW9uUmFkaXVzICsgQURESVRJT05BTF9ESVNUQU5DRSk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIGNsb3NlTm9kZXMpIHtcbiAgICAgICAgY29uc3QgYWxsSGFuZGxlcyA9IFsuLi4obm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10pLCAuLi4obm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy50YXJnZXQgPz8gW10pXTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGUgb2YgYWxsSGFuZGxlcykge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGhhbmRsZSBpcyB0aGUgc2FtZSBhcyB0aGUgZnJvbUhhbmRsZSB3ZSBza2lwIGl0XG4gICAgICAgICAgICBpZiAoZnJvbUhhbmRsZS5ub2RlSWQgPT09IGhhbmRsZS5ub2RlSWQgJiYgZnJvbUhhbmRsZS50eXBlID09PSBoYW5kbGUudHlwZSAmJiBmcm9tSGFuZGxlLmlkID09PSBoYW5kbGUuaWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRldGVybWluZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgaGFuZGxlXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGdldEhhbmRsZVBvc2l0aW9uKG5vZGUsIGhhbmRsZSwgaGFuZGxlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHggLSBwb3NpdGlvbi54LCAyKSArIE1hdGgucG93KHkgLSBwb3NpdGlvbi55LCAyKSk7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBjb25uZWN0aW9uUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RIYW5kbGVzID0gW3sgLi4uaGFuZGxlLCB4LCB5IH1dO1xuICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIG11bHRpcGxlIGhhbmRsZXMgYXJlIG9uIHRoZSBzYW1lIGRpc3RhbmNlIHdlIGNvbGxlY3QgYWxsIG9mIHRoZW1cbiAgICAgICAgICAgICAgICBjbG9zZXN0SGFuZGxlcy5wdXNoKHsgLi4uaGFuZGxlLCB4LCB5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2xvc2VzdEhhbmRsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyB3aGVuIG11bHRpcGxlIGhhbmRsZXMgb3ZlcmxheSBlYWNoIG90aGVyIHdlIHByZWZlciB0aGUgb3Bwb3NpdGUgaGFuZGxlXG4gICAgaWYgKGNsb3Nlc3RIYW5kbGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3Qgb3Bwb3NpdGVIYW5kbGVUeXBlID0gZnJvbUhhbmRsZS50eXBlID09PSAnc291cmNlJyA/ICd0YXJnZXQnIDogJ3NvdXJjZSc7XG4gICAgICAgIHJldHVybiBjbG9zZXN0SGFuZGxlcy5maW5kKChoYW5kbGUpID0+IGhhbmRsZS50eXBlID09PSBvcHBvc2l0ZUhhbmRsZVR5cGUpID8/IGNsb3Nlc3RIYW5kbGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gY2xvc2VzdEhhbmRsZXNbMF07XG59XG5mdW5jdGlvbiBnZXRIYW5kbGUobm9kZUlkLCBoYW5kbGVUeXBlLCBoYW5kbGVJZCwgbm9kZUxvb2t1cCwgY29ubmVjdGlvbk1vZGUsIHdpdGhBYnNvbHV0ZVBvc2l0aW9uID0gZmFsc2UpIHtcbiAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXMgPSBjb25uZWN0aW9uTW9kZSA9PT0gJ3N0cmljdCdcbiAgICAgICAgPyBub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHM/LltoYW5kbGVUeXBlXVxuICAgICAgICA6IFsuLi4obm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10pLCAuLi4obm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy50YXJnZXQgPz8gW10pXTtcbiAgICBjb25zdCBoYW5kbGUgPSAoaGFuZGxlSWQgPyBoYW5kbGVzPy5maW5kKChoKSA9PiBoLmlkID09PSBoYW5kbGVJZCkgOiBoYW5kbGVzPy5bMF0pID8/IG51bGw7XG4gICAgcmV0dXJuIGhhbmRsZSAmJiB3aXRoQWJzb2x1dGVQb3NpdGlvblxuICAgICAgICA/IHsgLi4uaGFuZGxlLCAuLi5nZXRIYW5kbGVQb3NpdGlvbihub2RlLCBoYW5kbGUsIGhhbmRsZS5wb3NpdGlvbiwgdHJ1ZSkgfVxuICAgICAgICA6IGhhbmRsZTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZVR5cGUoZWRnZVVwZGF0ZXJUeXBlLCBoYW5kbGVEb21Ob2RlKSB7XG4gICAgaWYgKGVkZ2VVcGRhdGVyVHlwZSkge1xuICAgICAgICByZXR1cm4gZWRnZVVwZGF0ZXJUeXBlO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYW5kbGVEb21Ob2RlPy5jbGFzc0xpc3QuY29udGFpbnMoJ3RhcmdldCcpKSB7XG4gICAgICAgIHJldHVybiAndGFyZ2V0JztcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlRG9tTm9kZT8uY2xhc3NMaXN0LmNvbnRhaW5zKCdzb3VyY2UnKSkge1xuICAgICAgICByZXR1cm4gJ3NvdXJjZSc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNDb25uZWN0aW9uVmFsaWQoaXNJbnNpZGVDb25uZWN0aW9uUmFkaXVzLCBpc0hhbmRsZVZhbGlkKSB7XG4gICAgbGV0IGlzVmFsaWQgPSBudWxsO1xuICAgIGlmIChpc0hhbmRsZVZhbGlkKSB7XG4gICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0luc2lkZUNvbm5lY3Rpb25SYWRpdXMgJiYgIWlzSGFuZGxlVmFsaWQpIHtcbiAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNWYWxpZDtcbn1cblxuY29uc3QgYWx3YXlzVmFsaWQgPSAoKSA9PiB0cnVlO1xuZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCwgeyBjb25uZWN0aW9uTW9kZSwgY29ubmVjdGlvblJhZGl1cywgaGFuZGxlSWQsIG5vZGVJZCwgZWRnZVVwZGF0ZXJUeXBlLCBpc1RhcmdldCwgZG9tTm9kZSwgbm9kZUxvb2t1cCwgbGliLCBhdXRvUGFuT25Db25uZWN0LCBmbG93SWQsIHBhbkJ5LCBjYW5jZWxDb25uZWN0aW9uLCBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0LCBvbkNvbm5lY3RFbmQsIGlzVmFsaWRDb25uZWN0aW9uID0gYWx3YXlzVmFsaWQsIG9uUmVjb25uZWN0RW5kLCB1cGRhdGVDb25uZWN0aW9uLCBnZXRUcmFuc2Zvcm0sIGdldEZyb21IYW5kbGUsIGF1dG9QYW5TcGVlZCwgfSkge1xuICAgIC8vIHdoZW4geHlmbG93IGlzIHVzZWQgaW5zaWRlIGEgc2hhZG93IHJvb3Qgd2UgY2FuJ3QgdXNlIGRvY3VtZW50XG4gICAgY29uc3QgZG9jID0gZ2V0SG9zdEZvckVsZW1lbnQoZXZlbnQudGFyZ2V0KTtcbiAgICBsZXQgYXV0b1BhbklkID0gMDtcbiAgICBsZXQgY2xvc2VzdEhhbmRsZTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQpO1xuICAgIGNvbnN0IGNsaWNrZWRIYW5kbGUgPSBkb2M/LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgaGFuZGxlVHlwZSA9IGdldEhhbmRsZVR5cGUoZWRnZVVwZGF0ZXJUeXBlLCBjbGlja2VkSGFuZGxlKTtcbiAgICBjb25zdCBjb250YWluZXJCb3VuZHMgPSBkb21Ob2RlPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoIWNvbnRhaW5lckJvdW5kcyB8fCAhaGFuZGxlVHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZyb21IYW5kbGVJbnRlcm5hbCA9IGdldEhhbmRsZShub2RlSWQsIGhhbmRsZVR5cGUsIGhhbmRsZUlkLCBub2RlTG9va3VwLCBjb25uZWN0aW9uTW9kZSk7XG4gICAgaWYgKCFmcm9tSGFuZGxlSW50ZXJuYWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgIGxldCBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBjb25uZWN0aW9uID0gbnVsbDtcbiAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuICAgIGxldCBoYW5kbGVEb21Ob2RlID0gbnVsbDtcbiAgICAvLyB3aGVuIHRoZSB1c2VyIGlzIG1vdmluZyB0aGUgbW91c2UgY2xvc2UgdG8gdGhlIGVkZ2Ugb2YgdGhlIGNhbnZhcyB3aGlsZSBjb25uZWN0aW5nIHdlIG1vdmUgdGhlIGNhbnZhc1xuICAgIGZ1bmN0aW9uIGF1dG9QYW4oKSB7XG4gICAgICAgIGlmICghYXV0b1Bhbk9uQ29ubmVjdCB8fCAhY29udGFpbmVyQm91bmRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3gsIHldID0gY2FsY0F1dG9QYW4ocG9zaXRpb24sIGNvbnRhaW5lckJvdW5kcywgYXV0b1BhblNwZWVkKTtcbiAgICAgICAgcGFuQnkoeyB4LCB5IH0pO1xuICAgICAgICBhdXRvUGFuSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYXV0b1Bhbik7XG4gICAgfVxuICAgIC8vIFN0YXlzIHRoZSBzYW1lIGZvciBhbGwgY29uc2VjdXRpdmUgcG9pbnRlcm1vdmUgZXZlbnRzXG4gICAgY29uc3QgZnJvbUhhbmRsZSA9IHtcbiAgICAgICAgLi4uZnJvbUhhbmRsZUludGVybmFsLFxuICAgICAgICBub2RlSWQsXG4gICAgICAgIHR5cGU6IGhhbmRsZVR5cGUsXG4gICAgICAgIHBvc2l0aW9uOiBmcm9tSGFuZGxlSW50ZXJuYWwucG9zaXRpb24sXG4gICAgfTtcbiAgICBjb25zdCBmcm9tTm9kZUludGVybmFsID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICBjb25zdCBmcm9tID0gZ2V0SGFuZGxlUG9zaXRpb24oZnJvbU5vZGVJbnRlcm5hbCwgZnJvbUhhbmRsZSwgUG9zaXRpb24uTGVmdCwgdHJ1ZSk7XG4gICAgY29uc3QgbmV3Q29ubmVjdGlvbiA9IHtcbiAgICAgICAgaW5Qcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgaXNWYWxpZDogbnVsbCxcbiAgICAgICAgZnJvbSxcbiAgICAgICAgZnJvbUhhbmRsZSxcbiAgICAgICAgZnJvbVBvc2l0aW9uOiBmcm9tSGFuZGxlLnBvc2l0aW9uLFxuICAgICAgICBmcm9tTm9kZTogZnJvbU5vZGVJbnRlcm5hbCxcbiAgICAgICAgdG86IHBvc2l0aW9uLFxuICAgICAgICB0b0hhbmRsZTogbnVsbCxcbiAgICAgICAgdG9Qb3NpdGlvbjogb3Bwb3NpdGVQb3NpdGlvbltmcm9tSGFuZGxlLnBvc2l0aW9uXSxcbiAgICAgICAgdG9Ob2RlOiBudWxsLFxuICAgIH07XG4gICAgdXBkYXRlQ29ubmVjdGlvbihuZXdDb25uZWN0aW9uKTtcbiAgICBsZXQgcHJldmlvdXNDb25uZWN0aW9uID0gbmV3Q29ubmVjdGlvbjtcbiAgICBvbkNvbm5lY3RTdGFydD8uKGV2ZW50LCB7IG5vZGVJZCwgaGFuZGxlSWQsIGhhbmRsZVR5cGUgfSk7XG4gICAgZnVuY3Rpb24gb25Qb2ludGVyTW92ZShldmVudCkge1xuICAgICAgICBpZiAoIWdldEZyb21IYW5kbGUoKSB8fCAhZnJvbUhhbmRsZSkge1xuICAgICAgICAgICAgb25Qb2ludGVyVXAoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGdldFRyYW5zZm9ybSgpO1xuICAgICAgICBwb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgICAgIGNsb3Nlc3RIYW5kbGUgPSBnZXRDbG9zZXN0SGFuZGxlKHBvaW50VG9SZW5kZXJlclBvaW50KHBvc2l0aW9uLCB0cmFuc2Zvcm0sIGZhbHNlLCBbMSwgMV0pLCBjb25uZWN0aW9uUmFkaXVzLCBub2RlTG9va3VwLCBmcm9tSGFuZGxlKTtcbiAgICAgICAgaWYgKCFhdXRvUGFuU3RhcnRlZCkge1xuICAgICAgICAgICAgYXV0b1BhbigpO1xuICAgICAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGlzVmFsaWRIYW5kbGUoZXZlbnQsIHtcbiAgICAgICAgICAgIGhhbmRsZTogY2xvc2VzdEhhbmRsZSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgZnJvbU5vZGVJZDogbm9kZUlkLFxuICAgICAgICAgICAgZnJvbUhhbmRsZUlkOiBoYW5kbGVJZCxcbiAgICAgICAgICAgIGZyb21UeXBlOiBpc1RhcmdldCA/ICd0YXJnZXQnIDogJ3NvdXJjZScsXG4gICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbixcbiAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgIGxpYixcbiAgICAgICAgICAgIGZsb3dJZCxcbiAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgIH0pO1xuICAgICAgICBoYW5kbGVEb21Ob2RlID0gcmVzdWx0LmhhbmRsZURvbU5vZGU7XG4gICAgICAgIGNvbm5lY3Rpb24gPSByZXN1bHQuY29ubmVjdGlvbjtcbiAgICAgICAgaXNWYWxpZCA9IGlzQ29ubmVjdGlvblZhbGlkKCEhY2xvc2VzdEhhbmRsZSwgcmVzdWx0LmlzVmFsaWQpO1xuICAgICAgICBjb25zdCBuZXdDb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgLy8gZnJvbSBzdGF5cyB0aGUgc2FtZVxuICAgICAgICAgICAgLi4ucHJldmlvdXNDb25uZWN0aW9uLFxuICAgICAgICAgICAgaXNWYWxpZCxcbiAgICAgICAgICAgIHRvOiByZXN1bHQudG9IYW5kbGUgJiYgaXNWYWxpZFxuICAgICAgICAgICAgICAgID8gcmVuZGVyZXJQb2ludFRvUG9pbnQoeyB4OiByZXN1bHQudG9IYW5kbGUueCwgeTogcmVzdWx0LnRvSGFuZGxlLnkgfSwgdHJhbnNmb3JtKVxuICAgICAgICAgICAgICAgIDogcG9zaXRpb24sXG4gICAgICAgICAgICB0b0hhbmRsZTogcmVzdWx0LnRvSGFuZGxlLFxuICAgICAgICAgICAgdG9Qb3NpdGlvbjogaXNWYWxpZCAmJiByZXN1bHQudG9IYW5kbGUgPyByZXN1bHQudG9IYW5kbGUucG9zaXRpb24gOiBvcHBvc2l0ZVBvc2l0aW9uW2Zyb21IYW5kbGUucG9zaXRpb25dLFxuICAgICAgICAgICAgdG9Ob2RlOiByZXN1bHQudG9IYW5kbGUgPyBub2RlTG9va3VwLmdldChyZXN1bHQudG9IYW5kbGUubm9kZUlkKSA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIC8qXG4gICAgICAgICAqIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBhbiB1cGRhdGUgd2hlbiB0aGUgY29ubmVjdGlvblxuICAgICAgICAgKiBpcyBzbmFwcGVkIHRvIHRoZSBzYW1lIGhhbmRsZSBhcyBiZWZvcmVcbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc1ZhbGlkICYmXG4gICAgICAgICAgICBjbG9zZXN0SGFuZGxlICYmXG4gICAgICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24udG9IYW5kbGUgJiZcbiAgICAgICAgICAgIG5ld0Nvbm5lY3Rpb24udG9IYW5kbGUgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50b0hhbmRsZS50eXBlID09PSBuZXdDb25uZWN0aW9uLnRvSGFuZGxlLnR5cGUgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50b0hhbmRsZS5ub2RlSWQgPT09IG5ld0Nvbm5lY3Rpb24udG9IYW5kbGUubm9kZUlkICYmXG4gICAgICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24udG9IYW5kbGUuaWQgPT09IG5ld0Nvbm5lY3Rpb24udG9IYW5kbGUuaWQgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50by54ID09PSBuZXdDb25uZWN0aW9uLnRvLnggJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50by55ID09PSBuZXdDb25uZWN0aW9uLnRvLnkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVDb25uZWN0aW9uKG5ld0Nvbm5lY3Rpb24pO1xuICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24gPSBuZXdDb25uZWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJVcChldmVudCkge1xuICAgICAgICBpZiAoKGNsb3Nlc3RIYW5kbGUgfHwgaGFuZGxlRG9tTm9kZSkgJiYgY29ubmVjdGlvbiAmJiBpc1ZhbGlkKSB7XG4gICAgICAgICAgICBvbkNvbm5lY3Q/Lihjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBpdCdzIGltcG9ydGFudCB0byBnZXQgYSBmcmVzaCByZWZlcmVuY2UgZnJvbSB0aGUgc3RvcmUgaGVyZVxuICAgICAgICAgKiBpbiBvcmRlciB0byBnZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBvbkNvbm5lY3RFbmRcbiAgICAgICAgICovXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgeyBpblByb2dyZXNzLCAuLi5jb25uZWN0aW9uU3RhdGUgfSA9IHByZXZpb3VzQ29ubmVjdGlvbjtcbiAgICAgICAgY29uc3QgZmluYWxDb25uZWN0aW9uU3RhdGUgPSB7XG4gICAgICAgICAgICAuLi5jb25uZWN0aW9uU3RhdGUsXG4gICAgICAgICAgICB0b1Bvc2l0aW9uOiBwcmV2aW91c0Nvbm5lY3Rpb24udG9IYW5kbGUgPyBwcmV2aW91c0Nvbm5lY3Rpb24udG9Qb3NpdGlvbiA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIG9uQ29ubmVjdEVuZD8uKGV2ZW50LCBmaW5hbENvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIGlmIChlZGdlVXBkYXRlclR5cGUpIHtcbiAgICAgICAgICAgIG9uUmVjb25uZWN0RW5kPy4oZXZlbnQsIGZpbmFsQ29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjYW5jZWxDb25uZWN0aW9uKCk7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGF1dG9QYW5JZCk7XG4gICAgICAgIGF1dG9QYW5TdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgIGhhbmRsZURvbU5vZGUgPSBudWxsO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Qb2ludGVyVXApO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uUG9pbnRlclVwKTtcbiAgICB9XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Qb2ludGVyVXApO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblBvaW50ZXJVcCk7XG59XG4vLyBjaGVja3MgaWYgIGFuZCByZXR1cm5zIGNvbm5lY3Rpb24gaW4gZm9tIG9mIGFuIG9iamVjdCB7IHNvdXJjZTogMTIzLCB0YXJnZXQ6IDMxMiB9XG5mdW5jdGlvbiBpc1ZhbGlkSGFuZGxlKGV2ZW50LCB7IGhhbmRsZSwgY29ubmVjdGlvbk1vZGUsIGZyb21Ob2RlSWQsIGZyb21IYW5kbGVJZCwgZnJvbVR5cGUsIGRvYywgbGliLCBmbG93SWQsIGlzVmFsaWRDb25uZWN0aW9uID0gYWx3YXlzVmFsaWQsIG5vZGVMb29rdXAsIH0pIHtcbiAgICBjb25zdCBpc1RhcmdldCA9IGZyb21UeXBlID09PSAndGFyZ2V0JztcbiAgICBjb25zdCBoYW5kbGVEb21Ob2RlID0gaGFuZGxlXG4gICAgICAgID8gZG9jLnF1ZXJ5U2VsZWN0b3IoYC4ke2xpYn0tZmxvd19faGFuZGxlW2RhdGEtaWQ9XCIke2Zsb3dJZH0tJHtoYW5kbGU/Lm5vZGVJZH0tJHtoYW5kbGU/LmlkfS0ke2hhbmRsZT8udHlwZX1cIl1gKVxuICAgICAgICA6IG51bGw7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50KTtcbiAgICBjb25zdCBoYW5kbGVCZWxvdyA9IGRvYy5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgIC8qXG4gICAgICogd2UgYWx3YXlzIHdhbnQgdG8gcHJpb3JpdGl6ZSB0aGUgaGFuZGxlIGJlbG93IHRoZSBtb3VzZSBjdXJzb3Igb3ZlciB0aGUgY2xvc2VzdCBkaXN0YW5jZSBoYW5kbGUsXG4gICAgICogYmVjYXVzZSBpdCBjb3VsZCBiZSB0aGF0IHRoZSBjZW50ZXIgb2YgYW5vdGhlciBoYW5kbGUgaXMgY2xvc2VyIHRvIHRoZSBtb3VzZSBwb2ludGVyIHRoYW4gdGhlIGhhbmRsZSBiZWxvdyB0aGUgY3Vyc29yXG4gICAgICovXG4gICAgY29uc3QgaGFuZGxlVG9DaGVjayA9IGhhbmRsZUJlbG93Py5jbGFzc0xpc3QuY29udGFpbnMoYCR7bGlifS1mbG93X19oYW5kbGVgKSA/IGhhbmRsZUJlbG93IDogaGFuZGxlRG9tTm9kZTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGhhbmRsZURvbU5vZGU6IGhhbmRsZVRvQ2hlY2ssXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBjb25uZWN0aW9uOiBudWxsLFxuICAgICAgICB0b0hhbmRsZTogbnVsbCxcbiAgICB9O1xuICAgIGlmIChoYW5kbGVUb0NoZWNrKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZVR5cGUgPSBnZXRIYW5kbGVUeXBlKHVuZGVmaW5lZCwgaGFuZGxlVG9DaGVjayk7XG4gICAgICAgIGNvbnN0IGhhbmRsZU5vZGVJZCA9IGhhbmRsZVRvQ2hlY2suZ2V0QXR0cmlidXRlKCdkYXRhLW5vZGVpZCcpO1xuICAgICAgICBjb25zdCBoYW5kbGVJZCA9IGhhbmRsZVRvQ2hlY2suZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZWlkJyk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RhYmxlID0gaGFuZGxlVG9DaGVjay5jbGFzc0xpc3QuY29udGFpbnMoJ2Nvbm5lY3RhYmxlJyk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RhYmxlRW5kID0gaGFuZGxlVG9DaGVjay5jbGFzc0xpc3QuY29udGFpbnMoJ2Nvbm5lY3RhYmxlZW5kJyk7XG4gICAgICAgIGlmICghaGFuZGxlTm9kZUlkIHx8ICFoYW5kbGVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB7XG4gICAgICAgICAgICBzb3VyY2U6IGlzVGFyZ2V0ID8gaGFuZGxlTm9kZUlkIDogZnJvbU5vZGVJZCxcbiAgICAgICAgICAgIHNvdXJjZUhhbmRsZTogaXNUYXJnZXQgPyBoYW5kbGVJZCA6IGZyb21IYW5kbGVJZCxcbiAgICAgICAgICAgIHRhcmdldDogaXNUYXJnZXQgPyBmcm9tTm9kZUlkIDogaGFuZGxlTm9kZUlkLFxuICAgICAgICAgICAgdGFyZ2V0SGFuZGxlOiBpc1RhcmdldCA/IGZyb21IYW5kbGVJZCA6IGhhbmRsZUlkLFxuICAgICAgICB9O1xuICAgICAgICByZXN1bHQuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIGNvbnN0IGlzQ29ubmVjdGFibGUgPSBjb25uZWN0YWJsZSAmJiBjb25uZWN0YWJsZUVuZDtcbiAgICAgICAgLy8gaW4gc3RyaWN0IG1vZGUgd2UgZG9uJ3QgYWxsb3cgdGFyZ2V0IHRvIHRhcmdldCBvciBzb3VyY2UgdG8gc291cmNlIGNvbm5lY3Rpb25zXG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBpc0Nvbm5lY3RhYmxlICYmXG4gICAgICAgICAgICAoY29ubmVjdGlvbk1vZGUgPT09IENvbm5lY3Rpb25Nb2RlLlN0cmljdFxuICAgICAgICAgICAgICAgID8gKGlzVGFyZ2V0ICYmIGhhbmRsZVR5cGUgPT09ICdzb3VyY2UnKSB8fCAoIWlzVGFyZ2V0ICYmIGhhbmRsZVR5cGUgPT09ICd0YXJnZXQnKVxuICAgICAgICAgICAgICAgIDogaGFuZGxlTm9kZUlkICE9PSBmcm9tTm9kZUlkIHx8IGhhbmRsZUlkICE9PSBmcm9tSGFuZGxlSWQpO1xuICAgICAgICByZXN1bHQuaXNWYWxpZCA9IGlzVmFsaWQgJiYgaXNWYWxpZENvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgICAgIHJlc3VsdC50b0hhbmRsZSA9IGdldEhhbmRsZShoYW5kbGVOb2RlSWQsIGhhbmRsZVR5cGUsIGhhbmRsZUlkLCBub2RlTG9va3VwLCBjb25uZWN0aW9uTW9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBYWUhhbmRsZSA9IHtcbiAgICBvblBvaW50ZXJEb3duLFxuICAgIGlzVmFsaWQ6IGlzVmFsaWRIYW5kbGUsXG59O1xuXG5mdW5jdGlvbiBYWU1pbmltYXAoeyBkb21Ob2RlLCBwYW5ab29tLCBnZXRUcmFuc2Zvcm0sIGdldFZpZXdTY2FsZSB9KSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gc2VsZWN0KGRvbU5vZGUpO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSh7IHRyYW5zbGF0ZUV4dGVudCwgd2lkdGgsIGhlaWdodCwgem9vbVN0ZXAgPSAxMCwgcGFubmFibGUgPSB0cnVlLCB6b29tYWJsZSA9IHRydWUsIGludmVyc2VQYW4gPSBmYWxzZSwgfSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCB6b29tSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQudHlwZSAhPT0gJ3doZWVsJyB8fCAhcGFuWm9vbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBpbmNoRGVsdGEgPSAtZXZlbnQuc291cmNlRXZlbnQuZGVsdGFZICpcbiAgICAgICAgICAgICAgICAoZXZlbnQuc291cmNlRXZlbnQuZGVsdGFNb2RlID09PSAxID8gMC4wNSA6IGV2ZW50LnNvdXJjZUV2ZW50LmRlbHRhTW9kZSA/IDEgOiAwLjAwMikgKlxuICAgICAgICAgICAgICAgIHpvb21TdGVwO1xuICAgICAgICAgICAgY29uc3QgbmV4dFpvb20gPSB0cmFuc2Zvcm1bMl0gKiBNYXRoLnBvdygyLCBwaW5jaERlbHRhKTtcbiAgICAgICAgICAgIHBhblpvb20uc2NhbGVUbyhuZXh0Wm9vbSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwYW5TdGFydCA9IFswLCAwXTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgcGFuU3RhcnRIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgcGFuU3RhcnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFggPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudC5jbGllbnRZID8/IGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBwYW5IYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGlmICgoZXZlbnQuc291cmNlRXZlbnQudHlwZSAhPT0gJ21vdXNlbW92ZScgJiYgZXZlbnQuc291cmNlRXZlbnQudHlwZSAhPT0gJ3RvdWNobW92ZScpIHx8ICFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFuQ3VycmVudCA9IFtcbiAgICAgICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudC5jbGllbnRYID8/IGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudC5jbGllbnRZID8/IGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBwYW5EZWx0YSA9IFtwYW5DdXJyZW50WzBdIC0gcGFuU3RhcnRbMF0sIHBhbkN1cnJlbnRbMV0gLSBwYW5TdGFydFsxXV07XG4gICAgICAgICAgICBwYW5TdGFydCA9IHBhbkN1cnJlbnQ7XG4gICAgICAgICAgICBjb25zdCBtb3ZlU2NhbGUgPSBnZXRWaWV3U2NhbGUoKSAqIE1hdGgubWF4KHRyYW5zZm9ybVsyXSwgTWF0aC5sb2codHJhbnNmb3JtWzJdKSkgKiAoaW52ZXJzZVBhbiA/IC0xIDogMSk7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiB0cmFuc2Zvcm1bMF0gLSBwYW5EZWx0YVswXSAqIG1vdmVTY2FsZSxcbiAgICAgICAgICAgICAgICB5OiB0cmFuc2Zvcm1bMV0gLSBwYW5EZWx0YVsxXSAqIG1vdmVTY2FsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgICAgICAgIFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBwYW5ab29tLnNldFZpZXdwb3J0Q29uc3RyYWluZWQoe1xuICAgICAgICAgICAgICAgIHg6IHBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgeTogcG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICB6b29tOiB0cmFuc2Zvcm1bMl0sXG4gICAgICAgICAgICB9LCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHpvb21BbmRQYW5IYW5kbGVyID0gem9vbSgpXG4gICAgICAgICAgICAub24oJ3N0YXJ0JywgcGFuU3RhcnRIYW5kbGVyKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgLm9uKCd6b29tJywgcGFubmFibGUgPyBwYW5IYW5kbGVyIDogbnVsbClcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIC5vbignem9vbS53aGVlbCcsIHpvb21hYmxlID8gem9vbUhhbmRsZXIgOiBudWxsKTtcbiAgICAgICAgc2VsZWN0aW9uLmNhbGwoem9vbUFuZFBhbkhhbmRsZXIsIHt9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgc2VsZWN0aW9uLm9uKCd6b29tJywgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICAgICAgcG9pbnRlcixcbiAgICB9O1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCB2aWV3Q2hhbmdlZCA9IChwcmV2Vmlld3BvcnQsIGV2ZW50Vmlld3BvcnQpID0+IHByZXZWaWV3cG9ydC54ICE9PSBldmVudFZpZXdwb3J0LnggfHwgcHJldlZpZXdwb3J0LnkgIT09IGV2ZW50Vmlld3BvcnQueSB8fCBwcmV2Vmlld3BvcnQuem9vbSAhPT0gZXZlbnRWaWV3cG9ydC5rO1xuY29uc3QgdHJhbnNmb3JtVG9WaWV3cG9ydCA9ICh0cmFuc2Zvcm0pID0+ICh7XG4gICAgeDogdHJhbnNmb3JtLngsXG4gICAgeTogdHJhbnNmb3JtLnksXG4gICAgem9vbTogdHJhbnNmb3JtLmssXG59KTtcbmNvbnN0IHZpZXdwb3J0VG9UcmFuc2Zvcm0gPSAoeyB4LCB5LCB6b29tIH0pID0+IHpvb21JZGVudGl0eS50cmFuc2xhdGUoeCwgeSkuc2NhbGUoem9vbSk7XG5jb25zdCBpc1dyYXBwZWRXaXRoQ2xhc3MgPSAoZXZlbnQsIGNsYXNzTmFtZSkgPT4gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoYC4ke2NsYXNzTmFtZX1gKTtcbmNvbnN0IGlzUmlnaHRDbGlja1BhbiA9IChwYW5PbkRyYWcsIHVzZWRCdXR0b24pID0+IHVzZWRCdXR0b24gPT09IDIgJiYgQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZy5pbmNsdWRlcygyKTtcbmNvbnN0IGdldEQzVHJhbnNpdGlvbiA9IChzZWxlY3Rpb24sIGR1cmF0aW9uID0gMCwgb25FbmQgPSAoKSA9PiB7IH0pID0+IHtcbiAgICBjb25zdCBoYXNEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcicgJiYgZHVyYXRpb24gPiAwO1xuICAgIGlmICghaGFzRHVyYXRpb24pIHtcbiAgICAgICAgb25FbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0R1cmF0aW9uID8gc2VsZWN0aW9uLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikub24oJ2VuZCcsIG9uRW5kKSA6IHNlbGVjdGlvbjtcbn07XG5jb25zdCB3aGVlbERlbHRhID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgZmFjdG9yID0gZXZlbnQuY3RybEtleSAmJiBpc01hY09zKCkgPyAxMCA6IDE7XG4gICAgcmV0dXJuIC1ldmVudC5kZWx0YVkgKiAoZXZlbnQuZGVsdGFNb2RlID09PSAxID8gMC4wNSA6IGV2ZW50LmRlbHRhTW9kZSA/IDEgOiAwLjAwMikgKiBmYWN0b3I7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVQYW5PblNjcm9sbEhhbmRsZXIoeyB6b29tUGFuVmFsdWVzLCBub1doZWVsQ2xhc3NOYW1lLCBkM1NlbGVjdGlvbiwgZDNab29tLCBwYW5PblNjcm9sbE1vZGUsIHBhbk9uU2Nyb2xsU3BlZWQsIHpvb21PblBpbmNoLCBvblBhblpvb21TdGFydCwgb25QYW5ab29tLCBvblBhblpvb21FbmQsIH0pIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIG5vV2hlZWxDbGFzc05hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gZDNTZWxlY3Rpb24ucHJvcGVydHkoJ19fem9vbScpLmsgfHwgMTtcbiAgICAgICAgLy8gbWFjb3Mgc2V0cyBjdHJsS2V5PXRydWUgZm9yIHBpbmNoIGdlc3R1cmUgb24gYSB0cmFja3BhZFxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiB6b29tT25QaW5jaCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludGVyKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHBpbmNoRGVsdGEgPSB3aGVlbERlbHRhKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHpvb20gPSBjdXJyZW50Wm9vbSAqIE1hdGgucG93KDIsIHBpbmNoRGVsdGEpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZDNab29tLnNjYWxlVG8oZDNTZWxlY3Rpb24sIHpvb20sIHBvaW50LCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogaW5jcmVhc2Ugc2Nyb2xsIHNwZWVkIGluIGZpcmVmb3hcbiAgICAgICAgICogZmlyZWZveDogZGVsdGFNb2RlID09PSAxOyBjaHJvbWU6IGRlbHRhTW9kZSA9PT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgZGVsdGFOb3JtYWxpemUgPSBldmVudC5kZWx0YU1vZGUgPT09IDEgPyAyMCA6IDE7XG4gICAgICAgIGxldCBkZWx0YVggPSBwYW5PblNjcm9sbE1vZGUgPT09IFBhbk9uU2Nyb2xsTW9kZS5WZXJ0aWNhbCA/IDAgOiBldmVudC5kZWx0YVggKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgbGV0IGRlbHRhWSA9IHBhbk9uU2Nyb2xsTW9kZSA9PT0gUGFuT25TY3JvbGxNb2RlLkhvcml6b250YWwgPyAwIDogZXZlbnQuZGVsdGFZICogZGVsdGFOb3JtYWxpemU7XG4gICAgICAgIC8vIHRoaXMgZW5hYmxlcyB2ZXJ0aWNhbCBzY3JvbGxpbmcgd2l0aCBzaGlmdCArIHNjcm9sbCBvbiB3aW5kb3dzXG4gICAgICAgIGlmICghaXNNYWNPcygpICYmIGV2ZW50LnNoaWZ0S2V5ICYmIHBhbk9uU2Nyb2xsTW9kZSAhPT0gUGFuT25TY3JvbGxNb2RlLlZlcnRpY2FsKSB7XG4gICAgICAgICAgICBkZWx0YVggPSBldmVudC5kZWx0YVkgKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgICAgIGRlbHRhWSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZDNab29tLnRyYW5zbGF0ZUJ5KGQzU2VsZWN0aW9uLCAtKGRlbHRhWCAvIGN1cnJlbnRab29tKSAqIHBhbk9uU2Nyb2xsU3BlZWQsIC0oZGVsdGFZIC8gY3VycmVudFpvb20pICogcGFuT25TY3JvbGxTcGVlZCwgXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgeyBpbnRlcm5hbDogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgbmV4dFZpZXdwb3J0ID0gdHJhbnNmb3JtVG9WaWV3cG9ydChkM1NlbGVjdGlvbi5wcm9wZXJ0eSgnX196b29tJykpO1xuICAgICAgICBjbGVhclRpbWVvdXQoem9vbVBhblZhbHVlcy5wYW5TY3JvbGxUaW1lb3V0KTtcbiAgICAgICAgLypcbiAgICAgICAgICogZm9yIHBhbiBvbiBzY3JvbGwgd2UgbmVlZCB0byBoYW5kbGUgdGhlIGV2ZW50IGNhbGxzIG9uIG91ciBvd25cbiAgICAgICAgICogd2UgY2FuJ3QgdXNlIHRoZSBzdGFydCwgem9vbSBhbmQgZW5kIGV2ZW50cyBmcm9tIGQzLXpvb21cbiAgICAgICAgICogYmVjYXVzZSBzdGFydCBhbmQgbW92ZSBnZXRzIGNhbGxlZCBvbiBldmVyeSBzY3JvbGwgZXZlbnQgYW5kIG5vdCBvbmNlIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICovXG4gICAgICAgIGlmICghem9vbVBhblZhbHVlcy5pc1BhblNjcm9sbGluZykge1xuICAgICAgICAgICAgem9vbVBhblZhbHVlcy5pc1BhblNjcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICBvblBhblpvb21TdGFydD8uKGV2ZW50LCBuZXh0Vmlld3BvcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6b29tUGFuVmFsdWVzLmlzUGFuU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICBvblBhblpvb20/LihldmVudCwgbmV4dFZpZXdwb3J0KTtcbiAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMucGFuU2Nyb2xsVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uUGFuWm9vbUVuZD8uKGV2ZW50LCBuZXh0Vmlld3BvcnQpO1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMuaXNQYW5TY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIDE1MCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlWm9vbU9uU2Nyb2xsSGFuZGxlcih7IG5vV2hlZWxDbGFzc05hbWUsIHByZXZlbnRTY3JvbGxpbmcsIGQzWm9vbUhhbmRsZXIgfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQsIGQpIHtcbiAgICAgICAgY29uc3QgaXNXaGVlbCA9IGV2ZW50LnR5cGUgPT09ICd3aGVlbCc7XG4gICAgICAgIC8vIHdlIHN0aWxsIHdhbnQgdG8gZW5hYmxlIHBpbmNoIHpvb21pbmcgZXZlbiBpZiBwcmV2ZW50U2Nyb2xsaW5nIGlzIHNldCB0byBmYWxzZVxuICAgICAgICBjb25zdCBwcmV2ZW50Wm9vbSA9ICFwcmV2ZW50U2Nyb2xsaW5nICYmIGlzV2hlZWwgJiYgIWV2ZW50LmN0cmxLZXk7XG4gICAgICAgIGNvbnN0IGhhc05vV2hlZWxDbGFzcyA9IGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSk7XG4gICAgICAgIC8vIGlmIHVzZXIgaXMgcGluY2ggem9vbWluZyBhYm92ZSBhIG5vd2hlZWwgZWxlbWVudCwgd2UgZG9uJ3Qgd2FudCB0aGUgYnJvd3NlciB0byB6b29tXG4gICAgICAgIGlmIChldmVudC5jdHJsS2V5ICYmIGlzV2hlZWwgJiYgaGFzTm9XaGVlbENsYXNzKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2ZW50Wm9vbSB8fCBoYXNOb1doZWVsQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGQzWm9vbUhhbmRsZXIuY2FsbCh0aGlzLCBldmVudCwgZCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhblpvb21TdGFydEhhbmRsZXIoeyB6b29tUGFuVmFsdWVzLCBvbkRyYWdnaW5nQ2hhbmdlLCBvblBhblpvb21TdGFydCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQ/LmludGVybmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld3BvcnQgPSB0cmFuc2Zvcm1Ub1ZpZXdwb3J0KGV2ZW50LnRyYW5zZm9ybSk7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgaXQgaGVyZSwgYmVjYXVzZSBpdCdzIGFsd2F5cyAwIGluIHRoZSBcInpvb21cIiBldmVudFxuICAgICAgICB6b29tUGFuVmFsdWVzLm1vdXNlQnV0dG9uID0gZXZlbnQuc291cmNlRXZlbnQ/LmJ1dHRvbiB8fCAwO1xuICAgICAgICB6b29tUGFuVmFsdWVzLmlzWm9vbWluZ09yUGFubmluZyA9IHRydWU7XG4gICAgICAgIHpvb21QYW5WYWx1ZXMucHJldlZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudD8udHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2UodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUGFuWm9vbVN0YXJ0KSB7XG4gICAgICAgICAgICBvblBhblpvb21TdGFydD8uKGV2ZW50LnNvdXJjZUV2ZW50LCB2aWV3cG9ydCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGFuWm9vbUhhbmRsZXIoeyB6b29tUGFuVmFsdWVzLCBwYW5PbkRyYWcsIG9uUGFuZUNvbnRleHRNZW51LCBvblRyYW5zZm9ybUNoYW5nZSwgb25QYW5ab29tLCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICB6b29tUGFuVmFsdWVzLnVzZWRSaWdodE1vdXNlQnV0dG9uID0gISEob25QYW5lQ29udGV4dE1lbnUgJiYgaXNSaWdodENsaWNrUGFuKHBhbk9uRHJhZywgem9vbVBhblZhbHVlcy5tb3VzZUJ1dHRvbiA/PyAwKSk7XG4gICAgICAgIGlmICghZXZlbnQuc291cmNlRXZlbnQ/LnN5bmMpIHtcbiAgICAgICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlKFtldmVudC50cmFuc2Zvcm0ueCwgZXZlbnQudHJhbnNmb3JtLnksIGV2ZW50LnRyYW5zZm9ybS5rXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUGFuWm9vbSAmJiAhZXZlbnQuc291cmNlRXZlbnQ/LmludGVybmFsKSB7XG4gICAgICAgICAgICBvblBhblpvb20/LihldmVudC5zb3VyY2VFdmVudCwgdHJhbnNmb3JtVG9WaWV3cG9ydChldmVudC50cmFuc2Zvcm0pKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVQYW5ab29tRW5kSGFuZGxlcih7IHpvb21QYW5WYWx1ZXMsIHBhbk9uRHJhZywgcGFuT25TY3JvbGwsIG9uRHJhZ2dpbmdDaGFuZ2UsIG9uUGFuWm9vbUVuZCwgb25QYW5lQ29udGV4dE1lbnUsIH0pIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudD8uaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB6b29tUGFuVmFsdWVzLmlzWm9vbWluZ09yUGFubmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAob25QYW5lQ29udGV4dE1lbnUgJiZcbiAgICAgICAgICAgIGlzUmlnaHRDbGlja1BhbihwYW5PbkRyYWcsIHpvb21QYW5WYWx1ZXMubW91c2VCdXR0b24gPz8gMCkgJiZcbiAgICAgICAgICAgICF6b29tUGFuVmFsdWVzLnVzZWRSaWdodE1vdXNlQnV0dG9uICYmXG4gICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudCkge1xuICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnUoZXZlbnQuc291cmNlRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHpvb21QYW5WYWx1ZXMudXNlZFJpZ2h0TW91c2VCdXR0b24gPSBmYWxzZTtcbiAgICAgICAgb25EcmFnZ2luZ0NoYW5nZShmYWxzZSk7XG4gICAgICAgIGlmIChvblBhblpvb21FbmQgJiYgdmlld0NoYW5nZWQoem9vbVBhblZhbHVlcy5wcmV2Vmlld3BvcnQsIGV2ZW50LnRyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gdHJhbnNmb3JtVG9WaWV3cG9ydChldmVudC50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgem9vbVBhblZhbHVlcy5wcmV2Vmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh6b29tUGFuVmFsdWVzLnRpbWVySWQpO1xuICAgICAgICAgICAgem9vbVBhblZhbHVlcy50aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kPy4oZXZlbnQuc291cmNlRXZlbnQsIHZpZXdwb3J0KTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLy8gd2UgbmVlZCBhIHNldFRpbWVvdXQgZm9yIHBhbk9uU2Nyb2xsIHRvIHN1cHJlc3MgbXVsdGlwbGUgZW5kIGV2ZW50cyBmaXJlZCBkdXJpbmcgc2Nyb2xsXG4gICAgICAgICAgICBwYW5PblNjcm9sbCA/IDE1MCA6IDApO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuZnVuY3Rpb24gY3JlYXRlRmlsdGVyKHsgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLCB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoLCBwYW5PbkRyYWcsIHBhbk9uU2Nyb2xsLCB6b29tT25Eb3VibGVDbGljaywgdXNlclNlbGVjdGlvbkFjdGl2ZSwgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGxpYiwgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3Qgem9vbVNjcm9sbCA9IHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCB8fCB6b29tT25TY3JvbGw7XG4gICAgICAgIGNvbnN0IHBpbmNoWm9vbSA9IHpvb21PblBpbmNoICYmIGV2ZW50LmN0cmxLZXk7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gPT09IDEgJiZcbiAgICAgICAgICAgIGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nICYmXG4gICAgICAgICAgICAoaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBgJHtsaWJ9LWZsb3dfX25vZGVgKSB8fCBpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIGAke2xpYn0tZmxvd19fZWRnZWApKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYWxsIGludGVyYWN0aW9ucyBhcmUgZGlzYWJsZWQsIHdlIHByZXZlbnQgYWxsIHpvb20gZXZlbnRzXG4gICAgICAgIGlmICghcGFuT25EcmFnICYmICF6b29tU2Nyb2xsICYmICFwYW5PblNjcm9sbCAmJiAhem9vbU9uRG91YmxlQ2xpY2sgJiYgIXpvb21PblBpbmNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZHVyaW5nIGEgc2VsZWN0aW9uIHdlIHByZXZlbnQgYWxsIG90aGVyIGludGVyYWN0aW9uc1xuICAgICAgICBpZiAodXNlclNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBpbnNpZGUgYW4gZWxlbWVudCB3aXRoIHRoZSBub3doZWVsIGNsYXNzLCB3ZSBwcmV2ZW50IHpvb21pbmdcbiAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSkgJiYgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBpbnNpZGUgYW4gZWxlbWVudCB3aXRoIHRoZSBub3BhbiBjbGFzcywgd2UgcHJldmVudCBwYW5uaW5nXG4gICAgICAgIGlmIChpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIG5vUGFuQ2xhc3NOYW1lKSAmJlxuICAgICAgICAgICAgKGV2ZW50LnR5cGUgIT09ICd3aGVlbCcgfHwgKHBhbk9uU2Nyb2xsICYmIGV2ZW50LnR5cGUgPT09ICd3aGVlbCcgJiYgIXpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF6b29tT25QaW5jaCAmJiBldmVudC5jdHJsS2V5ICYmIGV2ZW50LnR5cGUgPT09ICd3aGVlbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXpvb21PblBpbmNoICYmIGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JyAmJiBldmVudC50b3VjaGVzPy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBpZiB5b3UgbWFuYWdlIHRvIHN0YXJ0IHdpdGggMiB0b3VjaGVzLCB3ZSBwcmV2ZW50IG5hdGl2ZSB6b29tXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2hlbiB0aGVyZSBpcyBubyBzY3JvbGwgaGFuZGxpbmcgZW5hYmxlZCwgd2UgcHJldmVudCBhbGwgd2hlZWwgZXZlbnRzXG4gICAgICAgIGlmICghem9vbVNjcm9sbCAmJiAhcGFuT25TY3JvbGwgJiYgIXBpbmNoWm9vbSAmJiBldmVudC50eXBlID09PSAnd2hlZWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHBhbmUgaXMgbm90IG1vdmFibGUsIHdlIHByZXZlbnQgZHJhZ2dpbmcgaXQgd2l0aCBtb3VzZXN0YXJ0IG9yIHRvdWNoc3RhcnRcbiAgICAgICAgaWYgKCFwYW5PbkRyYWcgJiYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgcGFuZSBpcyBvbmx5IG1vdmFibGUgdXNpbmcgYWxsb3dlZCBjbGlja3NcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiAhcGFuT25EcmFnLmluY2x1ZGVzKGV2ZW50LmJ1dHRvbikgJiYgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBvbmx5IGFsbG93IHJpZ2h0IGNsaWNrcyBpZiBwYW4gb24gZHJhZyBpcyBzZXQgdG8gcmlnaHQgY2xpY2tcbiAgICAgICAgY29uc3QgYnV0dG9uQWxsb3dlZCA9IChBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgcGFuT25EcmFnLmluY2x1ZGVzKGV2ZW50LmJ1dHRvbikpIHx8ICFldmVudC5idXR0b24gfHwgZXZlbnQuYnV0dG9uIDw9IDE7XG4gICAgICAgIC8vIGRlZmF1bHQgZmlsdGVyIGZvciBkMy16b29tXG4gICAgICAgIHJldHVybiAoIWV2ZW50LmN0cmxLZXkgfHwgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykgJiYgYnV0dG9uQWxsb3dlZDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBYWVBhblpvb20oeyBkb21Ob2RlLCBtaW5ab29tLCBtYXhab29tLCBwYW5lQ2xpY2tEaXN0YW5jZSwgdHJhbnNsYXRlRXh0ZW50LCB2aWV3cG9ydCwgb25QYW5ab29tLCBvblBhblpvb21TdGFydCwgb25QYW5ab29tRW5kLCBvbkRyYWdnaW5nQ2hhbmdlLCB9KSB7XG4gICAgY29uc3Qgem9vbVBhblZhbHVlcyA9IHtcbiAgICAgICAgaXNab29taW5nT3JQYW5uaW5nOiBmYWxzZSxcbiAgICAgICAgdXNlZFJpZ2h0TW91c2VCdXR0b246IGZhbHNlLFxuICAgICAgICBwcmV2Vmlld3BvcnQ6IHsgeDogMCwgeTogMCwgem9vbTogMCB9LFxuICAgICAgICBtb3VzZUJ1dHRvbjogMCxcbiAgICAgICAgdGltZXJJZDogdW5kZWZpbmVkLFxuICAgICAgICBwYW5TY3JvbGxUaW1lb3V0OiB1bmRlZmluZWQsXG4gICAgICAgIGlzUGFuU2Nyb2xsaW5nOiBmYWxzZSxcbiAgICB9O1xuICAgIGNvbnN0IGJib3ggPSBkb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGQzWm9vbUluc3RhbmNlID0gem9vbSgpXG4gICAgICAgIC5jbGlja0Rpc3RhbmNlKCFpc051bWVyaWMocGFuZUNsaWNrRGlzdGFuY2UpIHx8IHBhbmVDbGlja0Rpc3RhbmNlIDwgMCA/IDAgOiBwYW5lQ2xpY2tEaXN0YW5jZSlcbiAgICAgICAgLnNjYWxlRXh0ZW50KFttaW5ab29tLCBtYXhab29tXSlcbiAgICAgICAgLnRyYW5zbGF0ZUV4dGVudCh0cmFuc2xhdGVFeHRlbnQpO1xuICAgIGNvbnN0IGQzU2VsZWN0aW9uID0gc2VsZWN0KGRvbU5vZGUpLmNhbGwoZDNab29tSW5zdGFuY2UpO1xuICAgIHNldFZpZXdwb3J0Q29uc3RyYWluZWQoe1xuICAgICAgICB4OiB2aWV3cG9ydC54LFxuICAgICAgICB5OiB2aWV3cG9ydC55LFxuICAgICAgICB6b29tOiBjbGFtcCh2aWV3cG9ydC56b29tLCBtaW5ab29tLCBtYXhab29tKSxcbiAgICB9LCBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgW2Jib3gud2lkdGgsIGJib3guaGVpZ2h0XSxcbiAgICBdLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIGNvbnN0IGQzWm9vbUhhbmRsZXIgPSBkM1NlbGVjdGlvbi5vbignd2hlZWwuem9vbScpO1xuICAgIGNvbnN0IGQzRGJsQ2xpY2tab29tSGFuZGxlciA9IGQzU2VsZWN0aW9uLm9uKCdkYmxjbGljay56b29tJyk7XG4gICAgZDNab29tSW5zdGFuY2Uud2hlZWxEZWx0YSh3aGVlbERlbHRhKTtcbiAgICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0odHJhbnNmb3JtLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChkM1NlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgZDNab29tSW5zdGFuY2U/LnRyYW5zZm9ybShnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uLCAoKSA9PiByZXNvbHZlKHRydWUpKSwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICAvLyBwdWJsaWMgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gdXBkYXRlKHsgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIG9uUGFuZUNvbnRleHRNZW51LCB1c2VyU2VsZWN0aW9uQWN0aXZlLCBwYW5PblNjcm9sbCwgcGFuT25EcmFnLCBwYW5PblNjcm9sbE1vZGUsIHBhbk9uU2Nyb2xsU3BlZWQsIHByZXZlbnRTY3JvbGxpbmcsIHpvb21PblBpbmNoLCB6b29tT25TY3JvbGwsIHpvb21PbkRvdWJsZUNsaWNrLCB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsIGxpYiwgb25UcmFuc2Zvcm1DaGFuZ2UsIH0pIHtcbiAgICAgICAgaWYgKHVzZXJTZWxlY3Rpb25BY3RpdmUgJiYgIXpvb21QYW5WYWx1ZXMuaXNab29taW5nT3JQYW5uaW5nKSB7XG4gICAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNQYW5PblNjcm9sbCA9IHBhbk9uU2Nyb2xsICYmICF6b29tQWN0aXZhdGlvbktleVByZXNzZWQgJiYgIXVzZXJTZWxlY3Rpb25BY3RpdmU7XG4gICAgICAgIGNvbnN0IHdoZWVsSGFuZGxlciA9IGlzUGFuT25TY3JvbGxcbiAgICAgICAgICAgID8gY3JlYXRlUGFuT25TY3JvbGxIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICB6b29tUGFuVmFsdWVzLFxuICAgICAgICAgICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgZDNTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgZDNab29tOiBkM1pvb21JbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBwYW5PblNjcm9sbE1vZGUsXG4gICAgICAgICAgICAgICAgcGFuT25TY3JvbGxTcGVlZCxcbiAgICAgICAgICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgICAgICAgICBvblBhblpvb21TdGFydCxcbiAgICAgICAgICAgICAgICBvblBhblpvb20sXG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogY3JlYXRlWm9vbU9uU2Nyb2xsSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsaW5nLFxuICAgICAgICAgICAgICAgIGQzWm9vbUhhbmRsZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgZDNTZWxlY3Rpb24ub24oJ3doZWVsLnpvb20nLCB3aGVlbEhhbmRsZXIsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgIGlmICghdXNlclNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgLy8gcGFuIHpvb20gc3RhcnRcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0SGFuZGxlciA9IGNyZWF0ZVBhblpvb21TdGFydEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMsXG4gICAgICAgICAgICAgICAgb25EcmFnZ2luZ0NoYW5nZSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21TdGFydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZDNab29tSW5zdGFuY2Uub24oJ3N0YXJ0Jywgc3RhcnRIYW5kbGVyKTtcbiAgICAgICAgICAgIC8vIHBhbiB6b29tXG4gICAgICAgICAgICBjb25zdCBwYW5ab29tSGFuZGxlciA9IGNyZWF0ZVBhblpvb21IYW5kbGVyKHtcbiAgICAgICAgICAgICAgICB6b29tUGFuVmFsdWVzLFxuICAgICAgICAgICAgICAgIHBhbk9uRHJhZyxcbiAgICAgICAgICAgICAgICBvblBhbmVDb250ZXh0TWVudTogISFvblBhbmVDb250ZXh0TWVudSxcbiAgICAgICAgICAgICAgICBvblBhblpvb20sXG4gICAgICAgICAgICAgICAgb25UcmFuc2Zvcm1DaGFuZ2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlLm9uKCd6b29tJywgcGFuWm9vbUhhbmRsZXIpO1xuICAgICAgICAgICAgLy8gcGFuIHpvb20gZW5kXG4gICAgICAgICAgICBjb25zdCBwYW5ab29tRW5kSGFuZGxlciA9IGNyZWF0ZVBhblpvb21FbmRIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICB6b29tUGFuVmFsdWVzLFxuICAgICAgICAgICAgICAgIHBhbk9uRHJhZyxcbiAgICAgICAgICAgICAgICBwYW5PblNjcm9sbCxcbiAgICAgICAgICAgICAgICBvblBhbmVDb250ZXh0TWVudSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21FbmQsXG4gICAgICAgICAgICAgICAgb25EcmFnZ2luZ0NoYW5nZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZDNab29tSW5zdGFuY2Uub24oJ2VuZCcsIHBhblpvb21FbmRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXIgPSBjcmVhdGVGaWx0ZXIoe1xuICAgICAgICAgICAgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLFxuICAgICAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICAgICAgem9vbU9uU2Nyb2xsLFxuICAgICAgICAgICAgcGFuT25TY3JvbGwsXG4gICAgICAgICAgICB6b29tT25Eb3VibGVDbGljayxcbiAgICAgICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICAgICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgICAgIGxpYixcbiAgICAgICAgfSk7XG4gICAgICAgIGQzWm9vbUluc3RhbmNlLmZpbHRlcihmaWx0ZXIpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBXZSBjYW5ub3QgYWRkIHpvb21PbkRvdWJsZUNsaWNrIHRvIHRoZSBmaWx0ZXIgYWJvdmUgYmVjYXVzZVxuICAgICAgICAgKiBkb3VibGUgdGFwcGluZyBvbiB0b3VjaCBzY3JlZW5zIGNpcmN1bXZlbnRzIHRoZSBmaWx0ZXIgYW5kXG4gICAgICAgICAqIGRibGNsaWNrLnpvb20gaXMgZmlyZWQgb24gdGhlIHNlbGVjdGlvbiBkaXJlY3RseVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHpvb21PbkRvdWJsZUNsaWNrKSB7XG4gICAgICAgICAgICBkM1NlbGVjdGlvbi5vbignZGJsY2xpY2suem9vbScsIGQzRGJsQ2xpY2tab29tSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkM1NlbGVjdGlvbi5vbignZGJsY2xpY2suem9vbScsIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGQzWm9vbUluc3RhbmNlLm9uKCd6b29tJywgbnVsbCk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNldFZpZXdwb3J0Q29uc3RyYWluZWQodmlld3BvcnQsIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSB7XG4gICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB2aWV3cG9ydFRvVHJhbnNmb3JtKHZpZXdwb3J0KTtcbiAgICAgICAgY29uc3QgY29udHJhaW5lZFRyYW5zZm9ybSA9IGQzWm9vbUluc3RhbmNlPy5jb25zdHJhaW4oKShuZXh0VHJhbnNmb3JtLCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgIGlmIChjb250cmFpbmVkVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBhd2FpdCBzZXRUcmFuc2Zvcm0oY29udHJhaW5lZFRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXNvbHZlKGNvbnRyYWluZWRUcmFuc2Zvcm0pKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2V0Vmlld3BvcnQodmlld3BvcnQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbmV4dFRyYW5zZm9ybSA9IHZpZXdwb3J0VG9UcmFuc2Zvcm0odmlld3BvcnQpO1xuICAgICAgICBhd2FpdCBzZXRUcmFuc2Zvcm0obmV4dFRyYW5zZm9ybSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVzb2x2ZShuZXh0VHJhbnNmb3JtKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN5bmNWaWV3cG9ydCh2aWV3cG9ydCkge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB2aWV3cG9ydFRvVHJhbnNmb3JtKHZpZXdwb3J0KTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBkM1NlbGVjdGlvbi5wcm9wZXJ0eSgnX196b29tJyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRyYW5zZm9ybS5rICE9PSB2aWV3cG9ydC56b29tIHx8XG4gICAgICAgICAgICAgICAgY3VycmVudFRyYW5zZm9ybS54ICE9PSB2aWV3cG9ydC54IHx8XG4gICAgICAgICAgICAgICAgY3VycmVudFRyYW5zZm9ybS55ICE9PSB2aWV3cG9ydC55KSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBkM1pvb21JbnN0YW5jZT8udHJhbnNmb3JtKGQzU2VsZWN0aW9uLCBuZXh0VHJhbnNmb3JtLCBudWxsLCB7IHN5bmM6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Vmlld3BvcnQoKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGQzU2VsZWN0aW9uID8gem9vbVRyYW5zZm9ybShkM1NlbGVjdGlvbi5ub2RlKCkpIDogeyB4OiAwLCB5OiAwLCBrOiAxIH07XG4gICAgICAgIHJldHVybiB7IHg6IHRyYW5zZm9ybS54LCB5OiB0cmFuc2Zvcm0ueSwgem9vbTogdHJhbnNmb3JtLmsgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGVUbyh6b29tLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChkM1NlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgZDNab29tSW5zdGFuY2U/LnNjYWxlVG8oZ2V0RDNUcmFuc2l0aW9uKGQzU2VsZWN0aW9uLCBvcHRpb25zPy5kdXJhdGlvbiwgKCkgPT4gcmVzb2x2ZSh0cnVlKSksIHpvb20pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlQnkoZmFjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChkM1NlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgZDNab29tSW5zdGFuY2U/LnNjYWxlQnkoZ2V0RDNUcmFuc2l0aW9uKGQzU2VsZWN0aW9uLCBvcHRpb25zPy5kdXJhdGlvbiwgKCkgPT4gcmVzb2x2ZSh0cnVlKSksIGZhY3Rvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0U2NhbGVFeHRlbnQoc2NhbGVFeHRlbnQpIHtcbiAgICAgICAgZDNab29tSW5zdGFuY2U/LnNjYWxlRXh0ZW50KHNjYWxlRXh0ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCkge1xuICAgICAgICBkM1pvb21JbnN0YW5jZT8udHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldENsaWNrRGlzdGFuY2UoZGlzdGFuY2UpIHtcbiAgICAgICAgY29uc3QgdmFsaWREaXN0YW5jZSA9ICFpc051bWVyaWMoZGlzdGFuY2UpIHx8IGRpc3RhbmNlIDwgMCA/IDAgOiBkaXN0YW5jZTtcbiAgICAgICAgZDNab29tSW5zdGFuY2U/LmNsaWNrRGlzdGFuY2UodmFsaWREaXN0YW5jZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICAgICAgc2V0Vmlld3BvcnQsXG4gICAgICAgIHNldFZpZXdwb3J0Q29uc3RyYWluZWQsXG4gICAgICAgIGdldFZpZXdwb3J0LFxuICAgICAgICBzY2FsZVRvLFxuICAgICAgICBzY2FsZUJ5LFxuICAgICAgICBzZXRTY2FsZUV4dGVudCxcbiAgICAgICAgc2V0VHJhbnNsYXRlRXh0ZW50LFxuICAgICAgICBzeW5jVmlld3BvcnQsXG4gICAgICAgIHNldENsaWNrRGlzdGFuY2UsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIGRldGVybWluZSB0aGUgdmFyaWFudCBvZiB0aGUgcmVzaXplIGNvbnRyb2xcbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZXNpemVDb250cm9sVmFyaWFudDtcbihmdW5jdGlvbiAoUmVzaXplQ29udHJvbFZhcmlhbnQpIHtcbiAgICBSZXNpemVDb250cm9sVmFyaWFudFtcIkxpbmVcIl0gPSBcImxpbmVcIjtcbiAgICBSZXNpemVDb250cm9sVmFyaWFudFtcIkhhbmRsZVwiXSA9IFwiaGFuZGxlXCI7XG59KShSZXNpemVDb250cm9sVmFyaWFudCB8fCAoUmVzaXplQ29udHJvbFZhcmlhbnQgPSB7fSkpO1xuY29uc3QgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TID0gWyd0b3AtbGVmdCcsICd0b3AtcmlnaHQnLCAnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0J107XG5jb25zdCBYWV9SRVNJWkVSX0xJTkVfUE9TSVRJT05TID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcblxuLyoqXG4gKiBHZXQgYWxsIGNvbm5lY3RpbmcgZWRnZXMgZm9yIGEgZ2l2ZW4gc2V0IG9mIG5vZGVzXG4gKiBAcGFyYW0gd2lkdGggLSBuZXcgd2lkdGggb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBwcmV2V2lkdGggLSBwcmV2aW91cyB3aWR0aCBvZiB0aGUgbm9kZVxuICogQHBhcmFtIGhlaWdodCAtIG5ldyBoZWlnaHQgb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBwcmV2SGVpZ2h0IC0gcHJldmlvdXMgaGVpZ2h0IG9mIHRoZSBub2RlXG4gKiBAcGFyYW0gYWZmZWN0c1ggLSB3aGV0aGVyIHRvIGludmVydCB0aGUgcmVzaXplIGRpcmVjdGlvbiBmb3IgdGhlIHggYXhpc1xuICogQHBhcmFtIGFmZmVjdHNZIC0gd2hldGhlciB0byBpbnZlcnQgdGhlIHJlc2l6ZSBkaXJlY3Rpb24gZm9yIHRoZSB5IGF4aXNcbiAqIEByZXR1cm5zIGFycmF5IG9mIHR3byBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSByZXNpemUgZm9yIGVhY2ggYXhpcywgMCA9IG5vIGNoYW5nZSwgMSA9IGluY3JlYXNlLCAtMSA9IGRlY3JlYXNlXG4gKi9cbmZ1bmN0aW9uIGdldFJlc2l6ZURpcmVjdGlvbih7IHdpZHRoLCBwcmV2V2lkdGgsIGhlaWdodCwgcHJldkhlaWdodCwgYWZmZWN0c1gsIGFmZmVjdHNZLCB9KSB7XG4gICAgY29uc3QgZGVsdGFXaWR0aCA9IHdpZHRoIC0gcHJldldpZHRoO1xuICAgIGNvbnN0IGRlbHRhSGVpZ2h0ID0gaGVpZ2h0IC0gcHJldkhlaWdodDtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBbZGVsdGFXaWR0aCA+IDAgPyAxIDogZGVsdGFXaWR0aCA8IDAgPyAtMSA6IDAsIGRlbHRhSGVpZ2h0ID4gMCA/IDEgOiBkZWx0YUhlaWdodCA8IDAgPyAtMSA6IDBdO1xuICAgIGlmIChkZWx0YVdpZHRoICYmIGFmZmVjdHNYKSB7XG4gICAgICAgIGRpcmVjdGlvblswXSA9IGRpcmVjdGlvblswXSAqIC0xO1xuICAgIH1cbiAgICBpZiAoZGVsdGFIZWlnaHQgJiYgYWZmZWN0c1kpIHtcbiAgICAgICAgZGlyZWN0aW9uWzFdID0gZGlyZWN0aW9uWzFdICogLTE7XG4gICAgfVxuICAgIHJldHVybiBkaXJlY3Rpb247XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgY29udHJvbCBwb3NpdGlvbiB0aGF0IGlzIGJlaW5nIGRyYWdnZWQgdG8gZGltZW5zaW9ucyB0aGF0IGFyZSBiZWluZyByZXNpemVkXG4gKiBAcGFyYW0gY29udHJvbFBvc2l0aW9uIC0gcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgdGhhdCBpcyBiZWluZyBkcmFnZ2VkXG4gKiBAcmV0dXJucyBpc0hvcml6b250YWwsIGlzVmVydGljYWwsIGFmZmVjdHNYLCBhZmZlY3RzWSxcbiAqL1xuZnVuY3Rpb24gZ2V0Q29udHJvbERpcmVjdGlvbihjb250cm9sUG9zaXRpb24pIHtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ3JpZ2h0JykgfHwgY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCdsZWZ0Jyk7XG4gICAgY29uc3QgaXNWZXJ0aWNhbCA9IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygnYm90dG9tJykgfHwgY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCd0b3AnKTtcbiAgICBjb25zdCBhZmZlY3RzWCA9IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygnbGVmdCcpO1xuICAgIGNvbnN0IGFmZmVjdHNZID0gY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCd0b3AnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0hvcml6b250YWwsXG4gICAgICAgIGlzVmVydGljYWwsXG4gICAgICAgIGFmZmVjdHNYLFxuICAgICAgICBhZmZlY3RzWSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0TG93ZXJFeHRlbnRDbGFtcChsb3dlckV4dGVudCwgbG93ZXJCb3VuZCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBsb3dlckJvdW5kIC0gbG93ZXJFeHRlbnQpO1xufVxuZnVuY3Rpb24gZ2V0VXBwZXJFeHRlbnRDbGFtcCh1cHBlckV4dGVudCwgdXBwZXJCb3VuZCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCB1cHBlckV4dGVudCAtIHVwcGVyQm91bmQpO1xufVxuZnVuY3Rpb24gZ2V0U2l6ZUNsYW1wKHNpemUsIG1pblNpemUsIG1heFNpemUpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbWluU2l6ZSAtIHNpemUsIHNpemUgLSBtYXhTaXplKTtcbn1cbmZ1bmN0aW9uIHhvcihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPyAhYiA6IGI7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgbmV3IHdpZHRoICYgaGVpZ2h0IGFuZCB4ICYgeSBvZiBub2RlIGFmdGVyIHJlc2l6ZSBiYXNlZCBvbiBwb2ludGVyIHBvc2l0aW9uXG4gKiBAZGVzY3JpcHRpb24gLSBCdWNrbGUgdXAsIHRoaXMgaXMgYSBjaHVua3kgb25lLi4uIElmIHlvdSB3YW50IHRvIGRldGVybWluZSB0aGUgbmV3IGRpbWVuc2lvbnMgb2YgYSBub2RlIGFmdGVyIGEgcmVzaXplLFxuICogeW91IGhhdmUgdG8gYWNjb3VudCBmb3IgYWxsIHBvc3NpYmxlIHJlc3RyaWN0aW9uczogbWluL21heCB3aWR0aC9oZWlnaHQgb2YgdGhlIG5vZGUsIHRoZSBtYXhpbXVtIGV4dGVudCB0aGUgbm9kZSBpcyBhbGxvd2VkXG4gKiB0byBtb3ZlIGluIChpbiB0aGlzIGNhc2U6IHJlc2l6ZSBpbnRvKSBkZXRlcm1pbmVkIGJ5IHRoZSBwYXJlbnQgbm9kZSwgdGhlIG1pbmltYWwgZXh0ZW50IGRldGVybWluZWQgYnkgY2hpbGQgbm9kZXNcbiAqIHdpdGggZXhwYW5kUGFyZW50IG9yIGV4dGVudDogJ3BhcmVudCcgc2V0IGFuZCBvaCB5ZWFoLCB0aGVzZSB0aGluZ3MgYWxzbyBoYXZlIHRvIHdvcmsgd2l0aCBrZWVwQXNwZWN0UmF0aW8hXG4gKiBUaGUgd2F5IHRoaXMgaXMgZG9uZSBpcyBieSBkZXRlcm1pbmluZyBob3cgbXVjaCBlYWNoIG9mIHRoZXNlIHJlc3RyaWN0aW5nIGFjdHVhbGx5IHJlc3RyaWN0cyB0aGUgcmVzaXplIGFuZCB0aGVuIGFwcGx5aW5nIHRoZVxuICogc3Ryb25nZXN0IHJlc3RyaWN0aW9uLiBCZWNhdXNlIHRoZSByZXNpemUgYWZmZWN0cyB4LCB5IGFuZCB3aWR0aCwgaGVpZ2h0IGFuZCB3aWR0aCwgaGVpZ2h0IG9mIGEgb3Bwb3Npbmcgc2lkZSB3aXRoIGtlZXBBc3BlY3RSYXRpbyxcbiAqIHRoZSByZXNpemUgYW1vdW50IGlzIGFsd2F5cyBrZXB0IGluIGRpc3RYICYgZGlzdFkgYW1vdW50ICh0aGUgZGlzdGFuY2UgaW4gbW91c2UgbW92ZW1lbnQpXG4gKiBJbnN0ZWFkIG9mIGNsYW1waW5nIGVhY2ggdmFsdWUsIHdlIGZpcnN0IGNhbGN1bGF0ZSB0aGUgYmlnZ2VzdCAnY2xhbXAnIChmb3IgdGhlIGxhY2sgb2YgYSBiZXR0ZXIgbmFtZSkgYW5kIHRoZW4gYXBwbHkgaXQgdG8gYWxsIHZhbHVlcy5cbiAqIFRvIGNvbXBsaWNhdGUgdGhpbmdzIG5vZGVPcmlnaW4gaGFzIHRvIGJlIHRha2VuIGludG8gYWNjb3VudCBhcyB3ZWxsLiBUaGlzIGlzIGRvbmUgYnkgb2Zmc2V0dGluZyB0aGUgbm9kZXMgYXMgaWYgdGhlaXIgb3JpZ2luIGlzIFswLCAwXSxcbiAqIHRoZW4gY2FsY3VsYXRpbmcgdGhlIHJlc3RyaWN0aW9ucyBhcyB1c3VhbFxuICogQHBhcmFtIHN0YXJ0VmFsdWVzIC0gc3RhcnRpbmcgdmFsdWVzIG9mIHJlc2l6ZVxuICogQHBhcmFtIGNvbnRyb2xEaXJlY3Rpb24gLSBkaW1lbnNpb25zIGFmZmVjdGVkIGJ5IHRoZSByZXNpemVcbiAqIEBwYXJhbSBwb2ludGVyUG9zaXRpb24gLSB0aGUgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGNvcnJlY3RlZCBmb3Igc25hcHBpbmdcbiAqIEBwYXJhbSBib3VuZGFyaWVzIC0gbWluaW11bSBhbmQgbWF4aW11bSBkaW1lbnNpb25zIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0ga2VlcEFzcGVjdFJhdGlvIC0gcHJldmVudCBjaGFuZ2VzIG9mIGFzcHJlY3QgcmF0aW9cbiAqIEByZXR1cm5zIHgsIHksIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIG5vZGUgYWZ0ZXIgcmVzaXplXG4gKi9cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnNBZnRlclJlc2l6ZShzdGFydFZhbHVlcywgY29udHJvbERpcmVjdGlvbiwgcG9pbnRlclBvc2l0aW9uLCBib3VuZGFyaWVzLCBrZWVwQXNwZWN0UmF0aW8sIG5vZGVPcmlnaW4sIGV4dGVudCwgY2hpbGRFeHRlbnQpIHtcbiAgICBsZXQgeyBhZmZlY3RzWCwgYWZmZWN0c1kgfSA9IGNvbnRyb2xEaXJlY3Rpb247XG4gICAgY29uc3QgeyBpc0hvcml6b250YWwsIGlzVmVydGljYWwgfSA9IGNvbnRyb2xEaXJlY3Rpb247XG4gICAgY29uc3QgaXNEaWFnb25hbCA9IGlzSG9yaXpvbnRhbCAmJiBpc1ZlcnRpY2FsO1xuICAgIGNvbnN0IHsgeFNuYXBwZWQsIHlTbmFwcGVkIH0gPSBwb2ludGVyUG9zaXRpb247XG4gICAgY29uc3QgeyBtaW5XaWR0aCwgbWF4V2lkdGgsIG1pbkhlaWdodCwgbWF4SGVpZ2h0IH0gPSBib3VuZGFyaWVzO1xuICAgIGNvbnN0IHsgeDogc3RhcnRYLCB5OiBzdGFydFksIHdpZHRoOiBzdGFydFdpZHRoLCBoZWlnaHQ6IHN0YXJ0SGVpZ2h0LCBhc3BlY3RSYXRpbyB9ID0gc3RhcnRWYWx1ZXM7XG4gICAgbGV0IGRpc3RYID0gTWF0aC5mbG9vcihpc0hvcml6b250YWwgPyB4U25hcHBlZCAtIHN0YXJ0VmFsdWVzLnBvaW50ZXJYIDogMCk7XG4gICAgbGV0IGRpc3RZID0gTWF0aC5mbG9vcihpc1ZlcnRpY2FsID8geVNuYXBwZWQgLSBzdGFydFZhbHVlcy5wb2ludGVyWSA6IDApO1xuICAgIGNvbnN0IG5ld1dpZHRoID0gc3RhcnRXaWR0aCArIChhZmZlY3RzWCA/IC1kaXN0WCA6IGRpc3RYKTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSBzdGFydEhlaWdodCArIChhZmZlY3RzWSA/IC1kaXN0WSA6IGRpc3RZKTtcbiAgICBjb25zdCBvcmlnaW5PZmZzZXRYID0gLW5vZGVPcmlnaW5bMF0gKiBzdGFydFdpZHRoO1xuICAgIGNvbnN0IG9yaWdpbk9mZnNldFkgPSAtbm9kZU9yaWdpblsxXSAqIHN0YXJ0SGVpZ2h0O1xuICAgIC8vIENoZWNrIGlmIG1heFdpZHRoLCBtaW5XV2lkdGgsIG1heEhlaWdodCwgbWluSGVpZ2h0IGFyZSByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgbGV0IGNsYW1wWCA9IGdldFNpemVDbGFtcChuZXdXaWR0aCwgbWluV2lkdGgsIG1heFdpZHRoKTtcbiAgICBsZXQgY2xhbXBZID0gZ2V0U2l6ZUNsYW1wKG5ld0hlaWdodCwgbWluSGVpZ2h0LCBtYXhIZWlnaHQpO1xuICAgIC8vIENoZWNrIGlmIGV4dGVudCBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgaWYgKGV4dGVudCkge1xuICAgICAgICBsZXQgeEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgbGV0IHlFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgIGlmIChhZmZlY3RzWCAmJiBkaXN0WCA8IDApIHtcbiAgICAgICAgICAgIHhFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgZGlzdFggKyBvcmlnaW5PZmZzZXRYLCBleHRlbnRbMF1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhZmZlY3RzWCAmJiBkaXN0WCA+IDApIHtcbiAgICAgICAgICAgIHhFeHRlbnRDbGFtcCA9IGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRYICsgbmV3V2lkdGggKyBvcmlnaW5PZmZzZXRYLCBleHRlbnRbMV1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZmZlY3RzWSAmJiBkaXN0WSA8IDApIHtcbiAgICAgICAgICAgIHlFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRZICsgZGlzdFkgKyBvcmlnaW5PZmZzZXRZLCBleHRlbnRbMF1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhZmZlY3RzWSAmJiBkaXN0WSA+IDApIHtcbiAgICAgICAgICAgIHlFeHRlbnRDbGFtcCA9IGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgbmV3SGVpZ2h0ICsgb3JpZ2luT2Zmc2V0WSwgZXh0ZW50WzFdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIHhFeHRlbnRDbGFtcCk7XG4gICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgeUV4dGVudENsYW1wKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkIGV4dGVudCBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgaWYgKGNoaWxkRXh0ZW50KSB7XG4gICAgICAgIGxldCB4RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICBsZXQgeUV4dGVudENsYW1wID0gMDtcbiAgICAgICAgaWYgKGFmZmVjdHNYICYmIGRpc3RYID4gMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyBkaXN0WCwgY2hpbGRFeHRlbnRbMF1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhZmZlY3RzWCAmJiBkaXN0WCA8IDApIHtcbiAgICAgICAgICAgIHhFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgbmV3V2lkdGgsIGNoaWxkRXh0ZW50WzFdWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZmZWN0c1kgJiYgZGlzdFkgPiAwKSB7XG4gICAgICAgICAgICB5RXh0ZW50Q2xhbXAgPSBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WSArIGRpc3RZLCBjaGlsZEV4dGVudFswXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNZICYmIGRpc3RZIDwgMCkge1xuICAgICAgICAgICAgeUV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBuZXdIZWlnaHQsIGNoaWxkRXh0ZW50WzFdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIHhFeHRlbnRDbGFtcCk7XG4gICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgeUV4dGVudENsYW1wKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGFzcGVjdCByYXRpbyByZXNpemluZyBvZiB0aGUgb3RoZXIgc2lkZSBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgaWYgKGtlZXBBc3BlY3RSYXRpbykge1xuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbWF4IGRpbWVuc2lvbnMgbWlnaHQgYmUgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgICAgICAgICAgY29uc3QgYXNwZWN0SGVpZ2h0Q2xhbXAgPSBnZXRTaXplQ2xhbXAobmV3V2lkdGggLyBhc3BlY3RSYXRpbywgbWluSGVpZ2h0LCBtYXhIZWlnaHQpICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIGFzcGVjdEhlaWdodENsYW1wKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBleHRlbnQgaXMgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgICAgICAgICAgaWYgKGV4dGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBhc3BlY3RFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCghYWZmZWN0c1ggJiYgIWFmZmVjdHNZKSB8fCAoYWZmZWN0c1ggJiYgIWFmZmVjdHNZICYmIGlzRGlhZ29uYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgb3JpZ2luT2Zmc2V0WSArIG5ld1dpZHRoIC8gYXNwZWN0UmF0aW8sIGV4dGVudFsxXVsxXSkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRZICsgb3JpZ2luT2Zmc2V0WSArIChhZmZlY3RzWCA/IGRpc3RYIDogLWRpc3RYKSAvIGFzcGVjdFJhdGlvLCBleHRlbnRbMF1bMV0pICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhbXBYID0gTWF0aC5tYXgoY2xhbXBYLCBhc3BlY3RFeHRlbnRDbGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY2hpbGQgZXh0ZW50IGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICAgICAgICAgIGlmIChjaGlsZEV4dGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBhc3BlY3RFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCghYWZmZWN0c1ggJiYgIWFmZmVjdHNZKSB8fCAoYWZmZWN0c1ggJiYgIWFmZmVjdHNZICYmIGlzRGlhZ29uYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBuZXdXaWR0aCAvIGFzcGVjdFJhdGlvLCBjaGlsZEV4dGVudFsxXVsxXSkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgKGFmZmVjdHNYID8gZGlzdFggOiAtZGlzdFgpIC8gYXNwZWN0UmF0aW8sIGNoaWxkRXh0ZW50WzBdWzFdKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIGFzcGVjdEV4dGVudENsYW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB0aGUgc2FtZSB0aGluZyBmb3IgdmVydGljYWwgcmVzaXppbmdcbiAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGFzcGVjdFdpZHRoQ2xhbXAgPSBnZXRTaXplQ2xhbXAobmV3SGVpZ2h0ICogYXNwZWN0UmF0aW8sIG1pbldpZHRoLCBtYXhXaWR0aCkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgYXNwZWN0V2lkdGhDbGFtcCk7XG4gICAgICAgICAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFzcGVjdEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoKCFhZmZlY3RzWCAmJiAhYWZmZWN0c1kpIHx8IChhZmZlY3RzWSAmJiAhYWZmZWN0c1ggJiYgaXNEaWFnb25hbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbyArIG9yaWdpbk9mZnNldFgsIGV4dGVudFsxXVswXSkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgKGFmZmVjdHNZID8gZGlzdFkgOiAtZGlzdFkpICogYXNwZWN0UmF0aW8gKyBvcmlnaW5PZmZzZXRYLCBleHRlbnRbMF1bMF0pIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCBhc3BlY3RFeHRlbnRDbGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGRFeHRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXNwZWN0RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICAgICAgICAgIGlmICgoIWFmZmVjdHNYICYmICFhZmZlY3RzWSkgfHwgKGFmZmVjdHNZICYmICFhZmZlY3RzWCAmJiBpc0RpYWdvbmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgbmV3SGVpZ2h0ICogYXNwZWN0UmF0aW8sIGNoaWxkRXh0ZW50WzFdWzBdKSAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyAoYWZmZWN0c1kgPyBkaXN0WSA6IC1kaXN0WSkgKiBhc3BlY3RSYXRpbywgY2hpbGRFeHRlbnRbMF1bMF0pIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgYXNwZWN0RXh0ZW50Q2xhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3RZID0gZGlzdFkgKyAoZGlzdFkgPCAwID8gY2xhbXBZIDogLWNsYW1wWSk7XG4gICAgZGlzdFggPSBkaXN0WCArIChkaXN0WCA8IDAgPyBjbGFtcFggOiAtY2xhbXBYKTtcbiAgICBpZiAoa2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICAgIGlmIChpc0RpYWdvbmFsKSB7XG4gICAgICAgICAgICBpZiAobmV3V2lkdGggPiBuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIGRpc3RZID0gKHhvcihhZmZlY3RzWCwgYWZmZWN0c1kpID8gLWRpc3RYIDogZGlzdFgpIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXN0WCA9ICh4b3IoYWZmZWN0c1gsIGFmZmVjdHNZKSA/IC1kaXN0WSA6IGRpc3RZKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGRpc3RZID0gZGlzdFggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICBhZmZlY3RzWSA9IGFmZmVjdHNYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzdFggPSBkaXN0WSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIGFmZmVjdHNYID0gYWZmZWN0c1k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeCA9IGFmZmVjdHNYID8gc3RhcnRYICsgZGlzdFggOiBzdGFydFg7XG4gICAgY29uc3QgeSA9IGFmZmVjdHNZID8gc3RhcnRZICsgZGlzdFkgOiBzdGFydFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHN0YXJ0V2lkdGggKyAoYWZmZWN0c1ggPyAtZGlzdFggOiBkaXN0WCksXG4gICAgICAgIGhlaWdodDogc3RhcnRIZWlnaHQgKyAoYWZmZWN0c1kgPyAtZGlzdFkgOiBkaXN0WSksXG4gICAgICAgIHg6IG5vZGVPcmlnaW5bMF0gKiBkaXN0WCAqICghYWZmZWN0c1ggPyAxIDogLTEpICsgeCxcbiAgICAgICAgeTogbm9kZU9yaWdpblsxXSAqIGRpc3RZICogKCFhZmZlY3RzWSA/IDEgOiAtMSkgKyB5LFxuICAgIH07XG59XG5cbmNvbnN0IGluaXRQcmV2VmFsdWVzID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwLCB4OiAwLCB5OiAwIH07XG5jb25zdCBpbml0U3RhcnRWYWx1ZXMgPSB7XG4gICAgLi4uaW5pdFByZXZWYWx1ZXMsXG4gICAgcG9pbnRlclg6IDAsXG4gICAgcG9pbnRlclk6IDAsXG4gICAgYXNwZWN0UmF0aW86IDEsXG59O1xuZnVuY3Rpb24gbm9kZVRvUGFyZW50RXh0ZW50KG5vZGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFtub2RlLm1lYXN1cmVkLndpZHRoLCBub2RlLm1lYXN1cmVkLmhlaWdodF0sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG5vZGVUb0NoaWxkRXh0ZW50KGNoaWxkLCBwYXJlbnQsIG5vZGVPcmlnaW4pIHtcbiAgICBjb25zdCB4ID0gcGFyZW50LnBvc2l0aW9uLnggKyBjaGlsZC5wb3NpdGlvbi54O1xuICAgIGNvbnN0IHkgPSBwYXJlbnQucG9zaXRpb24ueSArIGNoaWxkLnBvc2l0aW9uLnk7XG4gICAgY29uc3Qgd2lkdGggPSBjaGlsZC5tZWFzdXJlZC53aWR0aCA/PyAwO1xuICAgIGNvbnN0IGhlaWdodCA9IGNoaWxkLm1lYXN1cmVkLmhlaWdodCA/PyAwO1xuICAgIGNvbnN0IG9yaWdpbk9mZnNldFggPSBub2RlT3JpZ2luWzBdICogd2lkdGg7XG4gICAgY29uc3Qgb3JpZ2luT2Zmc2V0WSA9IG5vZGVPcmlnaW5bMV0gKiBoZWlnaHQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgW3ggLSBvcmlnaW5PZmZzZXRYLCB5IC0gb3JpZ2luT2Zmc2V0WV0sXG4gICAgICAgIFt4ICsgd2lkdGggLSBvcmlnaW5PZmZzZXRYLCB5ICsgaGVpZ2h0IC0gb3JpZ2luT2Zmc2V0WV0sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIFhZUmVzaXplcih7IGRvbU5vZGUsIG5vZGVJZCwgZ2V0U3RvcmVJdGVtcywgb25DaGFuZ2UsIG9uRW5kIH0pIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBzZWxlY3QoZG9tTm9kZSk7XG4gICAgZnVuY3Rpb24gdXBkYXRlKHsgY29udHJvbFBvc2l0aW9uLCBib3VuZGFyaWVzLCBrZWVwQXNwZWN0UmF0aW8sIHJlc2l6ZURpcmVjdGlvbiwgb25SZXNpemVTdGFydCwgb25SZXNpemUsIG9uUmVzaXplRW5kLCBzaG91bGRSZXNpemUsIH0pIHtcbiAgICAgICAgbGV0IHByZXZWYWx1ZXMgPSB7IC4uLmluaXRQcmV2VmFsdWVzIH07XG4gICAgICAgIGxldCBzdGFydFZhbHVlcyA9IHsgLi4uaW5pdFN0YXJ0VmFsdWVzIH07XG4gICAgICAgIGNvbnN0IGNvbnRyb2xEaXJlY3Rpb24gPSBnZXRDb250cm9sRGlyZWN0aW9uKGNvbnRyb2xQb3NpdGlvbik7XG4gICAgICAgIGxldCBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY29udGFpbmVyQm91bmRzID0gbnVsbDtcbiAgICAgICAgbGV0IGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSB1bmRlZmluZWQ7IC8vIE5lZWRlZCB0byBmaXggZXhwYW5kUGFyZW50XG4gICAgICAgIGxldCBwYXJlbnRFeHRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjaGlsZEV4dGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZHJhZ0hhbmRsZXIgPSBkcmFnKClcbiAgICAgICAgICAgIC5vbignc3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgcGFuZURvbU5vZGUgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyQm91bmRzID0gcGFuZURvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpID8/IG51bGw7XG4gICAgICAgICAgICBjb25zdCB7IHhTbmFwcGVkLCB5U25hcHBlZCB9ID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIHNuYXBHcmlkLFxuICAgICAgICAgICAgICAgIHNuYXBUb0dyaWQsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyQm91bmRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcmV2VmFsdWVzID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBub2RlLm1lYXN1cmVkLndpZHRoID8/IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlLm1lYXN1cmVkLmhlaWdodCA/PyAwLFxuICAgICAgICAgICAgICAgIHg6IG5vZGUucG9zaXRpb24ueCA/PyAwLFxuICAgICAgICAgICAgICAgIHk6IG5vZGUucG9zaXRpb24ueSA/PyAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0ge1xuICAgICAgICAgICAgICAgIC4uLnByZXZWYWx1ZXMsXG4gICAgICAgICAgICAgICAgcG9pbnRlclg6IHhTbmFwcGVkLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJZOiB5U25hcHBlZCxcbiAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbzogcHJldlZhbHVlcy53aWR0aCAvIHByZXZWYWx1ZXMuaGVpZ2h0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCAmJiAobm9kZS5leHRlbnQgPT09ICdwYXJlbnQnIHx8IG5vZGUuZXhwYW5kUGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBub2RlTG9va3VwLmdldChub2RlLnBhcmVudElkKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRFeHRlbnQgPSBwYXJlbnROb2RlICYmIG5vZGUuZXh0ZW50ID09PSAncGFyZW50JyA/IG5vZGVUb1BhcmVudEV4dGVudChwYXJlbnROb2RlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBDb2xsZWN0IGFsbCBjaGlsZCBub2RlcyB0byBjb3JyZWN0IHRoZWlyIHJlbGF0aXZlIHBvc2l0aW9ucyB3aGVuIHRvcC9sZWZ0IGNoYW5nZXNcbiAgICAgICAgICAgICAqIERldGVybWluZSBsYXJnZXN0IG1pbmltYWwgZXh0ZW50IHRoZSBwYXJlbnQgbm9kZSBpcyBhbGxvd2VkIHRvIHJlc2l6ZSB0b1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjaGlsZE5vZGVzID0gW107XG4gICAgICAgICAgICBjaGlsZEV4dGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2NoaWxkSWQsIGNoaWxkXSBvZiBub2RlTG9va3VwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudElkID09PSBub2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaGlsZElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHsgLi4uY2hpbGQucG9zaXRpb24gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudDogY2hpbGQuZXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmV4dGVudCA9PT0gJ3BhcmVudCcgfHwgY2hpbGQuZXhwYW5kUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRlbnQgPSBub2RlVG9DaGlsZEV4dGVudChjaGlsZCwgbm9kZSwgY2hpbGQub3JpZ2luID8/IG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtNYXRoLm1pbihleHRlbnRbMF1bMF0sIGNoaWxkRXh0ZW50WzBdWzBdKSwgTWF0aC5taW4oZXh0ZW50WzBdWzFdLCBjaGlsZEV4dGVudFswXVsxXSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbTWF0aC5tYXgoZXh0ZW50WzFdWzBdLCBjaGlsZEV4dGVudFsxXVswXSksIE1hdGgubWF4KGV4dGVudFsxXVsxXSwgY2hpbGRFeHRlbnRbMV1bMV0pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRFeHRlbnQgPSBleHRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvblJlc2l6ZVN0YXJ0Py4oZXZlbnQsIHsgLi4ucHJldlZhbHVlcyB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZHJhZycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlT3JpZ2luOiBzdG9yZU5vZGVPcmlnaW4gfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3NpdGlvbiA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICAgICAgICBzbmFwVG9HcmlkLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckJvdW5kcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDaGFuZ2VzID0gW107XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHg6IHByZXZYLCB5OiBwcmV2WSwgd2lkdGg6IHByZXZXaWR0aCwgaGVpZ2h0OiBwcmV2SGVpZ2h0IH0gPSBwcmV2VmFsdWVzO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlID0ge307XG4gICAgICAgICAgICBjb25zdCBub2RlT3JpZ2luID0gbm9kZS5vcmlnaW4gPz8gc3RvcmVOb2RlT3JpZ2luO1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB4LCB5IH0gPSBnZXREaW1lbnNpb25zQWZ0ZXJSZXNpemUoc3RhcnRWYWx1ZXMsIGNvbnRyb2xEaXJlY3Rpb24sIHBvaW50ZXJQb3NpdGlvbiwgYm91bmRhcmllcywga2VlcEFzcGVjdFJhdGlvLCBub2RlT3JpZ2luLCBwYXJlbnRFeHRlbnQsIGNoaWxkRXh0ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGlzV2lkdGhDaGFuZ2UgPSB3aWR0aCAhPT0gcHJldldpZHRoO1xuICAgICAgICAgICAgY29uc3QgaXNIZWlnaHRDaGFuZ2UgPSBoZWlnaHQgIT09IHByZXZIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBpc1hQb3NDaGFuZ2UgPSB4ICE9PSBwcmV2WCAmJiBpc1dpZHRoQ2hhbmdlO1xuICAgICAgICAgICAgY29uc3QgaXNZUG9zQ2hhbmdlID0geSAhPT0gcHJldlkgJiYgaXNIZWlnaHRDaGFuZ2U7XG4gICAgICAgICAgICBpZiAoIWlzWFBvc0NoYW5nZSAmJiAhaXNZUG9zQ2hhbmdlICYmICFpc1dpZHRoQ2hhbmdlICYmICFpc0hlaWdodENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1hQb3NDaGFuZ2UgfHwgaXNZUG9zQ2hhbmdlIHx8IG5vZGVPcmlnaW5bMF0gPT09IDEgfHwgbm9kZU9yaWdpblsxXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZS54ID0gaXNYUG9zQ2hhbmdlID8geCA6IHByZXZWYWx1ZXMueDtcbiAgICAgICAgICAgICAgICBjaGFuZ2UueSA9IGlzWVBvc0NoYW5nZSA/IHkgOiBwcmV2VmFsdWVzLnk7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy54ID0gY2hhbmdlLng7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy55ID0gY2hhbmdlLnk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB3aGVuIHRvcC9sZWZ0IGNoYW5nZXMsIGNvcnJlY3QgdGhlIHJlbGF0aXZlIHBvc2l0aW9ucyBvZiBjaGlsZCBub2Rlc1xuICAgICAgICAgICAgICAgICAqIHNvIHRoYXQgdGhleSBzdGF5IGluIHRoZSBzYW1lIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4Q2hhbmdlID0geCAtIHByZXZYO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5Q2hhbmdlID0geSAtIHByZXZZO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkTm9kZSBvZiBjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2hpbGROb2RlLnBvc2l0aW9uLnggLSB4Q2hhbmdlICsgbm9kZU9yaWdpblswXSAqICh3aWR0aCAtIHByZXZXaWR0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY2hpbGROb2RlLnBvc2l0aW9uLnkgLSB5Q2hhbmdlICsgbm9kZU9yaWdpblsxXSAqIChoZWlnaHQgLSBwcmV2SGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZENoYW5nZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzV2lkdGhDaGFuZ2UgfHwgaXNIZWlnaHRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2Uud2lkdGggPVxuICAgICAgICAgICAgICAgICAgICBpc1dpZHRoQ2hhbmdlICYmICghcmVzaXplRGlyZWN0aW9uIHx8IHJlc2l6ZURpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSA/IHdpZHRoIDogcHJldlZhbHVlcy53aWR0aDtcbiAgICAgICAgICAgICAgICBjaGFuZ2UuaGVpZ2h0ID1cbiAgICAgICAgICAgICAgICAgICAgaXNIZWlnaHRDaGFuZ2UgJiYgKCFyZXNpemVEaXJlY3Rpb24gfHwgcmVzaXplRGlyZWN0aW9uID09PSAndmVydGljYWwnKSA/IGhlaWdodCA6IHByZXZWYWx1ZXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMud2lkdGggPSBjaGFuZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy5oZWlnaHQgPSBjaGFuZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRml4IGV4cGFuZFBhcmVudCB3aGVuIHJlc2l6aW5nIGZyb20gdG9wL2xlZnRcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIG5vZGUuZXhwYW5kUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeExpbWl0ID0gbm9kZU9yaWdpblswXSAqIChjaGFuZ2Uud2lkdGggPz8gMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS54ICYmIGNoYW5nZS54IDwgeExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMueCA9IHhMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZXMueCA9IHN0YXJ0VmFsdWVzLnggLSAoY2hhbmdlLnggLSB4TGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB5TGltaXQgPSBub2RlT3JpZ2luWzFdICogKGNoYW5nZS5oZWlnaHQgPz8gMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS55ICYmIGNoYW5nZS55IDwgeUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMueSA9IHlMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZXMueSA9IHN0YXJ0VmFsdWVzLnkgLSAoY2hhbmdlLnkgLSB5TGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGdldFJlc2l6ZURpcmVjdGlvbih7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByZXZWYWx1ZXMud2lkdGgsXG4gICAgICAgICAgICAgICAgcHJldldpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcHJldlZhbHVlcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgcHJldkhlaWdodCxcbiAgICAgICAgICAgICAgICBhZmZlY3RzWDogY29udHJvbERpcmVjdGlvbi5hZmZlY3RzWCxcbiAgICAgICAgICAgICAgICBhZmZlY3RzWTogY29udHJvbERpcmVjdGlvbi5hZmZlY3RzWSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlcyA9IHsgLi4ucHJldlZhbHVlcywgZGlyZWN0aW9uIH07XG4gICAgICAgICAgICBjb25zdCBjYWxsUmVzaXplID0gc2hvdWxkUmVzaXplPy4oZXZlbnQsIG5leHRWYWx1ZXMpO1xuICAgICAgICAgICAgaWYgKGNhbGxSZXNpemUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25SZXNpemU/LihldmVudCwgbmV4dFZhbHVlcyk7XG4gICAgICAgICAgICBvbkNoYW5nZShjaGFuZ2UsIGNoaWxkQ2hhbmdlcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2VuZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25SZXNpemVFbmQ/LihldmVudCwgeyAuLi5wcmV2VmFsdWVzIH0pO1xuICAgICAgICAgICAgb25FbmQ/Lih7IC4uLnByZXZWYWx1ZXMgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxlY3Rpb24uY2FsbChkcmFnSGFuZGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHNlbGVjdGlvbi5vbignLmRyYWcnLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkZXN0cm95LFxuICAgIH07XG59XG5cbmV4cG9ydCB7IENvbm5lY3Rpb25MaW5lVHlwZSwgQ29ubmVjdGlvbk1vZGUsIE1hcmtlclR5cGUsIFBhbk9uU2Nyb2xsTW9kZSwgUG9zaXRpb24sIFJlc2l6ZUNvbnRyb2xWYXJpYW50LCBTZWxlY3Rpb25Nb2RlLCBYWURyYWcsIFhZSGFuZGxlLCBYWU1pbmltYXAsIFhZUGFuWm9vbSwgWFlSZXNpemVyLCBYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMsIFhZX1JFU0laRVJfTElORV9QT1NJVElPTlMsIGFkZEVkZ2UsIGFkb3B0VXNlck5vZGVzLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsLCBhcmVTZXRzRXF1YWwsIGJveFRvUmVjdCwgY2FsY0F1dG9QYW4sIGNhbGN1bGF0ZU5vZGVQb3NpdGlvbiwgY2xhbXAsIGNsYW1wUG9zaXRpb24sIGNsYW1wUG9zaXRpb25Ub1BhcmVudCwgY3JlYXRlTWFya2VySWRzLCBkZXZXYXJuLCBlbGVtZW50U2VsZWN0aW9uS2V5cywgZXJyb3JNZXNzYWdlcywgZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uLCBmaXRWaWV3cG9ydCwgZ2V0QmV6aWVyRWRnZUNlbnRlciwgZ2V0QmV6aWVyUGF0aCwgZ2V0Qm91bmRzT2ZCb3hlcywgZ2V0Qm91bmRzT2ZSZWN0cywgZ2V0Q29ubmVjdGVkRWRnZXMsIGdldENvbm5lY3Rpb25TdGF0dXMsIGdldERpbWVuc2lvbnMsIGdldEVkZ2VDZW50ZXIsIGdldEVkZ2VQb3NpdGlvbiwgZ2V0RWxlbWVudHNUb1JlbW92ZSwgZ2V0RWxldmF0ZWRFZGdlWkluZGV4LCBnZXRFdmVudFBvc2l0aW9uLCBnZXRIYW5kbGVCb3VuZHMsIGdldEhhbmRsZVBvc2l0aW9uLCBnZXRIb3N0Rm9yRWxlbWVudCwgZ2V0SW5jb21lcnMsIGdldEludGVybmFsTm9kZXNCb3VuZHMsIGdldE1hcmtlcklkLCBnZXROb2RlRGltZW5zaW9ucywgZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbiwgZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0sIGdldE5vZGVzQm91bmRzLCBnZXROb2Rlc0luc2lkZSwgZ2V0T3V0Z29lcnMsIGdldE92ZXJsYXBwaW5nQXJlYSwgZ2V0UG9pbnRlclBvc2l0aW9uLCBnZXRTbW9vdGhTdGVwUGF0aCwgZ2V0U3RyYWlnaHRQYXRoLCBnZXRWaWV3cG9ydEZvckJvdW5kcywgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZSwgaGFuZGxlRXhwYW5kUGFyZW50LCBpbmZpbml0ZUV4dGVudCwgaW5pdGlhbENvbm5lY3Rpb24sIGlzQ29vcmRpbmF0ZUV4dGVudCwgaXNFZGdlQmFzZSwgaXNFZGdlVmlzaWJsZSwgaXNJbnB1dERPTU5vZGUsIGlzSW50ZXJuYWxOb2RlQmFzZSwgaXNNYWNPcywgaXNNb3VzZUV2ZW50LCBpc05vZGVCYXNlLCBpc051bWVyaWMsIGlzUmVjdE9iamVjdCwgbm9kZUhhc0RpbWVuc2lvbnMsIG5vZGVUb0JveCwgbm9kZVRvUmVjdCwgb3Bwb3NpdGVQb3NpdGlvbiwgcGFuQnksIHBvaW50VG9SZW5kZXJlclBvaW50LCByZWNvbm5lY3RFZGdlLCByZWN0VG9Cb3gsIHJlbmRlcmVyUG9pbnRUb1BvaW50LCBzaGFsbG93Tm9kZURhdGEsIHNuYXBQb3NpdGlvbiwgdXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMsIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAsIHVwZGF0ZU5vZGVJbnRlcm5hbHMsIHdpdGhSZXNvbHZlcnMgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@xyflow/react/dist/style.css":
/*!***************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/style.css ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"0ce71f87aa41\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L3N0eWxlLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsiL1VzZXJzL3VzZXIvbm90ZXNvbnVuaXZlcnNlL25vZGVfbW9kdWxlcy9AeHlmbG93L3JlYWN0L2Rpc3Qvc3R5bGUuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiMGNlNzFmODdhYTQxXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@xyflow/react/dist/style.css\n");

/***/ }),

/***/ "(rsc)/./node_modules/@xyflow/react/dist/esm/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/esm/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Background: () => (/* binding */ Background),
/* harmony export */   BackgroundVariant: () => (/* binding */ BackgroundVariant),
/* harmony export */   BaseEdge: () => (/* binding */ BaseEdge),
/* harmony export */   BezierEdge: () => (/* binding */ BezierEdge),
/* harmony export */   ConnectionLineType: () => (/* binding */ ConnectionLineType),
/* harmony export */   ConnectionMode: () => (/* binding */ ConnectionMode),
/* harmony export */   ControlButton: () => (/* binding */ ControlButton),
/* harmony export */   Controls: () => (/* binding */ Controls),
/* harmony export */   EdgeLabelRenderer: () => (/* binding */ EdgeLabelRenderer),
/* harmony export */   EdgeText: () => (/* binding */ EdgeText),
/* harmony export */   Handle: () => (/* binding */ Handle),
/* harmony export */   MarkerType: () => (/* binding */ MarkerType),
/* harmony export */   MiniMap: () => (/* binding */ MiniMap),
/* harmony export */   NodeResizeControl: () => (/* binding */ NodeResizeControl),
/* harmony export */   NodeResizer: () => (/* binding */ NodeResizer),
/* harmony export */   NodeToolbar: () => (/* binding */ NodeToolbar),
/* harmony export */   PanOnScrollMode: () => (/* binding */ PanOnScrollMode),
/* harmony export */   Panel: () => (/* binding */ Panel),
/* harmony export */   Position: () => (/* binding */ Position),
/* harmony export */   ReactFlow: () => (/* binding */ ReactFlow),
/* harmony export */   ReactFlowProvider: () => (/* binding */ ReactFlowProvider),
/* harmony export */   ResizeControlVariant: () => (/* binding */ ResizeControlVariant),
/* harmony export */   SelectionMode: () => (/* binding */ SelectionMode),
/* harmony export */   SimpleBezierEdge: () => (/* binding */ SimpleBezierEdge),
/* harmony export */   SmoothStepEdge: () => (/* binding */ SmoothStepEdge),
/* harmony export */   StepEdge: () => (/* binding */ StepEdge),
/* harmony export */   StraightEdge: () => (/* binding */ StraightEdge),
/* harmony export */   ViewportPortal: () => (/* binding */ ViewportPortal),
/* harmony export */   addEdge: () => (/* binding */ addEdge),
/* harmony export */   applyEdgeChanges: () => (/* binding */ applyEdgeChanges),
/* harmony export */   applyNodeChanges: () => (/* binding */ applyNodeChanges),
/* harmony export */   getBezierEdgeCenter: () => (/* binding */ getBezierEdgeCenter),
/* harmony export */   getBezierPath: () => (/* binding */ getBezierPath),
/* harmony export */   getConnectedEdges: () => (/* binding */ getConnectedEdges),
/* harmony export */   getEdgeCenter: () => (/* binding */ getEdgeCenter),
/* harmony export */   getIncomers: () => (/* binding */ getIncomers),
/* harmony export */   getNodesBounds: () => (/* binding */ getNodesBounds),
/* harmony export */   getOutgoers: () => (/* binding */ getOutgoers),
/* harmony export */   getSimpleBezierPath: () => (/* binding */ getSimpleBezierPath),
/* harmony export */   getSmoothStepPath: () => (/* binding */ getSmoothStepPath),
/* harmony export */   getStraightPath: () => (/* binding */ getStraightPath),
/* harmony export */   getViewportForBounds: () => (/* binding */ getViewportForBounds),
/* harmony export */   isEdge: () => (/* binding */ isEdge),
/* harmony export */   isNode: () => (/* binding */ isNode),
/* harmony export */   reconnectEdge: () => (/* binding */ reconnectEdge),
/* harmony export */   useConnection: () => (/* binding */ useConnection),
/* harmony export */   useEdges: () => (/* binding */ useEdges),
/* harmony export */   useEdgesState: () => (/* binding */ useEdgesState),
/* harmony export */   useHandleConnections: () => (/* binding */ useHandleConnections),
/* harmony export */   useInternalNode: () => (/* binding */ useInternalNode),
/* harmony export */   useKeyPress: () => (/* binding */ useKeyPress),
/* harmony export */   useNodeConnections: () => (/* binding */ useNodeConnections),
/* harmony export */   useNodeId: () => (/* binding */ useNodeId),
/* harmony export */   useNodes: () => (/* binding */ useNodes),
/* harmony export */   useNodesData: () => (/* binding */ useNodesData),
/* harmony export */   useNodesInitialized: () => (/* binding */ useNodesInitialized),
/* harmony export */   useNodesState: () => (/* binding */ useNodesState),
/* harmony export */   useOnSelectionChange: () => (/* binding */ useOnSelectionChange),
/* harmony export */   useOnViewportChange: () => (/* binding */ useOnViewportChange),
/* harmony export */   useReactFlow: () => (/* binding */ useReactFlow),
/* harmony export */   useStore: () => (/* binding */ useStore),
/* harmony export */   useStoreApi: () => (/* binding */ useStoreApi),
/* harmony export */   useUpdateNodeInternals: () => (/* binding */ useUpdateNodeInternals),
/* harmony export */   useViewport: () => (/* binding */ useViewport)
/* harmony export */ });
/* harmony import */ var react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-server-dom-webpack/server.edge */ "(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-webpack-server-edge.js");
/* harmony import */ var react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__);

const ConnectionLineType = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call ConnectionLineType() from the server but ConnectionLineType is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"ConnectionLineType",
);const ConnectionMode = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call ConnectionMode() from the server but ConnectionMode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"ConnectionMode",
);const MarkerType = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call MarkerType() from the server but MarkerType is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"MarkerType",
);const PanOnScrollMode = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call PanOnScrollMode() from the server but PanOnScrollMode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"PanOnScrollMode",
);const Position = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call Position() from the server but Position is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"Position",
);const ResizeControlVariant = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call ResizeControlVariant() from the server but ResizeControlVariant is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"ResizeControlVariant",
);const SelectionMode = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call SelectionMode() from the server but SelectionMode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"SelectionMode",
);const addEdge = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call addEdge() from the server but addEdge is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"addEdge",
);const getBezierEdgeCenter = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call getBezierEdgeCenter() from the server but getBezierEdgeCenter is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"getBezierEdgeCenter",
);const getBezierPath = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call getBezierPath() from the server but getBezierPath is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"getBezierPath",
);const getConnectedEdges = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call getConnectedEdges() from the server but getConnectedEdges is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"getConnectedEdges",
);const getEdgeCenter = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call getEdgeCenter() from the server but getEdgeCenter is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"getEdgeCenter",
);const getIncomers = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call getIncomers() from the server but getIncomers is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"getIncomers",
);const getNodesBounds = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call getNodesBounds() from the server but getNodesBounds is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"getNodesBounds",
);const getOutgoers = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call getOutgoers() from the server but getOutgoers is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"getOutgoers",
);const getSmoothStepPath = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call getSmoothStepPath() from the server but getSmoothStepPath is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"getSmoothStepPath",
);const getStraightPath = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call getStraightPath() from the server but getStraightPath is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"getStraightPath",
);const getViewportForBounds = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call getViewportForBounds() from the server but getViewportForBounds is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"getViewportForBounds",
);const reconnectEdge = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call reconnectEdge() from the server but reconnectEdge is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"reconnectEdge",
);const Background = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call Background() from the server but Background is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"Background",
);const BackgroundVariant = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call BackgroundVariant() from the server but BackgroundVariant is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"BackgroundVariant",
);const BaseEdge = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call BaseEdge() from the server but BaseEdge is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"BaseEdge",
);const BezierEdge = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call BezierEdge() from the server but BezierEdge is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"BezierEdge",
);const ControlButton = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call ControlButton() from the server but ControlButton is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"ControlButton",
);const Controls = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call Controls() from the server but Controls is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"Controls",
);const EdgeLabelRenderer = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call EdgeLabelRenderer() from the server but EdgeLabelRenderer is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"EdgeLabelRenderer",
);const EdgeText = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call EdgeText() from the server but EdgeText is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"EdgeText",
);const Handle = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call Handle() from the server but Handle is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"Handle",
);const MiniMap = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call MiniMap() from the server but MiniMap is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"MiniMap",
);const NodeResizeControl = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call NodeResizeControl() from the server but NodeResizeControl is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"NodeResizeControl",
);const NodeResizer = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call NodeResizer() from the server but NodeResizer is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"NodeResizer",
);const NodeToolbar = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call NodeToolbar() from the server but NodeToolbar is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"NodeToolbar",
);const Panel = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call Panel() from the server but Panel is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"Panel",
);const ReactFlow = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call ReactFlow() from the server but ReactFlow is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"ReactFlow",
);const ReactFlowProvider = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call ReactFlowProvider() from the server but ReactFlowProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"ReactFlowProvider",
);const SimpleBezierEdge = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call SimpleBezierEdge() from the server but SimpleBezierEdge is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"SimpleBezierEdge",
);const SmoothStepEdge = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call SmoothStepEdge() from the server but SmoothStepEdge is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"SmoothStepEdge",
);const StepEdge = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call StepEdge() from the server but StepEdge is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"StepEdge",
);const StraightEdge = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call StraightEdge() from the server but StraightEdge is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"StraightEdge",
);const ViewportPortal = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call ViewportPortal() from the server but ViewportPortal is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"ViewportPortal",
);const applyEdgeChanges = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call applyEdgeChanges() from the server but applyEdgeChanges is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"applyEdgeChanges",
);const applyNodeChanges = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call applyNodeChanges() from the server but applyNodeChanges is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"applyNodeChanges",
);const getSimpleBezierPath = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call getSimpleBezierPath() from the server but getSimpleBezierPath is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"getSimpleBezierPath",
);const isEdge = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call isEdge() from the server but isEdge is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"isEdge",
);const isNode = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call isNode() from the server but isNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"isNode",
);const useConnection = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useConnection() from the server but useConnection is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useConnection",
);const useEdges = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useEdges() from the server but useEdges is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useEdges",
);const useEdgesState = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useEdgesState() from the server but useEdgesState is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useEdgesState",
);const useHandleConnections = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useHandleConnections() from the server but useHandleConnections is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useHandleConnections",
);const useInternalNode = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useInternalNode() from the server but useInternalNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useInternalNode",
);const useKeyPress = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useKeyPress() from the server but useKeyPress is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useKeyPress",
);const useNodeConnections = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useNodeConnections() from the server but useNodeConnections is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useNodeConnections",
);const useNodeId = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useNodeId() from the server but useNodeId is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useNodeId",
);const useNodes = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useNodes() from the server but useNodes is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useNodes",
);const useNodesData = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useNodesData() from the server but useNodesData is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useNodesData",
);const useNodesInitialized = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useNodesInitialized() from the server but useNodesInitialized is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useNodesInitialized",
);const useNodesState = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useNodesState() from the server but useNodesState is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useNodesState",
);const useOnSelectionChange = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useOnSelectionChange() from the server but useOnSelectionChange is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useOnSelectionChange",
);const useOnViewportChange = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useOnViewportChange() from the server but useOnViewportChange is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useOnViewportChange",
);const useReactFlow = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useReactFlow() from the server but useReactFlow is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useReactFlow",
);const useStore = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useStore() from the server but useStore is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useStore",
);const useStoreApi = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useStoreApi() from the server but useStoreApi is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useStoreApi",
);const useUpdateNodeInternals = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useUpdateNodeInternals() from the server but useUpdateNodeInternals is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useUpdateNodeInternals",
);const useViewport = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useViewport() from the server but useViewport is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/user/notesonuniverse/node_modules/@xyflow/react/dist/esm/index.js",
"useViewport",
);

/***/ })

};
;